// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/contrib/boosted_trees/proto/learner.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto 

namespace protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto
namespace tensorflow {
namespace boosted_trees {
namespace learner {
class AveragingConfig;
class AveragingConfigDefaultTypeInternal;
extern AveragingConfigDefaultTypeInternal _AveragingConfig_default_instance_;
class LearnerConfig;
class LearnerConfigDefaultTypeInternal;
extern LearnerConfigDefaultTypeInternal _LearnerConfig_default_instance_;
class LearningRateConfig;
class LearningRateConfigDefaultTypeInternal;
extern LearningRateConfigDefaultTypeInternal _LearningRateConfig_default_instance_;
class LearningRateDropoutDrivenConfig;
class LearningRateDropoutDrivenConfigDefaultTypeInternal;
extern LearningRateDropoutDrivenConfigDefaultTypeInternal _LearningRateDropoutDrivenConfig_default_instance_;
class LearningRateFixedConfig;
class LearningRateFixedConfigDefaultTypeInternal;
extern LearningRateFixedConfigDefaultTypeInternal _LearningRateFixedConfig_default_instance_;
class LearningRateLineSearchConfig;
class LearningRateLineSearchConfigDefaultTypeInternal;
extern LearningRateLineSearchConfigDefaultTypeInternal _LearningRateLineSearchConfig_default_instance_;
class TreeConstraintsConfig;
class TreeConstraintsConfigDefaultTypeInternal;
extern TreeConstraintsConfigDefaultTypeInternal _TreeConstraintsConfig_default_instance_;
class TreeRegularizationConfig;
class TreeRegularizationConfigDefaultTypeInternal;
extern TreeRegularizationConfigDefaultTypeInternal _TreeRegularizationConfig_default_instance_;
}  // namespace learner
}  // namespace boosted_trees
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::boosted_trees::learner::AveragingConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::learner::AveragingConfig>(Arena*);
template<> ::tensorflow::boosted_trees::learner::LearnerConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::learner::LearnerConfig>(Arena*);
template<> ::tensorflow::boosted_trees::learner::LearningRateConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::learner::LearningRateConfig>(Arena*);
template<> ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig>(Arena*);
template<> ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::learner::LearningRateFixedConfig>(Arena*);
template<> ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig>(Arena*);
template<> ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::learner::TreeConstraintsConfig>(Arena*);
template<> ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::learner::TreeRegularizationConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace boosted_trees {
namespace learner {

enum LearnerConfig_PruningMode {
  LearnerConfig_PruningMode_PRUNING_MODE_UNSPECIFIED = 0,
  LearnerConfig_PruningMode_PRE_PRUNE = 1,
  LearnerConfig_PruningMode_POST_PRUNE = 2,
  LearnerConfig_PruningMode_LearnerConfig_PruningMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LearnerConfig_PruningMode_LearnerConfig_PruningMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LearnerConfig_PruningMode_IsValid(int value);
const LearnerConfig_PruningMode LearnerConfig_PruningMode_PruningMode_MIN = LearnerConfig_PruningMode_PRUNING_MODE_UNSPECIFIED;
const LearnerConfig_PruningMode LearnerConfig_PruningMode_PruningMode_MAX = LearnerConfig_PruningMode_POST_PRUNE;
const int LearnerConfig_PruningMode_PruningMode_ARRAYSIZE = LearnerConfig_PruningMode_PruningMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* LearnerConfig_PruningMode_descriptor();
inline const ::std::string& LearnerConfig_PruningMode_Name(LearnerConfig_PruningMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LearnerConfig_PruningMode_descriptor(), value);
}
inline bool LearnerConfig_PruningMode_Parse(
    const ::std::string& name, LearnerConfig_PruningMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LearnerConfig_PruningMode>(
    LearnerConfig_PruningMode_descriptor(), name, value);
}
enum LearnerConfig_GrowingMode {
  LearnerConfig_GrowingMode_GROWING_MODE_UNSPECIFIED = 0,
  LearnerConfig_GrowingMode_WHOLE_TREE = 1,
  LearnerConfig_GrowingMode_LAYER_BY_LAYER = 2,
  LearnerConfig_GrowingMode_LearnerConfig_GrowingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LearnerConfig_GrowingMode_LearnerConfig_GrowingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LearnerConfig_GrowingMode_IsValid(int value);
const LearnerConfig_GrowingMode LearnerConfig_GrowingMode_GrowingMode_MIN = LearnerConfig_GrowingMode_GROWING_MODE_UNSPECIFIED;
const LearnerConfig_GrowingMode LearnerConfig_GrowingMode_GrowingMode_MAX = LearnerConfig_GrowingMode_LAYER_BY_LAYER;
const int LearnerConfig_GrowingMode_GrowingMode_ARRAYSIZE = LearnerConfig_GrowingMode_GrowingMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* LearnerConfig_GrowingMode_descriptor();
inline const ::std::string& LearnerConfig_GrowingMode_Name(LearnerConfig_GrowingMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LearnerConfig_GrowingMode_descriptor(), value);
}
inline bool LearnerConfig_GrowingMode_Parse(
    const ::std::string& name, LearnerConfig_GrowingMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LearnerConfig_GrowingMode>(
    LearnerConfig_GrowingMode_descriptor(), name, value);
}
enum LearnerConfig_MultiClassStrategy {
  LearnerConfig_MultiClassStrategy_MULTI_CLASS_STRATEGY_UNSPECIFIED = 0,
  LearnerConfig_MultiClassStrategy_TREE_PER_CLASS = 1,
  LearnerConfig_MultiClassStrategy_FULL_HESSIAN = 2,
  LearnerConfig_MultiClassStrategy_DIAGONAL_HESSIAN = 3,
  LearnerConfig_MultiClassStrategy_LearnerConfig_MultiClassStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LearnerConfig_MultiClassStrategy_LearnerConfig_MultiClassStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LearnerConfig_MultiClassStrategy_IsValid(int value);
const LearnerConfig_MultiClassStrategy LearnerConfig_MultiClassStrategy_MultiClassStrategy_MIN = LearnerConfig_MultiClassStrategy_MULTI_CLASS_STRATEGY_UNSPECIFIED;
const LearnerConfig_MultiClassStrategy LearnerConfig_MultiClassStrategy_MultiClassStrategy_MAX = LearnerConfig_MultiClassStrategy_DIAGONAL_HESSIAN;
const int LearnerConfig_MultiClassStrategy_MultiClassStrategy_ARRAYSIZE = LearnerConfig_MultiClassStrategy_MultiClassStrategy_MAX + 1;

const ::google::protobuf::EnumDescriptor* LearnerConfig_MultiClassStrategy_descriptor();
inline const ::std::string& LearnerConfig_MultiClassStrategy_Name(LearnerConfig_MultiClassStrategy value) {
  return ::google::protobuf::internal::NameOfEnum(
    LearnerConfig_MultiClassStrategy_descriptor(), value);
}
inline bool LearnerConfig_MultiClassStrategy_Parse(
    const ::std::string& name, LearnerConfig_MultiClassStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LearnerConfig_MultiClassStrategy>(
    LearnerConfig_MultiClassStrategy_descriptor(), name, value);
}
enum LearnerConfig_WeakLearnerType {
  LearnerConfig_WeakLearnerType_NORMAL_DECISION_TREE = 0,
  LearnerConfig_WeakLearnerType_OBLIVIOUS_DECISION_TREE = 1,
  LearnerConfig_WeakLearnerType_LearnerConfig_WeakLearnerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LearnerConfig_WeakLearnerType_LearnerConfig_WeakLearnerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LearnerConfig_WeakLearnerType_IsValid(int value);
const LearnerConfig_WeakLearnerType LearnerConfig_WeakLearnerType_WeakLearnerType_MIN = LearnerConfig_WeakLearnerType_NORMAL_DECISION_TREE;
const LearnerConfig_WeakLearnerType LearnerConfig_WeakLearnerType_WeakLearnerType_MAX = LearnerConfig_WeakLearnerType_OBLIVIOUS_DECISION_TREE;
const int LearnerConfig_WeakLearnerType_WeakLearnerType_ARRAYSIZE = LearnerConfig_WeakLearnerType_WeakLearnerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LearnerConfig_WeakLearnerType_descriptor();
inline const ::std::string& LearnerConfig_WeakLearnerType_Name(LearnerConfig_WeakLearnerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LearnerConfig_WeakLearnerType_descriptor(), value);
}
inline bool LearnerConfig_WeakLearnerType_Parse(
    const ::std::string& name, LearnerConfig_WeakLearnerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LearnerConfig_WeakLearnerType>(
    LearnerConfig_WeakLearnerType_descriptor(), name, value);
}
// ===================================================================

class TreeRegularizationConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.learner.TreeRegularizationConfig) */ {
 public:
  TreeRegularizationConfig();
  virtual ~TreeRegularizationConfig();

  TreeRegularizationConfig(const TreeRegularizationConfig& from);

  inline TreeRegularizationConfig& operator=(const TreeRegularizationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TreeRegularizationConfig(TreeRegularizationConfig&& from) noexcept
    : TreeRegularizationConfig() {
    *this = ::std::move(from);
  }

  inline TreeRegularizationConfig& operator=(TreeRegularizationConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeRegularizationConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeRegularizationConfig* internal_default_instance() {
    return reinterpret_cast<const TreeRegularizationConfig*>(
               &_TreeRegularizationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(TreeRegularizationConfig* other);
  void Swap(TreeRegularizationConfig* other);
  friend void swap(TreeRegularizationConfig& a, TreeRegularizationConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TreeRegularizationConfig* New() const final {
    return CreateMaybeMessage<TreeRegularizationConfig>(NULL);
  }

  TreeRegularizationConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TreeRegularizationConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TreeRegularizationConfig& from);
  void MergeFrom(const TreeRegularizationConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeRegularizationConfig* other);
  protected:
  explicit TreeRegularizationConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float l1 = 1;
  void clear_l1();
  static const int kL1FieldNumber = 1;
  float l1() const;
  void set_l1(float value);

  // float l2 = 2;
  void clear_l2();
  static const int kL2FieldNumber = 2;
  float l2() const;
  void set_l2(float value);

  // float tree_complexity = 3;
  void clear_tree_complexity();
  static const int kTreeComplexityFieldNumber = 3;
  float tree_complexity() const;
  void set_tree_complexity(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.learner.TreeRegularizationConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float l1_;
  float l2_;
  float tree_complexity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TreeConstraintsConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.learner.TreeConstraintsConfig) */ {
 public:
  TreeConstraintsConfig();
  virtual ~TreeConstraintsConfig();

  TreeConstraintsConfig(const TreeConstraintsConfig& from);

  inline TreeConstraintsConfig& operator=(const TreeConstraintsConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TreeConstraintsConfig(TreeConstraintsConfig&& from) noexcept
    : TreeConstraintsConfig() {
    *this = ::std::move(from);
  }

  inline TreeConstraintsConfig& operator=(TreeConstraintsConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeConstraintsConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeConstraintsConfig* internal_default_instance() {
    return reinterpret_cast<const TreeConstraintsConfig*>(
               &_TreeConstraintsConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(TreeConstraintsConfig* other);
  void Swap(TreeConstraintsConfig* other);
  friend void swap(TreeConstraintsConfig& a, TreeConstraintsConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TreeConstraintsConfig* New() const final {
    return CreateMaybeMessage<TreeConstraintsConfig>(NULL);
  }

  TreeConstraintsConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TreeConstraintsConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TreeConstraintsConfig& from);
  void MergeFrom(const TreeConstraintsConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeConstraintsConfig* other);
  protected:
  explicit TreeConstraintsConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 max_tree_depth = 1;
  void clear_max_tree_depth();
  static const int kMaxTreeDepthFieldNumber = 1;
  ::google::protobuf::uint32 max_tree_depth() const;
  void set_max_tree_depth(::google::protobuf::uint32 value);

  // float min_node_weight = 2;
  void clear_min_node_weight();
  static const int kMinNodeWeightFieldNumber = 2;
  float min_node_weight() const;
  void set_min_node_weight(float value);

  // int64 max_number_of_unique_feature_columns = 3;
  void clear_max_number_of_unique_feature_columns();
  static const int kMaxNumberOfUniqueFeatureColumnsFieldNumber = 3;
  ::google::protobuf::int64 max_number_of_unique_feature_columns() const;
  void set_max_number_of_unique_feature_columns(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.learner.TreeConstraintsConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::uint32 max_tree_depth_;
  float min_node_weight_;
  ::google::protobuf::int64 max_number_of_unique_feature_columns_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningRateConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.learner.LearningRateConfig) */ {
 public:
  LearningRateConfig();
  virtual ~LearningRateConfig();

  LearningRateConfig(const LearningRateConfig& from);

  inline LearningRateConfig& operator=(const LearningRateConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearningRateConfig(LearningRateConfig&& from) noexcept
    : LearningRateConfig() {
    *this = ::std::move(from);
  }

  inline LearningRateConfig& operator=(LearningRateConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningRateConfig& default_instance();

  enum TunerCase {
    kFixed = 1,
    kDropout = 2,
    kLineSearch = 3,
    TUNER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LearningRateConfig* internal_default_instance() {
    return reinterpret_cast<const LearningRateConfig*>(
               &_LearningRateConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(LearningRateConfig* other);
  void Swap(LearningRateConfig* other);
  friend void swap(LearningRateConfig& a, LearningRateConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearningRateConfig* New() const final {
    return CreateMaybeMessage<LearningRateConfig>(NULL);
  }

  LearningRateConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LearningRateConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LearningRateConfig& from);
  void MergeFrom(const LearningRateConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningRateConfig* other);
  protected:
  explicit LearningRateConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.boosted_trees.learner.LearningRateFixedConfig fixed = 1;
  bool has_fixed() const;
  void clear_fixed();
  static const int kFixedFieldNumber = 1;
  private:
  const ::tensorflow::boosted_trees::learner::LearningRateFixedConfig& _internal_fixed() const;
  public:
  const ::tensorflow::boosted_trees::learner::LearningRateFixedConfig& fixed() const;
  ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* release_fixed();
  ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* mutable_fixed();
  void set_allocated_fixed(::tensorflow::boosted_trees::learner::LearningRateFixedConfig* fixed);
  void unsafe_arena_set_allocated_fixed(
      ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* fixed);
  ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* unsafe_arena_release_fixed();

  // .tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig dropout = 2;
  bool has_dropout() const;
  void clear_dropout();
  static const int kDropoutFieldNumber = 2;
  private:
  const ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig& _internal_dropout() const;
  public:
  const ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig& dropout() const;
  ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* release_dropout();
  ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* mutable_dropout();
  void set_allocated_dropout(::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* dropout);
  void unsafe_arena_set_allocated_dropout(
      ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* dropout);
  ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* unsafe_arena_release_dropout();

  // .tensorflow.boosted_trees.learner.LearningRateLineSearchConfig line_search = 3;
  bool has_line_search() const;
  void clear_line_search();
  static const int kLineSearchFieldNumber = 3;
  private:
  const ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig& _internal_line_search() const;
  public:
  const ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig& line_search() const;
  ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* release_line_search();
  ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* mutable_line_search();
  void set_allocated_line_search(::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* line_search);
  void unsafe_arena_set_allocated_line_search(
      ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* line_search);
  ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* unsafe_arena_release_line_search();

  void clear_tuner();
  TunerCase tuner_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.learner.LearningRateConfig)
 private:
  void set_has_fixed();
  void set_has_dropout();
  void set_has_line_search();

  inline bool has_tuner() const;
  inline void clear_has_tuner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TunerUnion {
    TunerUnion() {}
    ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* fixed_;
    ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* dropout_;
    ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* line_search_;
  } tuner_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningRateFixedConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.learner.LearningRateFixedConfig) */ {
 public:
  LearningRateFixedConfig();
  virtual ~LearningRateFixedConfig();

  LearningRateFixedConfig(const LearningRateFixedConfig& from);

  inline LearningRateFixedConfig& operator=(const LearningRateFixedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearningRateFixedConfig(LearningRateFixedConfig&& from) noexcept
    : LearningRateFixedConfig() {
    *this = ::std::move(from);
  }

  inline LearningRateFixedConfig& operator=(LearningRateFixedConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningRateFixedConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LearningRateFixedConfig* internal_default_instance() {
    return reinterpret_cast<const LearningRateFixedConfig*>(
               &_LearningRateFixedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(LearningRateFixedConfig* other);
  void Swap(LearningRateFixedConfig* other);
  friend void swap(LearningRateFixedConfig& a, LearningRateFixedConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearningRateFixedConfig* New() const final {
    return CreateMaybeMessage<LearningRateFixedConfig>(NULL);
  }

  LearningRateFixedConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LearningRateFixedConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LearningRateFixedConfig& from);
  void MergeFrom(const LearningRateFixedConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningRateFixedConfig* other);
  protected:
  explicit LearningRateFixedConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float learning_rate = 1;
  void clear_learning_rate();
  static const int kLearningRateFieldNumber = 1;
  float learning_rate() const;
  void set_learning_rate(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.learner.LearningRateFixedConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float learning_rate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningRateLineSearchConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.learner.LearningRateLineSearchConfig) */ {
 public:
  LearningRateLineSearchConfig();
  virtual ~LearningRateLineSearchConfig();

  LearningRateLineSearchConfig(const LearningRateLineSearchConfig& from);

  inline LearningRateLineSearchConfig& operator=(const LearningRateLineSearchConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearningRateLineSearchConfig(LearningRateLineSearchConfig&& from) noexcept
    : LearningRateLineSearchConfig() {
    *this = ::std::move(from);
  }

  inline LearningRateLineSearchConfig& operator=(LearningRateLineSearchConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningRateLineSearchConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LearningRateLineSearchConfig* internal_default_instance() {
    return reinterpret_cast<const LearningRateLineSearchConfig*>(
               &_LearningRateLineSearchConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(LearningRateLineSearchConfig* other);
  void Swap(LearningRateLineSearchConfig* other);
  friend void swap(LearningRateLineSearchConfig& a, LearningRateLineSearchConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearningRateLineSearchConfig* New() const final {
    return CreateMaybeMessage<LearningRateLineSearchConfig>(NULL);
  }

  LearningRateLineSearchConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LearningRateLineSearchConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LearningRateLineSearchConfig& from);
  void MergeFrom(const LearningRateLineSearchConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningRateLineSearchConfig* other);
  protected:
  explicit LearningRateLineSearchConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float max_learning_rate = 1;
  void clear_max_learning_rate();
  static const int kMaxLearningRateFieldNumber = 1;
  float max_learning_rate() const;
  void set_max_learning_rate(float value);

  // int32 num_steps = 2;
  void clear_num_steps();
  static const int kNumStepsFieldNumber = 2;
  ::google::protobuf::int32 num_steps() const;
  void set_num_steps(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.learner.LearningRateLineSearchConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float max_learning_rate_;
  ::google::protobuf::int32 num_steps_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AveragingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.learner.AveragingConfig) */ {
 public:
  AveragingConfig();
  virtual ~AveragingConfig();

  AveragingConfig(const AveragingConfig& from);

  inline AveragingConfig& operator=(const AveragingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AveragingConfig(AveragingConfig&& from) noexcept
    : AveragingConfig() {
    *this = ::std::move(from);
  }

  inline AveragingConfig& operator=(AveragingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AveragingConfig& default_instance();

  enum ConfigCase {
    kAverageLastNTrees = 1,
    kAverageLastPercentTrees = 2,
    CONFIG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AveragingConfig* internal_default_instance() {
    return reinterpret_cast<const AveragingConfig*>(
               &_AveragingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(AveragingConfig* other);
  void Swap(AveragingConfig* other);
  friend void swap(AveragingConfig& a, AveragingConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AveragingConfig* New() const final {
    return CreateMaybeMessage<AveragingConfig>(NULL);
  }

  AveragingConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AveragingConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AveragingConfig& from);
  void MergeFrom(const AveragingConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AveragingConfig* other);
  protected:
  explicit AveragingConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float average_last_n_trees = 1;
  private:
  bool has_average_last_n_trees() const;
  public:
  void clear_average_last_n_trees();
  static const int kAverageLastNTreesFieldNumber = 1;
  float average_last_n_trees() const;
  void set_average_last_n_trees(float value);

  // float average_last_percent_trees = 2;
  private:
  bool has_average_last_percent_trees() const;
  public:
  void clear_average_last_percent_trees();
  static const int kAverageLastPercentTreesFieldNumber = 2;
  float average_last_percent_trees() const;
  void set_average_last_percent_trees(float value);

  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.learner.AveragingConfig)
 private:
  void set_has_average_last_n_trees();
  void set_has_average_last_percent_trees();

  inline bool has_config() const;
  inline void clear_has_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ConfigUnion {
    ConfigUnion() {}
    float average_last_n_trees_;
    float average_last_percent_trees_;
  } config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningRateDropoutDrivenConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig) */ {
 public:
  LearningRateDropoutDrivenConfig();
  virtual ~LearningRateDropoutDrivenConfig();

  LearningRateDropoutDrivenConfig(const LearningRateDropoutDrivenConfig& from);

  inline LearningRateDropoutDrivenConfig& operator=(const LearningRateDropoutDrivenConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearningRateDropoutDrivenConfig(LearningRateDropoutDrivenConfig&& from) noexcept
    : LearningRateDropoutDrivenConfig() {
    *this = ::std::move(from);
  }

  inline LearningRateDropoutDrivenConfig& operator=(LearningRateDropoutDrivenConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningRateDropoutDrivenConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LearningRateDropoutDrivenConfig* internal_default_instance() {
    return reinterpret_cast<const LearningRateDropoutDrivenConfig*>(
               &_LearningRateDropoutDrivenConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(LearningRateDropoutDrivenConfig* other);
  void Swap(LearningRateDropoutDrivenConfig* other);
  friend void swap(LearningRateDropoutDrivenConfig& a, LearningRateDropoutDrivenConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearningRateDropoutDrivenConfig* New() const final {
    return CreateMaybeMessage<LearningRateDropoutDrivenConfig>(NULL);
  }

  LearningRateDropoutDrivenConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LearningRateDropoutDrivenConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LearningRateDropoutDrivenConfig& from);
  void MergeFrom(const LearningRateDropoutDrivenConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningRateDropoutDrivenConfig* other);
  protected:
  explicit LearningRateDropoutDrivenConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float dropout_probability = 1;
  void clear_dropout_probability();
  static const int kDropoutProbabilityFieldNumber = 1;
  float dropout_probability() const;
  void set_dropout_probability(float value);

  // float probability_of_skipping_dropout = 2;
  void clear_probability_of_skipping_dropout();
  static const int kProbabilityOfSkippingDropoutFieldNumber = 2;
  float probability_of_skipping_dropout() const;
  void set_probability_of_skipping_dropout(float value);

  // float learning_rate = 3;
  void clear_learning_rate();
  static const int kLearningRateFieldNumber = 3;
  float learning_rate() const;
  void set_learning_rate(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float dropout_probability_;
  float probability_of_skipping_dropout_;
  float learning_rate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearnerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.learner.LearnerConfig) */ {
 public:
  LearnerConfig();
  virtual ~LearnerConfig();

  LearnerConfig(const LearnerConfig& from);

  inline LearnerConfig& operator=(const LearnerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearnerConfig(LearnerConfig&& from) noexcept
    : LearnerConfig() {
    *this = ::std::move(from);
  }

  inline LearnerConfig& operator=(LearnerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LearnerConfig& default_instance();

  enum FeatureFractionCase {
    kFeatureFractionPerTree = 2,
    kFeatureFractionPerLevel = 3,
    FEATURE_FRACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LearnerConfig* internal_default_instance() {
    return reinterpret_cast<const LearnerConfig*>(
               &_LearnerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(LearnerConfig* other);
  void Swap(LearnerConfig* other);
  friend void swap(LearnerConfig& a, LearnerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearnerConfig* New() const final {
    return CreateMaybeMessage<LearnerConfig>(NULL);
  }

  LearnerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LearnerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LearnerConfig& from);
  void MergeFrom(const LearnerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearnerConfig* other);
  protected:
  explicit LearnerConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LearnerConfig_PruningMode PruningMode;
  static const PruningMode PRUNING_MODE_UNSPECIFIED =
    LearnerConfig_PruningMode_PRUNING_MODE_UNSPECIFIED;
  static const PruningMode PRE_PRUNE =
    LearnerConfig_PruningMode_PRE_PRUNE;
  static const PruningMode POST_PRUNE =
    LearnerConfig_PruningMode_POST_PRUNE;
  static inline bool PruningMode_IsValid(int value) {
    return LearnerConfig_PruningMode_IsValid(value);
  }
  static const PruningMode PruningMode_MIN =
    LearnerConfig_PruningMode_PruningMode_MIN;
  static const PruningMode PruningMode_MAX =
    LearnerConfig_PruningMode_PruningMode_MAX;
  static const int PruningMode_ARRAYSIZE =
    LearnerConfig_PruningMode_PruningMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PruningMode_descriptor() {
    return LearnerConfig_PruningMode_descriptor();
  }
  static inline const ::std::string& PruningMode_Name(PruningMode value) {
    return LearnerConfig_PruningMode_Name(value);
  }
  static inline bool PruningMode_Parse(const ::std::string& name,
      PruningMode* value) {
    return LearnerConfig_PruningMode_Parse(name, value);
  }

  typedef LearnerConfig_GrowingMode GrowingMode;
  static const GrowingMode GROWING_MODE_UNSPECIFIED =
    LearnerConfig_GrowingMode_GROWING_MODE_UNSPECIFIED;
  static const GrowingMode WHOLE_TREE =
    LearnerConfig_GrowingMode_WHOLE_TREE;
  static const GrowingMode LAYER_BY_LAYER =
    LearnerConfig_GrowingMode_LAYER_BY_LAYER;
  static inline bool GrowingMode_IsValid(int value) {
    return LearnerConfig_GrowingMode_IsValid(value);
  }
  static const GrowingMode GrowingMode_MIN =
    LearnerConfig_GrowingMode_GrowingMode_MIN;
  static const GrowingMode GrowingMode_MAX =
    LearnerConfig_GrowingMode_GrowingMode_MAX;
  static const int GrowingMode_ARRAYSIZE =
    LearnerConfig_GrowingMode_GrowingMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GrowingMode_descriptor() {
    return LearnerConfig_GrowingMode_descriptor();
  }
  static inline const ::std::string& GrowingMode_Name(GrowingMode value) {
    return LearnerConfig_GrowingMode_Name(value);
  }
  static inline bool GrowingMode_Parse(const ::std::string& name,
      GrowingMode* value) {
    return LearnerConfig_GrowingMode_Parse(name, value);
  }

  typedef LearnerConfig_MultiClassStrategy MultiClassStrategy;
  static const MultiClassStrategy MULTI_CLASS_STRATEGY_UNSPECIFIED =
    LearnerConfig_MultiClassStrategy_MULTI_CLASS_STRATEGY_UNSPECIFIED;
  static const MultiClassStrategy TREE_PER_CLASS =
    LearnerConfig_MultiClassStrategy_TREE_PER_CLASS;
  static const MultiClassStrategy FULL_HESSIAN =
    LearnerConfig_MultiClassStrategy_FULL_HESSIAN;
  static const MultiClassStrategy DIAGONAL_HESSIAN =
    LearnerConfig_MultiClassStrategy_DIAGONAL_HESSIAN;
  static inline bool MultiClassStrategy_IsValid(int value) {
    return LearnerConfig_MultiClassStrategy_IsValid(value);
  }
  static const MultiClassStrategy MultiClassStrategy_MIN =
    LearnerConfig_MultiClassStrategy_MultiClassStrategy_MIN;
  static const MultiClassStrategy MultiClassStrategy_MAX =
    LearnerConfig_MultiClassStrategy_MultiClassStrategy_MAX;
  static const int MultiClassStrategy_ARRAYSIZE =
    LearnerConfig_MultiClassStrategy_MultiClassStrategy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MultiClassStrategy_descriptor() {
    return LearnerConfig_MultiClassStrategy_descriptor();
  }
  static inline const ::std::string& MultiClassStrategy_Name(MultiClassStrategy value) {
    return LearnerConfig_MultiClassStrategy_Name(value);
  }
  static inline bool MultiClassStrategy_Parse(const ::std::string& name,
      MultiClassStrategy* value) {
    return LearnerConfig_MultiClassStrategy_Parse(name, value);
  }

  typedef LearnerConfig_WeakLearnerType WeakLearnerType;
  static const WeakLearnerType NORMAL_DECISION_TREE =
    LearnerConfig_WeakLearnerType_NORMAL_DECISION_TREE;
  static const WeakLearnerType OBLIVIOUS_DECISION_TREE =
    LearnerConfig_WeakLearnerType_OBLIVIOUS_DECISION_TREE;
  static inline bool WeakLearnerType_IsValid(int value) {
    return LearnerConfig_WeakLearnerType_IsValid(value);
  }
  static const WeakLearnerType WeakLearnerType_MIN =
    LearnerConfig_WeakLearnerType_WeakLearnerType_MIN;
  static const WeakLearnerType WeakLearnerType_MAX =
    LearnerConfig_WeakLearnerType_WeakLearnerType_MAX;
  static const int WeakLearnerType_ARRAYSIZE =
    LearnerConfig_WeakLearnerType_WeakLearnerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WeakLearnerType_descriptor() {
    return LearnerConfig_WeakLearnerType_descriptor();
  }
  static inline const ::std::string& WeakLearnerType_Name(WeakLearnerType value) {
    return LearnerConfig_WeakLearnerType_Name(value);
  }
  static inline bool WeakLearnerType_Parse(const ::std::string& name,
      WeakLearnerType* value) {
    return LearnerConfig_WeakLearnerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .tensorflow.boosted_trees.learner.TreeRegularizationConfig regularization = 4;
  bool has_regularization() const;
  void clear_regularization();
  static const int kRegularizationFieldNumber = 4;
  private:
  const ::tensorflow::boosted_trees::learner::TreeRegularizationConfig& _internal_regularization() const;
  public:
  const ::tensorflow::boosted_trees::learner::TreeRegularizationConfig& regularization() const;
  ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* release_regularization();
  ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* mutable_regularization();
  void set_allocated_regularization(::tensorflow::boosted_trees::learner::TreeRegularizationConfig* regularization);
  void unsafe_arena_set_allocated_regularization(
      ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* regularization);
  ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* unsafe_arena_release_regularization();

  // .tensorflow.boosted_trees.learner.TreeConstraintsConfig constraints = 5;
  bool has_constraints() const;
  void clear_constraints();
  static const int kConstraintsFieldNumber = 5;
  private:
  const ::tensorflow::boosted_trees::learner::TreeConstraintsConfig& _internal_constraints() const;
  public:
  const ::tensorflow::boosted_trees::learner::TreeConstraintsConfig& constraints() const;
  ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* release_constraints();
  ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* mutable_constraints();
  void set_allocated_constraints(::tensorflow::boosted_trees::learner::TreeConstraintsConfig* constraints);
  void unsafe_arena_set_allocated_constraints(
      ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* constraints);
  ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* unsafe_arena_release_constraints();

  // .tensorflow.boosted_trees.learner.LearningRateConfig learning_rate_tuner = 6;
  bool has_learning_rate_tuner() const;
  void clear_learning_rate_tuner();
  static const int kLearningRateTunerFieldNumber = 6;
  private:
  const ::tensorflow::boosted_trees::learner::LearningRateConfig& _internal_learning_rate_tuner() const;
  public:
  const ::tensorflow::boosted_trees::learner::LearningRateConfig& learning_rate_tuner() const;
  ::tensorflow::boosted_trees::learner::LearningRateConfig* release_learning_rate_tuner();
  ::tensorflow::boosted_trees::learner::LearningRateConfig* mutable_learning_rate_tuner();
  void set_allocated_learning_rate_tuner(::tensorflow::boosted_trees::learner::LearningRateConfig* learning_rate_tuner);
  void unsafe_arena_set_allocated_learning_rate_tuner(
      ::tensorflow::boosted_trees::learner::LearningRateConfig* learning_rate_tuner);
  ::tensorflow::boosted_trees::learner::LearningRateConfig* unsafe_arena_release_learning_rate_tuner();

  // .tensorflow.boosted_trees.learner.AveragingConfig averaging_config = 11;
  bool has_averaging_config() const;
  void clear_averaging_config();
  static const int kAveragingConfigFieldNumber = 11;
  private:
  const ::tensorflow::boosted_trees::learner::AveragingConfig& _internal_averaging_config() const;
  public:
  const ::tensorflow::boosted_trees::learner::AveragingConfig& averaging_config() const;
  ::tensorflow::boosted_trees::learner::AveragingConfig* release_averaging_config();
  ::tensorflow::boosted_trees::learner::AveragingConfig* mutable_averaging_config();
  void set_allocated_averaging_config(::tensorflow::boosted_trees::learner::AveragingConfig* averaging_config);
  void unsafe_arena_set_allocated_averaging_config(
      ::tensorflow::boosted_trees::learner::AveragingConfig* averaging_config);
  ::tensorflow::boosted_trees::learner::AveragingConfig* unsafe_arena_release_averaging_config();

  // uint32 num_classes = 1;
  void clear_num_classes();
  static const int kNumClassesFieldNumber = 1;
  ::google::protobuf::uint32 num_classes() const;
  void set_num_classes(::google::protobuf::uint32 value);

  // .tensorflow.boosted_trees.learner.LearnerConfig.PruningMode pruning_mode = 8;
  void clear_pruning_mode();
  static const int kPruningModeFieldNumber = 8;
  ::tensorflow::boosted_trees::learner::LearnerConfig_PruningMode pruning_mode() const;
  void set_pruning_mode(::tensorflow::boosted_trees::learner::LearnerConfig_PruningMode value);

  // .tensorflow.boosted_trees.learner.LearnerConfig.GrowingMode growing_mode = 9;
  void clear_growing_mode();
  static const int kGrowingModeFieldNumber = 9;
  ::tensorflow::boosted_trees::learner::LearnerConfig_GrowingMode growing_mode() const;
  void set_growing_mode(::tensorflow::boosted_trees::learner::LearnerConfig_GrowingMode value);

  // .tensorflow.boosted_trees.learner.LearnerConfig.MultiClassStrategy multi_class_strategy = 10;
  void clear_multi_class_strategy();
  static const int kMultiClassStrategyFieldNumber = 10;
  ::tensorflow::boosted_trees::learner::LearnerConfig_MultiClassStrategy multi_class_strategy() const;
  void set_multi_class_strategy(::tensorflow::boosted_trees::learner::LearnerConfig_MultiClassStrategy value);

  // .tensorflow.boosted_trees.learner.LearnerConfig.WeakLearnerType weak_learner_type = 12;
  void clear_weak_learner_type();
  static const int kWeakLearnerTypeFieldNumber = 12;
  ::tensorflow::boosted_trees::learner::LearnerConfig_WeakLearnerType weak_learner_type() const;
  void set_weak_learner_type(::tensorflow::boosted_trees::learner::LearnerConfig_WeakLearnerType value);

  // float feature_fraction_per_tree = 2;
  private:
  bool has_feature_fraction_per_tree() const;
  public:
  void clear_feature_fraction_per_tree();
  static const int kFeatureFractionPerTreeFieldNumber = 2;
  float feature_fraction_per_tree() const;
  void set_feature_fraction_per_tree(float value);

  // float feature_fraction_per_level = 3;
  private:
  bool has_feature_fraction_per_level() const;
  public:
  void clear_feature_fraction_per_level();
  static const int kFeatureFractionPerLevelFieldNumber = 3;
  float feature_fraction_per_level() const;
  void set_feature_fraction_per_level(float value);

  void clear_feature_fraction();
  FeatureFractionCase feature_fraction_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.learner.LearnerConfig)
 private:
  void set_has_feature_fraction_per_tree();
  void set_has_feature_fraction_per_level();

  inline bool has_feature_fraction() const;
  inline void clear_has_feature_fraction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* regularization_;
  ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* constraints_;
  ::tensorflow::boosted_trees::learner::LearningRateConfig* learning_rate_tuner_;
  ::tensorflow::boosted_trees::learner::AveragingConfig* averaging_config_;
  ::google::protobuf::uint32 num_classes_;
  int pruning_mode_;
  int growing_mode_;
  int multi_class_strategy_;
  int weak_learner_type_;
  union FeatureFractionUnion {
    FeatureFractionUnion() {}
    float feature_fraction_per_tree_;
    float feature_fraction_per_level_;
  } feature_fraction_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TreeRegularizationConfig

// float l1 = 1;
inline void TreeRegularizationConfig::clear_l1() {
  l1_ = 0;
}
inline float TreeRegularizationConfig::l1() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.TreeRegularizationConfig.l1)
  return l1_;
}
inline void TreeRegularizationConfig::set_l1(float value) {
  
  l1_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.TreeRegularizationConfig.l1)
}

// float l2 = 2;
inline void TreeRegularizationConfig::clear_l2() {
  l2_ = 0;
}
inline float TreeRegularizationConfig::l2() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.TreeRegularizationConfig.l2)
  return l2_;
}
inline void TreeRegularizationConfig::set_l2(float value) {
  
  l2_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.TreeRegularizationConfig.l2)
}

// float tree_complexity = 3;
inline void TreeRegularizationConfig::clear_tree_complexity() {
  tree_complexity_ = 0;
}
inline float TreeRegularizationConfig::tree_complexity() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.TreeRegularizationConfig.tree_complexity)
  return tree_complexity_;
}
inline void TreeRegularizationConfig::set_tree_complexity(float value) {
  
  tree_complexity_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.TreeRegularizationConfig.tree_complexity)
}

// -------------------------------------------------------------------

// TreeConstraintsConfig

// uint32 max_tree_depth = 1;
inline void TreeConstraintsConfig::clear_max_tree_depth() {
  max_tree_depth_ = 0u;
}
inline ::google::protobuf::uint32 TreeConstraintsConfig::max_tree_depth() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.TreeConstraintsConfig.max_tree_depth)
  return max_tree_depth_;
}
inline void TreeConstraintsConfig::set_max_tree_depth(::google::protobuf::uint32 value) {
  
  max_tree_depth_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.TreeConstraintsConfig.max_tree_depth)
}

// float min_node_weight = 2;
inline void TreeConstraintsConfig::clear_min_node_weight() {
  min_node_weight_ = 0;
}
inline float TreeConstraintsConfig::min_node_weight() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.TreeConstraintsConfig.min_node_weight)
  return min_node_weight_;
}
inline void TreeConstraintsConfig::set_min_node_weight(float value) {
  
  min_node_weight_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.TreeConstraintsConfig.min_node_weight)
}

// int64 max_number_of_unique_feature_columns = 3;
inline void TreeConstraintsConfig::clear_max_number_of_unique_feature_columns() {
  max_number_of_unique_feature_columns_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TreeConstraintsConfig::max_number_of_unique_feature_columns() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.TreeConstraintsConfig.max_number_of_unique_feature_columns)
  return max_number_of_unique_feature_columns_;
}
inline void TreeConstraintsConfig::set_max_number_of_unique_feature_columns(::google::protobuf::int64 value) {
  
  max_number_of_unique_feature_columns_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.TreeConstraintsConfig.max_number_of_unique_feature_columns)
}

// -------------------------------------------------------------------

// LearningRateConfig

// .tensorflow.boosted_trees.learner.LearningRateFixedConfig fixed = 1;
inline bool LearningRateConfig::has_fixed() const {
  return tuner_case() == kFixed;
}
inline void LearningRateConfig::set_has_fixed() {
  _oneof_case_[0] = kFixed;
}
inline void LearningRateConfig::clear_fixed() {
  if (has_fixed()) {
    if (GetArenaNoVirtual() == NULL) {
      delete tuner_.fixed_;
    }
    clear_has_tuner();
  }
}
inline const ::tensorflow::boosted_trees::learner::LearningRateFixedConfig& LearningRateConfig::_internal_fixed() const {
  return *tuner_.fixed_;
}
inline ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* LearningRateConfig::release_fixed() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.learner.LearningRateConfig.fixed)
  if (has_fixed()) {
    clear_has_tuner();
      ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* temp = tuner_.fixed_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    tuner_.fixed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::learner::LearningRateFixedConfig& LearningRateConfig::fixed() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateConfig.fixed)
  return has_fixed()
      ? *tuner_.fixed_
      : *reinterpret_cast< ::tensorflow::boosted_trees::learner::LearningRateFixedConfig*>(&::tensorflow::boosted_trees::learner::_LearningRateFixedConfig_default_instance_);
}
inline ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* LearningRateConfig::unsafe_arena_release_fixed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.learner.LearningRateConfig.fixed)
  if (has_fixed()) {
    clear_has_tuner();
    ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* temp = tuner_.fixed_;
    tuner_.fixed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LearningRateConfig::unsafe_arena_set_allocated_fixed(::tensorflow::boosted_trees::learner::LearningRateFixedConfig* fixed) {
  clear_tuner();
  if (fixed) {
    set_has_fixed();
    tuner_.fixed_ = fixed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.learner.LearningRateConfig.fixed)
}
inline ::tensorflow::boosted_trees::learner::LearningRateFixedConfig* LearningRateConfig::mutable_fixed() {
  if (!has_fixed()) {
    clear_tuner();
    set_has_fixed();
    tuner_.fixed_ = CreateMaybeMessage< ::tensorflow::boosted_trees::learner::LearningRateFixedConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.learner.LearningRateConfig.fixed)
  return tuner_.fixed_;
}

// .tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig dropout = 2;
inline bool LearningRateConfig::has_dropout() const {
  return tuner_case() == kDropout;
}
inline void LearningRateConfig::set_has_dropout() {
  _oneof_case_[0] = kDropout;
}
inline void LearningRateConfig::clear_dropout() {
  if (has_dropout()) {
    if (GetArenaNoVirtual() == NULL) {
      delete tuner_.dropout_;
    }
    clear_has_tuner();
  }
}
inline const ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig& LearningRateConfig::_internal_dropout() const {
  return *tuner_.dropout_;
}
inline ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* LearningRateConfig::release_dropout() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.learner.LearningRateConfig.dropout)
  if (has_dropout()) {
    clear_has_tuner();
      ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* temp = tuner_.dropout_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    tuner_.dropout_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig& LearningRateConfig::dropout() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateConfig.dropout)
  return has_dropout()
      ? *tuner_.dropout_
      : *reinterpret_cast< ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig*>(&::tensorflow::boosted_trees::learner::_LearningRateDropoutDrivenConfig_default_instance_);
}
inline ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* LearningRateConfig::unsafe_arena_release_dropout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.learner.LearningRateConfig.dropout)
  if (has_dropout()) {
    clear_has_tuner();
    ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* temp = tuner_.dropout_;
    tuner_.dropout_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LearningRateConfig::unsafe_arena_set_allocated_dropout(::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* dropout) {
  clear_tuner();
  if (dropout) {
    set_has_dropout();
    tuner_.dropout_ = dropout;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.learner.LearningRateConfig.dropout)
}
inline ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig* LearningRateConfig::mutable_dropout() {
  if (!has_dropout()) {
    clear_tuner();
    set_has_dropout();
    tuner_.dropout_ = CreateMaybeMessage< ::tensorflow::boosted_trees::learner::LearningRateDropoutDrivenConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.learner.LearningRateConfig.dropout)
  return tuner_.dropout_;
}

// .tensorflow.boosted_trees.learner.LearningRateLineSearchConfig line_search = 3;
inline bool LearningRateConfig::has_line_search() const {
  return tuner_case() == kLineSearch;
}
inline void LearningRateConfig::set_has_line_search() {
  _oneof_case_[0] = kLineSearch;
}
inline void LearningRateConfig::clear_line_search() {
  if (has_line_search()) {
    if (GetArenaNoVirtual() == NULL) {
      delete tuner_.line_search_;
    }
    clear_has_tuner();
  }
}
inline const ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig& LearningRateConfig::_internal_line_search() const {
  return *tuner_.line_search_;
}
inline ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* LearningRateConfig::release_line_search() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.learner.LearningRateConfig.line_search)
  if (has_line_search()) {
    clear_has_tuner();
      ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* temp = tuner_.line_search_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    tuner_.line_search_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig& LearningRateConfig::line_search() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateConfig.line_search)
  return has_line_search()
      ? *tuner_.line_search_
      : *reinterpret_cast< ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig*>(&::tensorflow::boosted_trees::learner::_LearningRateLineSearchConfig_default_instance_);
}
inline ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* LearningRateConfig::unsafe_arena_release_line_search() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.learner.LearningRateConfig.line_search)
  if (has_line_search()) {
    clear_has_tuner();
    ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* temp = tuner_.line_search_;
    tuner_.line_search_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LearningRateConfig::unsafe_arena_set_allocated_line_search(::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* line_search) {
  clear_tuner();
  if (line_search) {
    set_has_line_search();
    tuner_.line_search_ = line_search;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.learner.LearningRateConfig.line_search)
}
inline ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig* LearningRateConfig::mutable_line_search() {
  if (!has_line_search()) {
    clear_tuner();
    set_has_line_search();
    tuner_.line_search_ = CreateMaybeMessage< ::tensorflow::boosted_trees::learner::LearningRateLineSearchConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.learner.LearningRateConfig.line_search)
  return tuner_.line_search_;
}

inline bool LearningRateConfig::has_tuner() const {
  return tuner_case() != TUNER_NOT_SET;
}
inline void LearningRateConfig::clear_has_tuner() {
  _oneof_case_[0] = TUNER_NOT_SET;
}
inline LearningRateConfig::TunerCase LearningRateConfig::tuner_case() const {
  return LearningRateConfig::TunerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LearningRateFixedConfig

// float learning_rate = 1;
inline void LearningRateFixedConfig::clear_learning_rate() {
  learning_rate_ = 0;
}
inline float LearningRateFixedConfig::learning_rate() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateFixedConfig.learning_rate)
  return learning_rate_;
}
inline void LearningRateFixedConfig::set_learning_rate(float value) {
  
  learning_rate_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearningRateFixedConfig.learning_rate)
}

// -------------------------------------------------------------------

// LearningRateLineSearchConfig

// float max_learning_rate = 1;
inline void LearningRateLineSearchConfig::clear_max_learning_rate() {
  max_learning_rate_ = 0;
}
inline float LearningRateLineSearchConfig::max_learning_rate() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateLineSearchConfig.max_learning_rate)
  return max_learning_rate_;
}
inline void LearningRateLineSearchConfig::set_max_learning_rate(float value) {
  
  max_learning_rate_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearningRateLineSearchConfig.max_learning_rate)
}

// int32 num_steps = 2;
inline void LearningRateLineSearchConfig::clear_num_steps() {
  num_steps_ = 0;
}
inline ::google::protobuf::int32 LearningRateLineSearchConfig::num_steps() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateLineSearchConfig.num_steps)
  return num_steps_;
}
inline void LearningRateLineSearchConfig::set_num_steps(::google::protobuf::int32 value) {
  
  num_steps_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearningRateLineSearchConfig.num_steps)
}

// -------------------------------------------------------------------

// AveragingConfig

// float average_last_n_trees = 1;
inline bool AveragingConfig::has_average_last_n_trees() const {
  return config_case() == kAverageLastNTrees;
}
inline void AveragingConfig::set_has_average_last_n_trees() {
  _oneof_case_[0] = kAverageLastNTrees;
}
inline void AveragingConfig::clear_average_last_n_trees() {
  if (has_average_last_n_trees()) {
    config_.average_last_n_trees_ = 0;
    clear_has_config();
  }
}
inline float AveragingConfig::average_last_n_trees() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.AveragingConfig.average_last_n_trees)
  if (has_average_last_n_trees()) {
    return config_.average_last_n_trees_;
  }
  return 0;
}
inline void AveragingConfig::set_average_last_n_trees(float value) {
  if (!has_average_last_n_trees()) {
    clear_config();
    set_has_average_last_n_trees();
  }
  config_.average_last_n_trees_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.AveragingConfig.average_last_n_trees)
}

// float average_last_percent_trees = 2;
inline bool AveragingConfig::has_average_last_percent_trees() const {
  return config_case() == kAverageLastPercentTrees;
}
inline void AveragingConfig::set_has_average_last_percent_trees() {
  _oneof_case_[0] = kAverageLastPercentTrees;
}
inline void AveragingConfig::clear_average_last_percent_trees() {
  if (has_average_last_percent_trees()) {
    config_.average_last_percent_trees_ = 0;
    clear_has_config();
  }
}
inline float AveragingConfig::average_last_percent_trees() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.AveragingConfig.average_last_percent_trees)
  if (has_average_last_percent_trees()) {
    return config_.average_last_percent_trees_;
  }
  return 0;
}
inline void AveragingConfig::set_average_last_percent_trees(float value) {
  if (!has_average_last_percent_trees()) {
    clear_config();
    set_has_average_last_percent_trees();
  }
  config_.average_last_percent_trees_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.AveragingConfig.average_last_percent_trees)
}

inline bool AveragingConfig::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void AveragingConfig::clear_has_config() {
  _oneof_case_[0] = CONFIG_NOT_SET;
}
inline AveragingConfig::ConfigCase AveragingConfig::config_case() const {
  return AveragingConfig::ConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LearningRateDropoutDrivenConfig

// float dropout_probability = 1;
inline void LearningRateDropoutDrivenConfig::clear_dropout_probability() {
  dropout_probability_ = 0;
}
inline float LearningRateDropoutDrivenConfig::dropout_probability() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig.dropout_probability)
  return dropout_probability_;
}
inline void LearningRateDropoutDrivenConfig::set_dropout_probability(float value) {
  
  dropout_probability_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig.dropout_probability)
}

// float probability_of_skipping_dropout = 2;
inline void LearningRateDropoutDrivenConfig::clear_probability_of_skipping_dropout() {
  probability_of_skipping_dropout_ = 0;
}
inline float LearningRateDropoutDrivenConfig::probability_of_skipping_dropout() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig.probability_of_skipping_dropout)
  return probability_of_skipping_dropout_;
}
inline void LearningRateDropoutDrivenConfig::set_probability_of_skipping_dropout(float value) {
  
  probability_of_skipping_dropout_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig.probability_of_skipping_dropout)
}

// float learning_rate = 3;
inline void LearningRateDropoutDrivenConfig::clear_learning_rate() {
  learning_rate_ = 0;
}
inline float LearningRateDropoutDrivenConfig::learning_rate() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig.learning_rate)
  return learning_rate_;
}
inline void LearningRateDropoutDrivenConfig::set_learning_rate(float value) {
  
  learning_rate_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig.learning_rate)
}

// -------------------------------------------------------------------

// LearnerConfig

// uint32 num_classes = 1;
inline void LearnerConfig::clear_num_classes() {
  num_classes_ = 0u;
}
inline ::google::protobuf::uint32 LearnerConfig::num_classes() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.num_classes)
  return num_classes_;
}
inline void LearnerConfig::set_num_classes(::google::protobuf::uint32 value) {
  
  num_classes_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearnerConfig.num_classes)
}

// float feature_fraction_per_tree = 2;
inline bool LearnerConfig::has_feature_fraction_per_tree() const {
  return feature_fraction_case() == kFeatureFractionPerTree;
}
inline void LearnerConfig::set_has_feature_fraction_per_tree() {
  _oneof_case_[0] = kFeatureFractionPerTree;
}
inline void LearnerConfig::clear_feature_fraction_per_tree() {
  if (has_feature_fraction_per_tree()) {
    feature_fraction_.feature_fraction_per_tree_ = 0;
    clear_has_feature_fraction();
  }
}
inline float LearnerConfig::feature_fraction_per_tree() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.feature_fraction_per_tree)
  if (has_feature_fraction_per_tree()) {
    return feature_fraction_.feature_fraction_per_tree_;
  }
  return 0;
}
inline void LearnerConfig::set_feature_fraction_per_tree(float value) {
  if (!has_feature_fraction_per_tree()) {
    clear_feature_fraction();
    set_has_feature_fraction_per_tree();
  }
  feature_fraction_.feature_fraction_per_tree_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearnerConfig.feature_fraction_per_tree)
}

// float feature_fraction_per_level = 3;
inline bool LearnerConfig::has_feature_fraction_per_level() const {
  return feature_fraction_case() == kFeatureFractionPerLevel;
}
inline void LearnerConfig::set_has_feature_fraction_per_level() {
  _oneof_case_[0] = kFeatureFractionPerLevel;
}
inline void LearnerConfig::clear_feature_fraction_per_level() {
  if (has_feature_fraction_per_level()) {
    feature_fraction_.feature_fraction_per_level_ = 0;
    clear_has_feature_fraction();
  }
}
inline float LearnerConfig::feature_fraction_per_level() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.feature_fraction_per_level)
  if (has_feature_fraction_per_level()) {
    return feature_fraction_.feature_fraction_per_level_;
  }
  return 0;
}
inline void LearnerConfig::set_feature_fraction_per_level(float value) {
  if (!has_feature_fraction_per_level()) {
    clear_feature_fraction();
    set_has_feature_fraction_per_level();
  }
  feature_fraction_.feature_fraction_per_level_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearnerConfig.feature_fraction_per_level)
}

// .tensorflow.boosted_trees.learner.TreeRegularizationConfig regularization = 4;
inline bool LearnerConfig::has_regularization() const {
  return this != internal_default_instance() && regularization_ != NULL;
}
inline void LearnerConfig::clear_regularization() {
  if (GetArenaNoVirtual() == NULL && regularization_ != NULL) {
    delete regularization_;
  }
  regularization_ = NULL;
}
inline const ::tensorflow::boosted_trees::learner::TreeRegularizationConfig& LearnerConfig::_internal_regularization() const {
  return *regularization_;
}
inline const ::tensorflow::boosted_trees::learner::TreeRegularizationConfig& LearnerConfig::regularization() const {
  const ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* p = regularization_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.regularization)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::learner::TreeRegularizationConfig*>(
      &::tensorflow::boosted_trees::learner::_TreeRegularizationConfig_default_instance_);
}
inline ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* LearnerConfig::release_regularization() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.learner.LearnerConfig.regularization)
  
  ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* temp = regularization_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  regularization_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* LearnerConfig::unsafe_arena_release_regularization() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.learner.LearnerConfig.regularization)
  
  ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* temp = regularization_;
  regularization_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::learner::TreeRegularizationConfig* LearnerConfig::mutable_regularization() {
  
  if (regularization_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::learner::TreeRegularizationConfig>(GetArenaNoVirtual());
    regularization_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.learner.LearnerConfig.regularization)
  return regularization_;
}
inline void LearnerConfig::set_allocated_regularization(::tensorflow::boosted_trees::learner::TreeRegularizationConfig* regularization) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete regularization_;
  }
  if (regularization) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(regularization);
    if (message_arena != submessage_arena) {
      regularization = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, regularization, submessage_arena);
    }
    
  } else {
    
  }
  regularization_ = regularization;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.learner.LearnerConfig.regularization)
}

// .tensorflow.boosted_trees.learner.TreeConstraintsConfig constraints = 5;
inline bool LearnerConfig::has_constraints() const {
  return this != internal_default_instance() && constraints_ != NULL;
}
inline void LearnerConfig::clear_constraints() {
  if (GetArenaNoVirtual() == NULL && constraints_ != NULL) {
    delete constraints_;
  }
  constraints_ = NULL;
}
inline const ::tensorflow::boosted_trees::learner::TreeConstraintsConfig& LearnerConfig::_internal_constraints() const {
  return *constraints_;
}
inline const ::tensorflow::boosted_trees::learner::TreeConstraintsConfig& LearnerConfig::constraints() const {
  const ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* p = constraints_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.constraints)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::learner::TreeConstraintsConfig*>(
      &::tensorflow::boosted_trees::learner::_TreeConstraintsConfig_default_instance_);
}
inline ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* LearnerConfig::release_constraints() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.learner.LearnerConfig.constraints)
  
  ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* temp = constraints_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  constraints_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* LearnerConfig::unsafe_arena_release_constraints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.learner.LearnerConfig.constraints)
  
  ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* temp = constraints_;
  constraints_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::learner::TreeConstraintsConfig* LearnerConfig::mutable_constraints() {
  
  if (constraints_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::learner::TreeConstraintsConfig>(GetArenaNoVirtual());
    constraints_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.learner.LearnerConfig.constraints)
  return constraints_;
}
inline void LearnerConfig::set_allocated_constraints(::tensorflow::boosted_trees::learner::TreeConstraintsConfig* constraints) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete constraints_;
  }
  if (constraints) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(constraints);
    if (message_arena != submessage_arena) {
      constraints = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, constraints, submessage_arena);
    }
    
  } else {
    
  }
  constraints_ = constraints;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.learner.LearnerConfig.constraints)
}

// .tensorflow.boosted_trees.learner.LearnerConfig.PruningMode pruning_mode = 8;
inline void LearnerConfig::clear_pruning_mode() {
  pruning_mode_ = 0;
}
inline ::tensorflow::boosted_trees::learner::LearnerConfig_PruningMode LearnerConfig::pruning_mode() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.pruning_mode)
  return static_cast< ::tensorflow::boosted_trees::learner::LearnerConfig_PruningMode >(pruning_mode_);
}
inline void LearnerConfig::set_pruning_mode(::tensorflow::boosted_trees::learner::LearnerConfig_PruningMode value) {
  
  pruning_mode_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearnerConfig.pruning_mode)
}

// .tensorflow.boosted_trees.learner.LearnerConfig.GrowingMode growing_mode = 9;
inline void LearnerConfig::clear_growing_mode() {
  growing_mode_ = 0;
}
inline ::tensorflow::boosted_trees::learner::LearnerConfig_GrowingMode LearnerConfig::growing_mode() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.growing_mode)
  return static_cast< ::tensorflow::boosted_trees::learner::LearnerConfig_GrowingMode >(growing_mode_);
}
inline void LearnerConfig::set_growing_mode(::tensorflow::boosted_trees::learner::LearnerConfig_GrowingMode value) {
  
  growing_mode_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearnerConfig.growing_mode)
}

// .tensorflow.boosted_trees.learner.LearningRateConfig learning_rate_tuner = 6;
inline bool LearnerConfig::has_learning_rate_tuner() const {
  return this != internal_default_instance() && learning_rate_tuner_ != NULL;
}
inline void LearnerConfig::clear_learning_rate_tuner() {
  if (GetArenaNoVirtual() == NULL && learning_rate_tuner_ != NULL) {
    delete learning_rate_tuner_;
  }
  learning_rate_tuner_ = NULL;
}
inline const ::tensorflow::boosted_trees::learner::LearningRateConfig& LearnerConfig::_internal_learning_rate_tuner() const {
  return *learning_rate_tuner_;
}
inline const ::tensorflow::boosted_trees::learner::LearningRateConfig& LearnerConfig::learning_rate_tuner() const {
  const ::tensorflow::boosted_trees::learner::LearningRateConfig* p = learning_rate_tuner_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.learning_rate_tuner)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::learner::LearningRateConfig*>(
      &::tensorflow::boosted_trees::learner::_LearningRateConfig_default_instance_);
}
inline ::tensorflow::boosted_trees::learner::LearningRateConfig* LearnerConfig::release_learning_rate_tuner() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.learner.LearnerConfig.learning_rate_tuner)
  
  ::tensorflow::boosted_trees::learner::LearningRateConfig* temp = learning_rate_tuner_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  learning_rate_tuner_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::learner::LearningRateConfig* LearnerConfig::unsafe_arena_release_learning_rate_tuner() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.learner.LearnerConfig.learning_rate_tuner)
  
  ::tensorflow::boosted_trees::learner::LearningRateConfig* temp = learning_rate_tuner_;
  learning_rate_tuner_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::learner::LearningRateConfig* LearnerConfig::mutable_learning_rate_tuner() {
  
  if (learning_rate_tuner_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::learner::LearningRateConfig>(GetArenaNoVirtual());
    learning_rate_tuner_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.learner.LearnerConfig.learning_rate_tuner)
  return learning_rate_tuner_;
}
inline void LearnerConfig::set_allocated_learning_rate_tuner(::tensorflow::boosted_trees::learner::LearningRateConfig* learning_rate_tuner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete learning_rate_tuner_;
  }
  if (learning_rate_tuner) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(learning_rate_tuner);
    if (message_arena != submessage_arena) {
      learning_rate_tuner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, learning_rate_tuner, submessage_arena);
    }
    
  } else {
    
  }
  learning_rate_tuner_ = learning_rate_tuner;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.learner.LearnerConfig.learning_rate_tuner)
}

// .tensorflow.boosted_trees.learner.LearnerConfig.MultiClassStrategy multi_class_strategy = 10;
inline void LearnerConfig::clear_multi_class_strategy() {
  multi_class_strategy_ = 0;
}
inline ::tensorflow::boosted_trees::learner::LearnerConfig_MultiClassStrategy LearnerConfig::multi_class_strategy() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.multi_class_strategy)
  return static_cast< ::tensorflow::boosted_trees::learner::LearnerConfig_MultiClassStrategy >(multi_class_strategy_);
}
inline void LearnerConfig::set_multi_class_strategy(::tensorflow::boosted_trees::learner::LearnerConfig_MultiClassStrategy value) {
  
  multi_class_strategy_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearnerConfig.multi_class_strategy)
}

// .tensorflow.boosted_trees.learner.AveragingConfig averaging_config = 11;
inline bool LearnerConfig::has_averaging_config() const {
  return this != internal_default_instance() && averaging_config_ != NULL;
}
inline void LearnerConfig::clear_averaging_config() {
  if (GetArenaNoVirtual() == NULL && averaging_config_ != NULL) {
    delete averaging_config_;
  }
  averaging_config_ = NULL;
}
inline const ::tensorflow::boosted_trees::learner::AveragingConfig& LearnerConfig::_internal_averaging_config() const {
  return *averaging_config_;
}
inline const ::tensorflow::boosted_trees::learner::AveragingConfig& LearnerConfig::averaging_config() const {
  const ::tensorflow::boosted_trees::learner::AveragingConfig* p = averaging_config_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.averaging_config)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::learner::AveragingConfig*>(
      &::tensorflow::boosted_trees::learner::_AveragingConfig_default_instance_);
}
inline ::tensorflow::boosted_trees::learner::AveragingConfig* LearnerConfig::release_averaging_config() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.learner.LearnerConfig.averaging_config)
  
  ::tensorflow::boosted_trees::learner::AveragingConfig* temp = averaging_config_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  averaging_config_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::learner::AveragingConfig* LearnerConfig::unsafe_arena_release_averaging_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.learner.LearnerConfig.averaging_config)
  
  ::tensorflow::boosted_trees::learner::AveragingConfig* temp = averaging_config_;
  averaging_config_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::learner::AveragingConfig* LearnerConfig::mutable_averaging_config() {
  
  if (averaging_config_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::learner::AveragingConfig>(GetArenaNoVirtual());
    averaging_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.learner.LearnerConfig.averaging_config)
  return averaging_config_;
}
inline void LearnerConfig::set_allocated_averaging_config(::tensorflow::boosted_trees::learner::AveragingConfig* averaging_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete averaging_config_;
  }
  if (averaging_config) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(averaging_config);
    if (message_arena != submessage_arena) {
      averaging_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, averaging_config, submessage_arena);
    }
    
  } else {
    
  }
  averaging_config_ = averaging_config;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.learner.LearnerConfig.averaging_config)
}

// .tensorflow.boosted_trees.learner.LearnerConfig.WeakLearnerType weak_learner_type = 12;
inline void LearnerConfig::clear_weak_learner_type() {
  weak_learner_type_ = 0;
}
inline ::tensorflow::boosted_trees::learner::LearnerConfig_WeakLearnerType LearnerConfig::weak_learner_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.learner.LearnerConfig.weak_learner_type)
  return static_cast< ::tensorflow::boosted_trees::learner::LearnerConfig_WeakLearnerType >(weak_learner_type_);
}
inline void LearnerConfig::set_weak_learner_type(::tensorflow::boosted_trees::learner::LearnerConfig_WeakLearnerType value) {
  
  weak_learner_type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.learner.LearnerConfig.weak_learner_type)
}

inline bool LearnerConfig::has_feature_fraction() const {
  return feature_fraction_case() != FEATURE_FRACTION_NOT_SET;
}
inline void LearnerConfig::clear_has_feature_fraction() {
  _oneof_case_[0] = FEATURE_FRACTION_NOT_SET;
}
inline LearnerConfig::FeatureFractionCase LearnerConfig::feature_fraction_case() const {
  return LearnerConfig::FeatureFractionCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace learner
}  // namespace boosted_trees
}  // namespace tensorflow

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tensorflow::boosted_trees::learner::LearnerConfig_PruningMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::boosted_trees::learner::LearnerConfig_PruningMode>() {
  return ::tensorflow::boosted_trees::learner::LearnerConfig_PruningMode_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::boosted_trees::learner::LearnerConfig_GrowingMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::boosted_trees::learner::LearnerConfig_GrowingMode>() {
  return ::tensorflow::boosted_trees::learner::LearnerConfig_GrowingMode_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::boosted_trees::learner::LearnerConfig_MultiClassStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::boosted_trees::learner::LearnerConfig_MultiClassStrategy>() {
  return ::tensorflow::boosted_trees::learner::LearnerConfig_MultiClassStrategy_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::boosted_trees::learner::LearnerConfig_WeakLearnerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::boosted_trees::learner::LearnerConfig_WeakLearnerType>() {
  return ::tensorflow::boosted_trees::learner::LearnerConfig_WeakLearnerType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2flearner_2eproto
