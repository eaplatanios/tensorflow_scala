// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/contrib/tensor_forest/proto/fertile_stats.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/contrib/decision_trees/proto/generic_tree_model.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto 

namespace protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto
namespace tensorflow {
namespace tensorforest {
class FertileSlot;
class FertileSlotDefaultTypeInternal;
extern FertileSlotDefaultTypeInternal _FertileSlot_default_instance_;
class FertileStats;
class FertileStatsDefaultTypeInternal;
extern FertileStatsDefaultTypeInternal _FertileStats_default_instance_;
class GiniStats;
class GiniStatsDefaultTypeInternal;
extern GiniStatsDefaultTypeInternal _GiniStats_default_instance_;
class LeafStat;
class LeafStatDefaultTypeInternal;
extern LeafStatDefaultTypeInternal _LeafStat_default_instance_;
class LeafStat_GiniImpurityClassificationStats;
class LeafStat_GiniImpurityClassificationStatsDefaultTypeInternal;
extern LeafStat_GiniImpurityClassificationStatsDefaultTypeInternal _LeafStat_GiniImpurityClassificationStats_default_instance_;
class LeafStat_LeastSquaresRegressionStats;
class LeafStat_LeastSquaresRegressionStatsDefaultTypeInternal;
extern LeafStat_LeastSquaresRegressionStatsDefaultTypeInternal _LeafStat_LeastSquaresRegressionStats_default_instance_;
class SplitCandidate;
class SplitCandidateDefaultTypeInternal;
extern SplitCandidateDefaultTypeInternal _SplitCandidate_default_instance_;
class TreePath;
class TreePathDefaultTypeInternal;
extern TreePathDefaultTypeInternal _TreePath_default_instance_;
}  // namespace tensorforest
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::tensorforest::FertileSlot* Arena::CreateMaybeMessage<::tensorflow::tensorforest::FertileSlot>(Arena*);
template<> ::tensorflow::tensorforest::FertileStats* Arena::CreateMaybeMessage<::tensorflow::tensorforest::FertileStats>(Arena*);
template<> ::tensorflow::tensorforest::GiniStats* Arena::CreateMaybeMessage<::tensorflow::tensorforest::GiniStats>(Arena*);
template<> ::tensorflow::tensorforest::LeafStat* Arena::CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(Arena*);
template<> ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* Arena::CreateMaybeMessage<::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats>(Arena*);
template<> ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* Arena::CreateMaybeMessage<::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats>(Arena*);
template<> ::tensorflow::tensorforest::SplitCandidate* Arena::CreateMaybeMessage<::tensorflow::tensorforest::SplitCandidate>(Arena*);
template<> ::tensorflow::tensorforest::TreePath* Arena::CreateMaybeMessage<::tensorflow::tensorforest::TreePath>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace tensorforest {

// ===================================================================

class FertileStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.FertileStats) */ {
 public:
  FertileStats();
  virtual ~FertileStats();

  FertileStats(const FertileStats& from);

  inline FertileStats& operator=(const FertileStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FertileStats(FertileStats&& from) noexcept
    : FertileStats() {
    *this = ::std::move(from);
  }

  inline FertileStats& operator=(FertileStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FertileStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FertileStats* internal_default_instance() {
    return reinterpret_cast<const FertileStats*>(
               &_FertileStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(FertileStats* other);
  void Swap(FertileStats* other);
  friend void swap(FertileStats& a, FertileStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FertileStats* New() const final {
    return CreateMaybeMessage<FertileStats>(NULL);
  }

  FertileStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FertileStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FertileStats& from);
  void MergeFrom(const FertileStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FertileStats* other);
  protected:
  explicit FertileStats(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.tensorforest.FertileSlot node_to_slot = 1;
  int node_to_slot_size() const;
  void clear_node_to_slot();
  static const int kNodeToSlotFieldNumber = 1;
  ::tensorflow::tensorforest::FertileSlot* mutable_node_to_slot(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot >*
      mutable_node_to_slot();
  const ::tensorflow::tensorforest::FertileSlot& node_to_slot(int index) const;
  ::tensorflow::tensorforest::FertileSlot* add_node_to_slot();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot >&
      node_to_slot() const;

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.FertileStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot > node_to_slot_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GiniStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.GiniStats) */ {
 public:
  GiniStats();
  virtual ~GiniStats();

  GiniStats(const GiniStats& from);

  inline GiniStats& operator=(const GiniStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GiniStats(GiniStats&& from) noexcept
    : GiniStats() {
    *this = ::std::move(from);
  }

  inline GiniStats& operator=(GiniStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GiniStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GiniStats* internal_default_instance() {
    return reinterpret_cast<const GiniStats*>(
               &_GiniStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(GiniStats* other);
  void Swap(GiniStats* other);
  friend void swap(GiniStats& a, GiniStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GiniStats* New() const final {
    return CreateMaybeMessage<GiniStats>(NULL);
  }

  GiniStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GiniStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GiniStats& from);
  void MergeFrom(const GiniStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GiniStats* other);
  protected:
  explicit GiniStats(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float square = 2;
  void clear_square();
  static const int kSquareFieldNumber = 2;
  float square() const;
  void set_square(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.GiniStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float square_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeafStat_GiniImpurityClassificationStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats) */ {
 public:
  LeafStat_GiniImpurityClassificationStats();
  virtual ~LeafStat_GiniImpurityClassificationStats();

  LeafStat_GiniImpurityClassificationStats(const LeafStat_GiniImpurityClassificationStats& from);

  inline LeafStat_GiniImpurityClassificationStats& operator=(const LeafStat_GiniImpurityClassificationStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeafStat_GiniImpurityClassificationStats(LeafStat_GiniImpurityClassificationStats&& from) noexcept
    : LeafStat_GiniImpurityClassificationStats() {
    *this = ::std::move(from);
  }

  inline LeafStat_GiniImpurityClassificationStats& operator=(LeafStat_GiniImpurityClassificationStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeafStat_GiniImpurityClassificationStats& default_instance();

  enum CountsCase {
    kDenseCounts = 1,
    kSparseCounts = 2,
    COUNTS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeafStat_GiniImpurityClassificationStats* internal_default_instance() {
    return reinterpret_cast<const LeafStat_GiniImpurityClassificationStats*>(
               &_LeafStat_GiniImpurityClassificationStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(LeafStat_GiniImpurityClassificationStats* other);
  void Swap(LeafStat_GiniImpurityClassificationStats* other);
  friend void swap(LeafStat_GiniImpurityClassificationStats& a, LeafStat_GiniImpurityClassificationStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeafStat_GiniImpurityClassificationStats* New() const final {
    return CreateMaybeMessage<LeafStat_GiniImpurityClassificationStats>(NULL);
  }

  LeafStat_GiniImpurityClassificationStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeafStat_GiniImpurityClassificationStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LeafStat_GiniImpurityClassificationStats& from);
  void MergeFrom(const LeafStat_GiniImpurityClassificationStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafStat_GiniImpurityClassificationStats* other);
  protected:
  explicit LeafStat_GiniImpurityClassificationStats(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.tensorforest.GiniStats gini = 3;
  bool has_gini() const;
  void clear_gini();
  static const int kGiniFieldNumber = 3;
  private:
  const ::tensorflow::tensorforest::GiniStats& _internal_gini() const;
  public:
  const ::tensorflow::tensorforest::GiniStats& gini() const;
  ::tensorflow::tensorforest::GiniStats* release_gini();
  ::tensorflow::tensorforest::GiniStats* mutable_gini();
  void set_allocated_gini(::tensorflow::tensorforest::GiniStats* gini);
  void unsafe_arena_set_allocated_gini(
      ::tensorflow::tensorforest::GiniStats* gini);
  ::tensorflow::tensorforest::GiniStats* unsafe_arena_release_gini();

  // .tensorflow.decision_trees.Vector dense_counts = 1;
  bool has_dense_counts() const;
  void clear_dense_counts();
  static const int kDenseCountsFieldNumber = 1;
  private:
  const ::tensorflow::decision_trees::Vector& _internal_dense_counts() const;
  public:
  const ::tensorflow::decision_trees::Vector& dense_counts() const;
  ::tensorflow::decision_trees::Vector* release_dense_counts();
  ::tensorflow::decision_trees::Vector* mutable_dense_counts();
  void set_allocated_dense_counts(::tensorflow::decision_trees::Vector* dense_counts);
  void unsafe_arena_set_allocated_dense_counts(
      ::tensorflow::decision_trees::Vector* dense_counts);
  ::tensorflow::decision_trees::Vector* unsafe_arena_release_dense_counts();

  // .tensorflow.decision_trees.SparseVector sparse_counts = 2;
  bool has_sparse_counts() const;
  void clear_sparse_counts();
  static const int kSparseCountsFieldNumber = 2;
  private:
  const ::tensorflow::decision_trees::SparseVector& _internal_sparse_counts() const;
  public:
  const ::tensorflow::decision_trees::SparseVector& sparse_counts() const;
  ::tensorflow::decision_trees::SparseVector* release_sparse_counts();
  ::tensorflow::decision_trees::SparseVector* mutable_sparse_counts();
  void set_allocated_sparse_counts(::tensorflow::decision_trees::SparseVector* sparse_counts);
  void unsafe_arena_set_allocated_sparse_counts(
      ::tensorflow::decision_trees::SparseVector* sparse_counts);
  ::tensorflow::decision_trees::SparseVector* unsafe_arena_release_sparse_counts();

  void clear_counts();
  CountsCase counts_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats)
 private:
  void set_has_dense_counts();
  void set_has_sparse_counts();

  inline bool has_counts() const;
  inline void clear_has_counts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::tensorforest::GiniStats* gini_;
  union CountsUnion {
    CountsUnion() {}
    ::tensorflow::decision_trees::Vector* dense_counts_;
    ::tensorflow::decision_trees::SparseVector* sparse_counts_;
  } counts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeafStat_LeastSquaresRegressionStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats) */ {
 public:
  LeafStat_LeastSquaresRegressionStats();
  virtual ~LeafStat_LeastSquaresRegressionStats();

  LeafStat_LeastSquaresRegressionStats(const LeafStat_LeastSquaresRegressionStats& from);

  inline LeafStat_LeastSquaresRegressionStats& operator=(const LeafStat_LeastSquaresRegressionStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeafStat_LeastSquaresRegressionStats(LeafStat_LeastSquaresRegressionStats&& from) noexcept
    : LeafStat_LeastSquaresRegressionStats() {
    *this = ::std::move(from);
  }

  inline LeafStat_LeastSquaresRegressionStats& operator=(LeafStat_LeastSquaresRegressionStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeafStat_LeastSquaresRegressionStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeafStat_LeastSquaresRegressionStats* internal_default_instance() {
    return reinterpret_cast<const LeafStat_LeastSquaresRegressionStats*>(
               &_LeafStat_LeastSquaresRegressionStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(LeafStat_LeastSquaresRegressionStats* other);
  void Swap(LeafStat_LeastSquaresRegressionStats* other);
  friend void swap(LeafStat_LeastSquaresRegressionStats& a, LeafStat_LeastSquaresRegressionStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeafStat_LeastSquaresRegressionStats* New() const final {
    return CreateMaybeMessage<LeafStat_LeastSquaresRegressionStats>(NULL);
  }

  LeafStat_LeastSquaresRegressionStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeafStat_LeastSquaresRegressionStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LeafStat_LeastSquaresRegressionStats& from);
  void MergeFrom(const LeafStat_LeastSquaresRegressionStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafStat_LeastSquaresRegressionStats* other);
  protected:
  explicit LeafStat_LeastSquaresRegressionStats(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.decision_trees.Vector mean_output = 1;
  bool has_mean_output() const;
  void clear_mean_output();
  static const int kMeanOutputFieldNumber = 1;
  private:
  const ::tensorflow::decision_trees::Vector& _internal_mean_output() const;
  public:
  const ::tensorflow::decision_trees::Vector& mean_output() const;
  ::tensorflow::decision_trees::Vector* release_mean_output();
  ::tensorflow::decision_trees::Vector* mutable_mean_output();
  void set_allocated_mean_output(::tensorflow::decision_trees::Vector* mean_output);
  void unsafe_arena_set_allocated_mean_output(
      ::tensorflow::decision_trees::Vector* mean_output);
  ::tensorflow::decision_trees::Vector* unsafe_arena_release_mean_output();

  // .tensorflow.decision_trees.Vector mean_output_squares = 2;
  bool has_mean_output_squares() const;
  void clear_mean_output_squares();
  static const int kMeanOutputSquaresFieldNumber = 2;
  private:
  const ::tensorflow::decision_trees::Vector& _internal_mean_output_squares() const;
  public:
  const ::tensorflow::decision_trees::Vector& mean_output_squares() const;
  ::tensorflow::decision_trees::Vector* release_mean_output_squares();
  ::tensorflow::decision_trees::Vector* mutable_mean_output_squares();
  void set_allocated_mean_output_squares(::tensorflow::decision_trees::Vector* mean_output_squares);
  void unsafe_arena_set_allocated_mean_output_squares(
      ::tensorflow::decision_trees::Vector* mean_output_squares);
  ::tensorflow::decision_trees::Vector* unsafe_arena_release_mean_output_squares();

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::decision_trees::Vector* mean_output_;
  ::tensorflow::decision_trees::Vector* mean_output_squares_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeafStat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.LeafStat) */ {
 public:
  LeafStat();
  virtual ~LeafStat();

  LeafStat(const LeafStat& from);

  inline LeafStat& operator=(const LeafStat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeafStat(LeafStat&& from) noexcept
    : LeafStat() {
    *this = ::std::move(from);
  }

  inline LeafStat& operator=(LeafStat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeafStat& default_instance();

  enum LeafStatCase {
    kClassification = 1,
    kRegression = 2,
    LEAF_STAT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeafStat* internal_default_instance() {
    return reinterpret_cast<const LeafStat*>(
               &_LeafStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(LeafStat* other);
  void Swap(LeafStat* other);
  friend void swap(LeafStat& a, LeafStat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeafStat* New() const final {
    return CreateMaybeMessage<LeafStat>(NULL);
  }

  LeafStat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeafStat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LeafStat& from);
  void MergeFrom(const LeafStat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafStat* other);
  protected:
  explicit LeafStat(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LeafStat_GiniImpurityClassificationStats GiniImpurityClassificationStats;
  typedef LeafStat_LeastSquaresRegressionStats LeastSquaresRegressionStats;

  // accessors -------------------------------------------------------

  // float weight_sum = 3;
  void clear_weight_sum();
  static const int kWeightSumFieldNumber = 3;
  float weight_sum() const;
  void set_weight_sum(float value);

  // .tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats classification = 1;
  bool has_classification() const;
  void clear_classification();
  static const int kClassificationFieldNumber = 1;
  private:
  const ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats& _internal_classification() const;
  public:
  const ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats& classification() const;
  ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* release_classification();
  ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* mutable_classification();
  void set_allocated_classification(::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* classification);
  void unsafe_arena_set_allocated_classification(
      ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* classification);
  ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* unsafe_arena_release_classification();

  // .tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats regression = 2;
  bool has_regression() const;
  void clear_regression();
  static const int kRegressionFieldNumber = 2;
  private:
  const ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats& _internal_regression() const;
  public:
  const ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats& regression() const;
  ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* release_regression();
  ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* mutable_regression();
  void set_allocated_regression(::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* regression);
  void unsafe_arena_set_allocated_regression(
      ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* regression);
  ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* unsafe_arena_release_regression();

  void clear_leaf_stat();
  LeafStatCase leaf_stat_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.LeafStat)
 private:
  void set_has_classification();
  void set_has_regression();

  inline bool has_leaf_stat() const;
  inline void clear_has_leaf_stat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float weight_sum_;
  union LeafStatUnion {
    LeafStatUnion() {}
    ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* classification_;
    ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* regression_;
  } leaf_stat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FertileSlot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.FertileSlot) */ {
 public:
  FertileSlot();
  virtual ~FertileSlot();

  FertileSlot(const FertileSlot& from);

  inline FertileSlot& operator=(const FertileSlot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FertileSlot(FertileSlot&& from) noexcept
    : FertileSlot() {
    *this = ::std::move(from);
  }

  inline FertileSlot& operator=(FertileSlot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FertileSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FertileSlot* internal_default_instance() {
    return reinterpret_cast<const FertileSlot*>(
               &_FertileSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(FertileSlot* other);
  void Swap(FertileSlot* other);
  friend void swap(FertileSlot& a, FertileSlot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FertileSlot* New() const final {
    return CreateMaybeMessage<FertileSlot>(NULL);
  }

  FertileSlot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FertileSlot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FertileSlot& from);
  void MergeFrom(const FertileSlot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FertileSlot* other);
  protected:
  explicit FertileSlot(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.tensorforest.SplitCandidate candidates = 1;
  int candidates_size() const;
  void clear_candidates();
  static const int kCandidatesFieldNumber = 1;
  ::tensorflow::tensorforest::SplitCandidate* mutable_candidates(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate >*
      mutable_candidates();
  const ::tensorflow::tensorforest::SplitCandidate& candidates(int index) const;
  ::tensorflow::tensorforest::SplitCandidate* add_candidates();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate >&
      candidates() const;

  // .tensorflow.tensorforest.LeafStat leaf_stats = 4;
  bool has_leaf_stats() const;
  void clear_leaf_stats();
  static const int kLeafStatsFieldNumber = 4;
  private:
  const ::tensorflow::tensorforest::LeafStat& _internal_leaf_stats() const;
  public:
  const ::tensorflow::tensorforest::LeafStat& leaf_stats() const;
  ::tensorflow::tensorforest::LeafStat* release_leaf_stats();
  ::tensorflow::tensorforest::LeafStat* mutable_leaf_stats();
  void set_allocated_leaf_stats(::tensorflow::tensorforest::LeafStat* leaf_stats);
  void unsafe_arena_set_allocated_leaf_stats(
      ::tensorflow::tensorforest::LeafStat* leaf_stats);
  ::tensorflow::tensorforest::LeafStat* unsafe_arena_release_leaf_stats();

  // .tensorflow.tensorforest.LeafStat post_init_leaf_stats = 6;
  bool has_post_init_leaf_stats() const;
  void clear_post_init_leaf_stats();
  static const int kPostInitLeafStatsFieldNumber = 6;
  private:
  const ::tensorflow::tensorforest::LeafStat& _internal_post_init_leaf_stats() const;
  public:
  const ::tensorflow::tensorforest::LeafStat& post_init_leaf_stats() const;
  ::tensorflow::tensorforest::LeafStat* release_post_init_leaf_stats();
  ::tensorflow::tensorforest::LeafStat* mutable_post_init_leaf_stats();
  void set_allocated_post_init_leaf_stats(::tensorflow::tensorforest::LeafStat* post_init_leaf_stats);
  void unsafe_arena_set_allocated_post_init_leaf_stats(
      ::tensorflow::tensorforest::LeafStat* post_init_leaf_stats);
  ::tensorflow::tensorforest::LeafStat* unsafe_arena_release_post_init_leaf_stats();

  // int32 node_id = 5;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 5;
  ::google::protobuf::int32 node_id() const;
  void set_node_id(::google::protobuf::int32 value);

  // int32 depth = 7;
  void clear_depth();
  static const int kDepthFieldNumber = 7;
  ::google::protobuf::int32 depth() const;
  void set_depth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.FertileSlot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate > candidates_;
  ::tensorflow::tensorforest::LeafStat* leaf_stats_;
  ::tensorflow::tensorforest::LeafStat* post_init_leaf_stats_;
  ::google::protobuf::int32 node_id_;
  ::google::protobuf::int32 depth_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SplitCandidate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.SplitCandidate) */ {
 public:
  SplitCandidate();
  virtual ~SplitCandidate();

  SplitCandidate(const SplitCandidate& from);

  inline SplitCandidate& operator=(const SplitCandidate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplitCandidate(SplitCandidate&& from) noexcept
    : SplitCandidate() {
    *this = ::std::move(from);
  }

  inline SplitCandidate& operator=(SplitCandidate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitCandidate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitCandidate* internal_default_instance() {
    return reinterpret_cast<const SplitCandidate*>(
               &_SplitCandidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(SplitCandidate* other);
  void Swap(SplitCandidate* other);
  friend void swap(SplitCandidate& a, SplitCandidate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitCandidate* New() const final {
    return CreateMaybeMessage<SplitCandidate>(NULL);
  }

  SplitCandidate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SplitCandidate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SplitCandidate& from);
  void MergeFrom(const SplitCandidate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitCandidate* other);
  protected:
  explicit SplitCandidate(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string unique_id = 6;
  void clear_unique_id();
  static const int kUniqueIdFieldNumber = 6;
  const ::std::string& unique_id() const;
  void set_unique_id(const ::std::string& value);
  #if LANG_CXX11
  void set_unique_id(::std::string&& value);
  #endif
  void set_unique_id(const char* value);
  void set_unique_id(const char* value, size_t size);
  ::std::string* mutable_unique_id();
  ::std::string* release_unique_id();
  void set_allocated_unique_id(::std::string* unique_id);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_unique_id();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_unique_id(
      ::std::string* unique_id);

  // .tensorflow.decision_trees.BinaryNode split = 1;
  bool has_split() const;
  void clear_split();
  static const int kSplitFieldNumber = 1;
  private:
  const ::tensorflow::decision_trees::BinaryNode& _internal_split() const;
  public:
  const ::tensorflow::decision_trees::BinaryNode& split() const;
  ::tensorflow::decision_trees::BinaryNode* release_split();
  ::tensorflow::decision_trees::BinaryNode* mutable_split();
  void set_allocated_split(::tensorflow::decision_trees::BinaryNode* split);
  void unsafe_arena_set_allocated_split(
      ::tensorflow::decision_trees::BinaryNode* split);
  ::tensorflow::decision_trees::BinaryNode* unsafe_arena_release_split();

  // .tensorflow.tensorforest.LeafStat left_stats = 4;
  bool has_left_stats() const;
  void clear_left_stats();
  static const int kLeftStatsFieldNumber = 4;
  private:
  const ::tensorflow::tensorforest::LeafStat& _internal_left_stats() const;
  public:
  const ::tensorflow::tensorforest::LeafStat& left_stats() const;
  ::tensorflow::tensorforest::LeafStat* release_left_stats();
  ::tensorflow::tensorforest::LeafStat* mutable_left_stats();
  void set_allocated_left_stats(::tensorflow::tensorforest::LeafStat* left_stats);
  void unsafe_arena_set_allocated_left_stats(
      ::tensorflow::tensorforest::LeafStat* left_stats);
  ::tensorflow::tensorforest::LeafStat* unsafe_arena_release_left_stats();

  // .tensorflow.tensorforest.LeafStat right_stats = 5;
  bool has_right_stats() const;
  void clear_right_stats();
  static const int kRightStatsFieldNumber = 5;
  private:
  const ::tensorflow::tensorforest::LeafStat& _internal_right_stats() const;
  public:
  const ::tensorflow::tensorforest::LeafStat& right_stats() const;
  ::tensorflow::tensorforest::LeafStat* release_right_stats();
  ::tensorflow::tensorforest::LeafStat* mutable_right_stats();
  void set_allocated_right_stats(::tensorflow::tensorforest::LeafStat* right_stats);
  void unsafe_arena_set_allocated_right_stats(
      ::tensorflow::tensorforest::LeafStat* right_stats);
  ::tensorflow::tensorforest::LeafStat* unsafe_arena_release_right_stats();

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.SplitCandidate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr unique_id_;
  ::tensorflow::decision_trees::BinaryNode* split_;
  ::tensorflow::tensorforest::LeafStat* left_stats_;
  ::tensorflow::tensorforest::LeafStat* right_stats_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TreePath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.TreePath) */ {
 public:
  TreePath();
  virtual ~TreePath();

  TreePath(const TreePath& from);

  inline TreePath& operator=(const TreePath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TreePath(TreePath&& from) noexcept
    : TreePath() {
    *this = ::std::move(from);
  }

  inline TreePath& operator=(TreePath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TreePath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreePath* internal_default_instance() {
    return reinterpret_cast<const TreePath*>(
               &_TreePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(TreePath* other);
  void Swap(TreePath* other);
  friend void swap(TreePath& a, TreePath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TreePath* New() const final {
    return CreateMaybeMessage<TreePath>(NULL);
  }

  TreePath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TreePath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TreePath& from);
  void MergeFrom(const TreePath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreePath* other);
  protected:
  explicit TreePath(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.decision_trees.TreeNode nodes_visited = 1;
  int nodes_visited_size() const;
  void clear_nodes_visited();
  static const int kNodesVisitedFieldNumber = 1;
  ::tensorflow::decision_trees::TreeNode* mutable_nodes_visited(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >*
      mutable_nodes_visited();
  const ::tensorflow::decision_trees::TreeNode& nodes_visited(int index) const;
  ::tensorflow::decision_trees::TreeNode* add_nodes_visited();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >&
      nodes_visited() const;

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.TreePath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode > nodes_visited_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FertileStats

// repeated .tensorflow.tensorforest.FertileSlot node_to_slot = 1;
inline int FertileStats::node_to_slot_size() const {
  return node_to_slot_.size();
}
inline void FertileStats::clear_node_to_slot() {
  node_to_slot_.Clear();
}
inline ::tensorflow::tensorforest::FertileSlot* FertileStats::mutable_node_to_slot(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.FertileStats.node_to_slot)
  return node_to_slot_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot >*
FertileStats::mutable_node_to_slot() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.tensorforest.FertileStats.node_to_slot)
  return &node_to_slot_;
}
inline const ::tensorflow::tensorforest::FertileSlot& FertileStats::node_to_slot(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileStats.node_to_slot)
  return node_to_slot_.Get(index);
}
inline ::tensorflow::tensorforest::FertileSlot* FertileStats::add_node_to_slot() {
  // @@protoc_insertion_point(field_add:tensorflow.tensorforest.FertileStats.node_to_slot)
  return node_to_slot_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot >&
FertileStats::node_to_slot() const {
  // @@protoc_insertion_point(field_list:tensorflow.tensorforest.FertileStats.node_to_slot)
  return node_to_slot_;
}

// -------------------------------------------------------------------

// GiniStats

// float square = 2;
inline void GiniStats::clear_square() {
  square_ = 0;
}
inline float GiniStats::square() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.GiniStats.square)
  return square_;
}
inline void GiniStats::set_square(float value) {
  
  square_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.GiniStats.square)
}

// -------------------------------------------------------------------

// LeafStat_GiniImpurityClassificationStats

// .tensorflow.decision_trees.Vector dense_counts = 1;
inline bool LeafStat_GiniImpurityClassificationStats::has_dense_counts() const {
  return counts_case() == kDenseCounts;
}
inline void LeafStat_GiniImpurityClassificationStats::set_has_dense_counts() {
  _oneof_case_[0] = kDenseCounts;
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_GiniImpurityClassificationStats::_internal_dense_counts() const {
  return *counts_.dense_counts_;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_GiniImpurityClassificationStats::release_dense_counts() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
  if (has_dense_counts()) {
    clear_has_counts();
      ::tensorflow::decision_trees::Vector* temp = counts_.dense_counts_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    counts_.dense_counts_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_GiniImpurityClassificationStats::dense_counts() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
  return has_dense_counts()
      ? *counts_.dense_counts_
      : *reinterpret_cast< ::tensorflow::decision_trees::Vector*>(&::tensorflow::decision_trees::_Vector_default_instance_);
}
inline ::tensorflow::decision_trees::Vector* LeafStat_GiniImpurityClassificationStats::unsafe_arena_release_dense_counts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
  if (has_dense_counts()) {
    clear_has_counts();
    ::tensorflow::decision_trees::Vector* temp = counts_.dense_counts_;
    counts_.dense_counts_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LeafStat_GiniImpurityClassificationStats::unsafe_arena_set_allocated_dense_counts(::tensorflow::decision_trees::Vector* dense_counts) {
  clear_counts();
  if (dense_counts) {
    set_has_dense_counts();
    counts_.dense_counts_ = dense_counts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
}
inline ::tensorflow::decision_trees::Vector* LeafStat_GiniImpurityClassificationStats::mutable_dense_counts() {
  if (!has_dense_counts()) {
    clear_counts();
    set_has_dense_counts();
    counts_.dense_counts_ = CreateMaybeMessage< ::tensorflow::decision_trees::Vector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
  return counts_.dense_counts_;
}

// .tensorflow.decision_trees.SparseVector sparse_counts = 2;
inline bool LeafStat_GiniImpurityClassificationStats::has_sparse_counts() const {
  return counts_case() == kSparseCounts;
}
inline void LeafStat_GiniImpurityClassificationStats::set_has_sparse_counts() {
  _oneof_case_[0] = kSparseCounts;
}
inline const ::tensorflow::decision_trees::SparseVector& LeafStat_GiniImpurityClassificationStats::_internal_sparse_counts() const {
  return *counts_.sparse_counts_;
}
inline ::tensorflow::decision_trees::SparseVector* LeafStat_GiniImpurityClassificationStats::release_sparse_counts() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
  if (has_sparse_counts()) {
    clear_has_counts();
      ::tensorflow::decision_trees::SparseVector* temp = counts_.sparse_counts_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    counts_.sparse_counts_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::decision_trees::SparseVector& LeafStat_GiniImpurityClassificationStats::sparse_counts() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
  return has_sparse_counts()
      ? *counts_.sparse_counts_
      : *reinterpret_cast< ::tensorflow::decision_trees::SparseVector*>(&::tensorflow::decision_trees::_SparseVector_default_instance_);
}
inline ::tensorflow::decision_trees::SparseVector* LeafStat_GiniImpurityClassificationStats::unsafe_arena_release_sparse_counts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
  if (has_sparse_counts()) {
    clear_has_counts();
    ::tensorflow::decision_trees::SparseVector* temp = counts_.sparse_counts_;
    counts_.sparse_counts_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LeafStat_GiniImpurityClassificationStats::unsafe_arena_set_allocated_sparse_counts(::tensorflow::decision_trees::SparseVector* sparse_counts) {
  clear_counts();
  if (sparse_counts) {
    set_has_sparse_counts();
    counts_.sparse_counts_ = sparse_counts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
}
inline ::tensorflow::decision_trees::SparseVector* LeafStat_GiniImpurityClassificationStats::mutable_sparse_counts() {
  if (!has_sparse_counts()) {
    clear_counts();
    set_has_sparse_counts();
    counts_.sparse_counts_ = CreateMaybeMessage< ::tensorflow::decision_trees::SparseVector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
  return counts_.sparse_counts_;
}

// .tensorflow.tensorforest.GiniStats gini = 3;
inline bool LeafStat_GiniImpurityClassificationStats::has_gini() const {
  return this != internal_default_instance() && gini_ != NULL;
}
inline void LeafStat_GiniImpurityClassificationStats::clear_gini() {
  if (GetArenaNoVirtual() == NULL && gini_ != NULL) {
    delete gini_;
  }
  gini_ = NULL;
}
inline const ::tensorflow::tensorforest::GiniStats& LeafStat_GiniImpurityClassificationStats::_internal_gini() const {
  return *gini_;
}
inline const ::tensorflow::tensorforest::GiniStats& LeafStat_GiniImpurityClassificationStats::gini() const {
  const ::tensorflow::tensorforest::GiniStats* p = gini_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::GiniStats*>(
      &::tensorflow::tensorforest::_GiniStats_default_instance_);
}
inline ::tensorflow::tensorforest::GiniStats* LeafStat_GiniImpurityClassificationStats::release_gini() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
  
  ::tensorflow::tensorforest::GiniStats* temp = gini_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  gini_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::GiniStats* LeafStat_GiniImpurityClassificationStats::unsafe_arena_release_gini() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
  
  ::tensorflow::tensorforest::GiniStats* temp = gini_;
  gini_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::GiniStats* LeafStat_GiniImpurityClassificationStats::mutable_gini() {
  
  if (gini_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::GiniStats>(GetArenaNoVirtual());
    gini_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
  return gini_;
}
inline void LeafStat_GiniImpurityClassificationStats::set_allocated_gini(::tensorflow::tensorforest::GiniStats* gini) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gini_;
  }
  if (gini) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(gini);
    if (message_arena != submessage_arena) {
      gini = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gini, submessage_arena);
    }
    
  } else {
    
  }
  gini_ = gini;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
}

inline bool LeafStat_GiniImpurityClassificationStats::has_counts() const {
  return counts_case() != COUNTS_NOT_SET;
}
inline void LeafStat_GiniImpurityClassificationStats::clear_has_counts() {
  _oneof_case_[0] = COUNTS_NOT_SET;
}
inline LeafStat_GiniImpurityClassificationStats::CountsCase LeafStat_GiniImpurityClassificationStats::counts_case() const {
  return LeafStat_GiniImpurityClassificationStats::CountsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LeafStat_LeastSquaresRegressionStats

// .tensorflow.decision_trees.Vector mean_output = 1;
inline bool LeafStat_LeastSquaresRegressionStats::has_mean_output() const {
  return this != internal_default_instance() && mean_output_ != NULL;
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_LeastSquaresRegressionStats::_internal_mean_output() const {
  return *mean_output_;
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_LeastSquaresRegressionStats::mean_output() const {
  const ::tensorflow::decision_trees::Vector* p = mean_output_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::Vector*>(
      &::tensorflow::decision_trees::_Vector_default_instance_);
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::release_mean_output() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
  
  ::tensorflow::decision_trees::Vector* temp = mean_output_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  mean_output_ = NULL;
  return temp;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::unsafe_arena_release_mean_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
  
  ::tensorflow::decision_trees::Vector* temp = mean_output_;
  mean_output_ = NULL;
  return temp;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::mutable_mean_output() {
  
  if (mean_output_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::Vector>(GetArenaNoVirtual());
    mean_output_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
  return mean_output_;
}
inline void LeafStat_LeastSquaresRegressionStats::set_allocated_mean_output(::tensorflow::decision_trees::Vector* mean_output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mean_output_);
  }
  if (mean_output) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(mean_output)->GetArena();
    if (message_arena != submessage_arena) {
      mean_output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mean_output, submessage_arena);
    }
    
  } else {
    
  }
  mean_output_ = mean_output;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
}

// .tensorflow.decision_trees.Vector mean_output_squares = 2;
inline bool LeafStat_LeastSquaresRegressionStats::has_mean_output_squares() const {
  return this != internal_default_instance() && mean_output_squares_ != NULL;
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_LeastSquaresRegressionStats::_internal_mean_output_squares() const {
  return *mean_output_squares_;
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_LeastSquaresRegressionStats::mean_output_squares() const {
  const ::tensorflow::decision_trees::Vector* p = mean_output_squares_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::Vector*>(
      &::tensorflow::decision_trees::_Vector_default_instance_);
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::release_mean_output_squares() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
  
  ::tensorflow::decision_trees::Vector* temp = mean_output_squares_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  mean_output_squares_ = NULL;
  return temp;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::unsafe_arena_release_mean_output_squares() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
  
  ::tensorflow::decision_trees::Vector* temp = mean_output_squares_;
  mean_output_squares_ = NULL;
  return temp;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::mutable_mean_output_squares() {
  
  if (mean_output_squares_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::Vector>(GetArenaNoVirtual());
    mean_output_squares_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
  return mean_output_squares_;
}
inline void LeafStat_LeastSquaresRegressionStats::set_allocated_mean_output_squares(::tensorflow::decision_trees::Vector* mean_output_squares) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mean_output_squares_);
  }
  if (mean_output_squares) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(mean_output_squares)->GetArena();
    if (message_arena != submessage_arena) {
      mean_output_squares = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mean_output_squares, submessage_arena);
    }
    
  } else {
    
  }
  mean_output_squares_ = mean_output_squares;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
}

// -------------------------------------------------------------------

// LeafStat

// float weight_sum = 3;
inline void LeafStat::clear_weight_sum() {
  weight_sum_ = 0;
}
inline float LeafStat::weight_sum() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.weight_sum)
  return weight_sum_;
}
inline void LeafStat::set_weight_sum(float value) {
  
  weight_sum_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.LeafStat.weight_sum)
}

// .tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats classification = 1;
inline bool LeafStat::has_classification() const {
  return leaf_stat_case() == kClassification;
}
inline void LeafStat::set_has_classification() {
  _oneof_case_[0] = kClassification;
}
inline void LeafStat::clear_classification() {
  if (has_classification()) {
    if (GetArenaNoVirtual() == NULL) {
      delete leaf_stat_.classification_;
    }
    clear_has_leaf_stat();
  }
}
inline const ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats& LeafStat::_internal_classification() const {
  return *leaf_stat_.classification_;
}
inline ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* LeafStat::release_classification() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.classification)
  if (has_classification()) {
    clear_has_leaf_stat();
      ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* temp = leaf_stat_.classification_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    leaf_stat_.classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats& LeafStat::classification() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.classification)
  return has_classification()
      ? *leaf_stat_.classification_
      : *reinterpret_cast< ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats*>(&::tensorflow::tensorforest::_LeafStat_GiniImpurityClassificationStats_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* LeafStat::unsafe_arena_release_classification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.classification)
  if (has_classification()) {
    clear_has_leaf_stat();
    ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* temp = leaf_stat_.classification_;
    leaf_stat_.classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LeafStat::unsafe_arena_set_allocated_classification(::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* classification) {
  clear_leaf_stat();
  if (classification) {
    set_has_classification();
    leaf_stat_.classification_ = classification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.LeafStat.classification)
}
inline ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* LeafStat::mutable_classification() {
  if (!has_classification()) {
    clear_leaf_stat();
    set_has_classification();
    leaf_stat_.classification_ = CreateMaybeMessage< ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.classification)
  return leaf_stat_.classification_;
}

// .tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats regression = 2;
inline bool LeafStat::has_regression() const {
  return leaf_stat_case() == kRegression;
}
inline void LeafStat::set_has_regression() {
  _oneof_case_[0] = kRegression;
}
inline void LeafStat::clear_regression() {
  if (has_regression()) {
    if (GetArenaNoVirtual() == NULL) {
      delete leaf_stat_.regression_;
    }
    clear_has_leaf_stat();
  }
}
inline const ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats& LeafStat::_internal_regression() const {
  return *leaf_stat_.regression_;
}
inline ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* LeafStat::release_regression() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.regression)
  if (has_regression()) {
    clear_has_leaf_stat();
      ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* temp = leaf_stat_.regression_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    leaf_stat_.regression_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats& LeafStat::regression() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.regression)
  return has_regression()
      ? *leaf_stat_.regression_
      : *reinterpret_cast< ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats*>(&::tensorflow::tensorforest::_LeafStat_LeastSquaresRegressionStats_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* LeafStat::unsafe_arena_release_regression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.regression)
  if (has_regression()) {
    clear_has_leaf_stat();
    ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* temp = leaf_stat_.regression_;
    leaf_stat_.regression_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LeafStat::unsafe_arena_set_allocated_regression(::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* regression) {
  clear_leaf_stat();
  if (regression) {
    set_has_regression();
    leaf_stat_.regression_ = regression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.LeafStat.regression)
}
inline ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* LeafStat::mutable_regression() {
  if (!has_regression()) {
    clear_leaf_stat();
    set_has_regression();
    leaf_stat_.regression_ = CreateMaybeMessage< ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.regression)
  return leaf_stat_.regression_;
}

inline bool LeafStat::has_leaf_stat() const {
  return leaf_stat_case() != LEAF_STAT_NOT_SET;
}
inline void LeafStat::clear_has_leaf_stat() {
  _oneof_case_[0] = LEAF_STAT_NOT_SET;
}
inline LeafStat::LeafStatCase LeafStat::leaf_stat_case() const {
  return LeafStat::LeafStatCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FertileSlot

// .tensorflow.tensorforest.LeafStat leaf_stats = 4;
inline bool FertileSlot::has_leaf_stats() const {
  return this != internal_default_instance() && leaf_stats_ != NULL;
}
inline void FertileSlot::clear_leaf_stats() {
  if (GetArenaNoVirtual() == NULL && leaf_stats_ != NULL) {
    delete leaf_stats_;
  }
  leaf_stats_ = NULL;
}
inline const ::tensorflow::tensorforest::LeafStat& FertileSlot::_internal_leaf_stats() const {
  return *leaf_stats_;
}
inline const ::tensorflow::tensorforest::LeafStat& FertileSlot::leaf_stats() const {
  const ::tensorflow::tensorforest::LeafStat* p = leaf_stats_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.leaf_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::LeafStat*>(
      &::tensorflow::tensorforest::_LeafStat_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::release_leaf_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.FertileSlot.leaf_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = leaf_stats_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  leaf_stats_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::unsafe_arena_release_leaf_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.FertileSlot.leaf_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = leaf_stats_;
  leaf_stats_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::mutable_leaf_stats() {
  
  if (leaf_stats_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(GetArenaNoVirtual());
    leaf_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.FertileSlot.leaf_stats)
  return leaf_stats_;
}
inline void FertileSlot::set_allocated_leaf_stats(::tensorflow::tensorforest::LeafStat* leaf_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leaf_stats_;
  }
  if (leaf_stats) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(leaf_stats);
    if (message_arena != submessage_arena) {
      leaf_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leaf_stats, submessage_arena);
    }
    
  } else {
    
  }
  leaf_stats_ = leaf_stats;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.FertileSlot.leaf_stats)
}

// repeated .tensorflow.tensorforest.SplitCandidate candidates = 1;
inline int FertileSlot::candidates_size() const {
  return candidates_.size();
}
inline void FertileSlot::clear_candidates() {
  candidates_.Clear();
}
inline ::tensorflow::tensorforest::SplitCandidate* FertileSlot::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.FertileSlot.candidates)
  return candidates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate >*
FertileSlot::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.tensorforest.FertileSlot.candidates)
  return &candidates_;
}
inline const ::tensorflow::tensorforest::SplitCandidate& FertileSlot::candidates(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.candidates)
  return candidates_.Get(index);
}
inline ::tensorflow::tensorforest::SplitCandidate* FertileSlot::add_candidates() {
  // @@protoc_insertion_point(field_add:tensorflow.tensorforest.FertileSlot.candidates)
  return candidates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate >&
FertileSlot::candidates() const {
  // @@protoc_insertion_point(field_list:tensorflow.tensorforest.FertileSlot.candidates)
  return candidates_;
}

// .tensorflow.tensorforest.LeafStat post_init_leaf_stats = 6;
inline bool FertileSlot::has_post_init_leaf_stats() const {
  return this != internal_default_instance() && post_init_leaf_stats_ != NULL;
}
inline void FertileSlot::clear_post_init_leaf_stats() {
  if (GetArenaNoVirtual() == NULL && post_init_leaf_stats_ != NULL) {
    delete post_init_leaf_stats_;
  }
  post_init_leaf_stats_ = NULL;
}
inline const ::tensorflow::tensorforest::LeafStat& FertileSlot::_internal_post_init_leaf_stats() const {
  return *post_init_leaf_stats_;
}
inline const ::tensorflow::tensorforest::LeafStat& FertileSlot::post_init_leaf_stats() const {
  const ::tensorflow::tensorforest::LeafStat* p = post_init_leaf_stats_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::LeafStat*>(
      &::tensorflow::tensorforest::_LeafStat_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::release_post_init_leaf_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = post_init_leaf_stats_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  post_init_leaf_stats_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::unsafe_arena_release_post_init_leaf_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = post_init_leaf_stats_;
  post_init_leaf_stats_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::mutable_post_init_leaf_stats() {
  
  if (post_init_leaf_stats_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(GetArenaNoVirtual());
    post_init_leaf_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
  return post_init_leaf_stats_;
}
inline void FertileSlot::set_allocated_post_init_leaf_stats(::tensorflow::tensorforest::LeafStat* post_init_leaf_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete post_init_leaf_stats_;
  }
  if (post_init_leaf_stats) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(post_init_leaf_stats);
    if (message_arena != submessage_arena) {
      post_init_leaf_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, post_init_leaf_stats, submessage_arena);
    }
    
  } else {
    
  }
  post_init_leaf_stats_ = post_init_leaf_stats;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
}

// int32 node_id = 5;
inline void FertileSlot::clear_node_id() {
  node_id_ = 0;
}
inline ::google::protobuf::int32 FertileSlot::node_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.node_id)
  return node_id_;
}
inline void FertileSlot::set_node_id(::google::protobuf::int32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.FertileSlot.node_id)
}

// int32 depth = 7;
inline void FertileSlot::clear_depth() {
  depth_ = 0;
}
inline ::google::protobuf::int32 FertileSlot::depth() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.depth)
  return depth_;
}
inline void FertileSlot::set_depth(::google::protobuf::int32 value) {
  
  depth_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.FertileSlot.depth)
}

// -------------------------------------------------------------------

// SplitCandidate

// .tensorflow.decision_trees.BinaryNode split = 1;
inline bool SplitCandidate::has_split() const {
  return this != internal_default_instance() && split_ != NULL;
}
inline const ::tensorflow::decision_trees::BinaryNode& SplitCandidate::_internal_split() const {
  return *split_;
}
inline const ::tensorflow::decision_trees::BinaryNode& SplitCandidate::split() const {
  const ::tensorflow::decision_trees::BinaryNode* p = split_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitCandidate.split)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::BinaryNode*>(
      &::tensorflow::decision_trees::_BinaryNode_default_instance_);
}
inline ::tensorflow::decision_trees::BinaryNode* SplitCandidate::release_split() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitCandidate.split)
  
  ::tensorflow::decision_trees::BinaryNode* temp = split_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  split_ = NULL;
  return temp;
}
inline ::tensorflow::decision_trees::BinaryNode* SplitCandidate::unsafe_arena_release_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.SplitCandidate.split)
  
  ::tensorflow::decision_trees::BinaryNode* temp = split_;
  split_ = NULL;
  return temp;
}
inline ::tensorflow::decision_trees::BinaryNode* SplitCandidate::mutable_split() {
  
  if (split_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::BinaryNode>(GetArenaNoVirtual());
    split_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitCandidate.split)
  return split_;
}
inline void SplitCandidate::set_allocated_split(::tensorflow::decision_trees::BinaryNode* split) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(split_);
  }
  if (split) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(split)->GetArena();
    if (message_arena != submessage_arena) {
      split = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, split, submessage_arena);
    }
    
  } else {
    
  }
  split_ = split;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitCandidate.split)
}

// .tensorflow.tensorforest.LeafStat left_stats = 4;
inline bool SplitCandidate::has_left_stats() const {
  return this != internal_default_instance() && left_stats_ != NULL;
}
inline void SplitCandidate::clear_left_stats() {
  if (GetArenaNoVirtual() == NULL && left_stats_ != NULL) {
    delete left_stats_;
  }
  left_stats_ = NULL;
}
inline const ::tensorflow::tensorforest::LeafStat& SplitCandidate::_internal_left_stats() const {
  return *left_stats_;
}
inline const ::tensorflow::tensorforest::LeafStat& SplitCandidate::left_stats() const {
  const ::tensorflow::tensorforest::LeafStat* p = left_stats_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitCandidate.left_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::LeafStat*>(
      &::tensorflow::tensorforest::_LeafStat_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::release_left_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitCandidate.left_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = left_stats_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  left_stats_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::unsafe_arena_release_left_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.SplitCandidate.left_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = left_stats_;
  left_stats_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::mutable_left_stats() {
  
  if (left_stats_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(GetArenaNoVirtual());
    left_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitCandidate.left_stats)
  return left_stats_;
}
inline void SplitCandidate::set_allocated_left_stats(::tensorflow::tensorforest::LeafStat* left_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_stats_;
  }
  if (left_stats) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(left_stats);
    if (message_arena != submessage_arena) {
      left_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left_stats, submessage_arena);
    }
    
  } else {
    
  }
  left_stats_ = left_stats;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitCandidate.left_stats)
}

// .tensorflow.tensorforest.LeafStat right_stats = 5;
inline bool SplitCandidate::has_right_stats() const {
  return this != internal_default_instance() && right_stats_ != NULL;
}
inline void SplitCandidate::clear_right_stats() {
  if (GetArenaNoVirtual() == NULL && right_stats_ != NULL) {
    delete right_stats_;
  }
  right_stats_ = NULL;
}
inline const ::tensorflow::tensorforest::LeafStat& SplitCandidate::_internal_right_stats() const {
  return *right_stats_;
}
inline const ::tensorflow::tensorforest::LeafStat& SplitCandidate::right_stats() const {
  const ::tensorflow::tensorforest::LeafStat* p = right_stats_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitCandidate.right_stats)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::LeafStat*>(
      &::tensorflow::tensorforest::_LeafStat_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::release_right_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitCandidate.right_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = right_stats_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  right_stats_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::unsafe_arena_release_right_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.SplitCandidate.right_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = right_stats_;
  right_stats_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::mutable_right_stats() {
  
  if (right_stats_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(GetArenaNoVirtual());
    right_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitCandidate.right_stats)
  return right_stats_;
}
inline void SplitCandidate::set_allocated_right_stats(::tensorflow::tensorforest::LeafStat* right_stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_stats_;
  }
  if (right_stats) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(right_stats);
    if (message_arena != submessage_arena) {
      right_stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right_stats, submessage_arena);
    }
    
  } else {
    
  }
  right_stats_ = right_stats;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitCandidate.right_stats)
}

// string unique_id = 6;
inline void SplitCandidate::clear_unique_id() {
  unique_id_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& SplitCandidate::unique_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitCandidate.unique_id)
  return unique_id_.Get();
}
inline void SplitCandidate::set_unique_id(const ::std::string& value) {
  
  unique_id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.SplitCandidate.unique_id)
}
#if LANG_CXX11
inline void SplitCandidate::set_unique_id(::std::string&& value) {
  
  unique_id_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.tensorforest.SplitCandidate.unique_id)
}
#endif
inline void SplitCandidate::set_unique_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  unique_id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.tensorforest.SplitCandidate.unique_id)
}
inline void SplitCandidate::set_unique_id(const char* value,
    size_t size) {
  
  unique_id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.tensorforest.SplitCandidate.unique_id)
}
inline ::std::string* SplitCandidate::mutable_unique_id() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitCandidate.unique_id)
  return unique_id_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SplitCandidate::release_unique_id() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitCandidate.unique_id)
  
  return unique_id_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void SplitCandidate::set_allocated_unique_id(::std::string* unique_id) {
  if (unique_id != NULL) {
    
  } else {
    
  }
  unique_id_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unique_id,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitCandidate.unique_id)
}
inline ::std::string* SplitCandidate::unsafe_arena_release_unique_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.SplitCandidate.unique_id)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return unique_id_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SplitCandidate::unsafe_arena_set_allocated_unique_id(
    ::std::string* unique_id) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (unique_id != NULL) {
    
  } else {
    
  }
  unique_id_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      unique_id, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.SplitCandidate.unique_id)
}

// -------------------------------------------------------------------

// TreePath

// repeated .tensorflow.decision_trees.TreeNode nodes_visited = 1;
inline int TreePath::nodes_visited_size() const {
  return nodes_visited_.size();
}
inline ::tensorflow::decision_trees::TreeNode* TreePath::mutable_nodes_visited(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TreePath.nodes_visited)
  return nodes_visited_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >*
TreePath::mutable_nodes_visited() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.tensorforest.TreePath.nodes_visited)
  return &nodes_visited_;
}
inline const ::tensorflow::decision_trees::TreeNode& TreePath::nodes_visited(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TreePath.nodes_visited)
  return nodes_visited_.Get(index);
}
inline ::tensorflow::decision_trees::TreeNode* TreePath::add_nodes_visited() {
  // @@protoc_insertion_point(field_add:tensorflow.tensorforest.TreePath.nodes_visited)
  return nodes_visited_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >&
TreePath::nodes_visited() const {
  // @@protoc_insertion_point(field_list:tensorflow.tensorforest.TreePath.nodes_visited)
  return nodes_visited_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorforest
}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ffertile_5fstats_2eproto
