// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/contrib/tensor_forest/proto/tensor_forest_params.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/contrib/decision_trees/proto/generic_tree_model.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto 

namespace protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto
namespace tensorflow {
namespace tensorforest {
class DepthDependentParam;
class DepthDependentParamDefaultTypeInternal;
extern DepthDependentParamDefaultTypeInternal _DepthDependentParam_default_instance_;
class ExponentialParam;
class ExponentialParamDefaultTypeInternal;
extern ExponentialParamDefaultTypeInternal _ExponentialParam_default_instance_;
class LinearParam;
class LinearParamDefaultTypeInternal;
extern LinearParamDefaultTypeInternal _LinearParam_default_instance_;
class SplitFinishConfig;
class SplitFinishConfigDefaultTypeInternal;
extern SplitFinishConfigDefaultTypeInternal _SplitFinishConfig_default_instance_;
class SplitPruningConfig;
class SplitPruningConfigDefaultTypeInternal;
extern SplitPruningConfigDefaultTypeInternal _SplitPruningConfig_default_instance_;
class TensorForestParams;
class TensorForestParamsDefaultTypeInternal;
extern TensorForestParamsDefaultTypeInternal _TensorForestParams_default_instance_;
class ThresholdParam;
class ThresholdParamDefaultTypeInternal;
extern ThresholdParamDefaultTypeInternal _ThresholdParam_default_instance_;
}  // namespace tensorforest
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::tensorforest::DepthDependentParam* Arena::CreateMaybeMessage<::tensorflow::tensorforest::DepthDependentParam>(Arena*);
template<> ::tensorflow::tensorforest::ExponentialParam* Arena::CreateMaybeMessage<::tensorflow::tensorforest::ExponentialParam>(Arena*);
template<> ::tensorflow::tensorforest::LinearParam* Arena::CreateMaybeMessage<::tensorflow::tensorforest::LinearParam>(Arena*);
template<> ::tensorflow::tensorforest::SplitFinishConfig* Arena::CreateMaybeMessage<::tensorflow::tensorforest::SplitFinishConfig>(Arena*);
template<> ::tensorflow::tensorforest::SplitPruningConfig* Arena::CreateMaybeMessage<::tensorflow::tensorforest::SplitPruningConfig>(Arena*);
template<> ::tensorflow::tensorforest::TensorForestParams* Arena::CreateMaybeMessage<::tensorflow::tensorforest::TensorForestParams>(Arena*);
template<> ::tensorflow::tensorforest::ThresholdParam* Arena::CreateMaybeMessage<::tensorflow::tensorforest::ThresholdParam>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace tensorforest {

enum LeafModelType {
  MODEL_DENSE_CLASSIFICATION = 0,
  MODEL_SPARSE_CLASSIFICATION = 1,
  MODEL_REGRESSION = 2,
  MODEL_SPARSE_OR_DENSE_CLASSIFICATION = 3,
  LeafModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LeafModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LeafModelType_IsValid(int value);
const LeafModelType LeafModelType_MIN = MODEL_DENSE_CLASSIFICATION;
const LeafModelType LeafModelType_MAX = MODEL_SPARSE_OR_DENSE_CLASSIFICATION;
const int LeafModelType_ARRAYSIZE = LeafModelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LeafModelType_descriptor();
inline const ::std::string& LeafModelType_Name(LeafModelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LeafModelType_descriptor(), value);
}
inline bool LeafModelType_Parse(
    const ::std::string& name, LeafModelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LeafModelType>(
    LeafModelType_descriptor(), name, value);
}
enum StatsModelType {
  STATS_DENSE_GINI = 0,
  STATS_SPARSE_GINI = 1,
  STATS_LEAST_SQUARES_REGRESSION = 2,
  STATS_SPARSE_THEN_DENSE_GINI = 3,
  STATS_FIXED_SIZE_SPARSE_GINI = 4,
  StatsModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StatsModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StatsModelType_IsValid(int value);
const StatsModelType StatsModelType_MIN = STATS_DENSE_GINI;
const StatsModelType StatsModelType_MAX = STATS_FIXED_SIZE_SPARSE_GINI;
const int StatsModelType_ARRAYSIZE = StatsModelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatsModelType_descriptor();
inline const ::std::string& StatsModelType_Name(StatsModelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatsModelType_descriptor(), value);
}
inline bool StatsModelType_Parse(
    const ::std::string& name, StatsModelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatsModelType>(
    StatsModelType_descriptor(), name, value);
}
enum SplitCollectionType {
  COLLECTION_BASIC = 0,
  GRAPH_RUNNER_COLLECTION = 1,
  SplitCollectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SplitCollectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SplitCollectionType_IsValid(int value);
const SplitCollectionType SplitCollectionType_MIN = COLLECTION_BASIC;
const SplitCollectionType SplitCollectionType_MAX = GRAPH_RUNNER_COLLECTION;
const int SplitCollectionType_ARRAYSIZE = SplitCollectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SplitCollectionType_descriptor();
inline const ::std::string& SplitCollectionType_Name(SplitCollectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SplitCollectionType_descriptor(), value);
}
inline bool SplitCollectionType_Parse(
    const ::std::string& name, SplitCollectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SplitCollectionType>(
    SplitCollectionType_descriptor(), name, value);
}
enum SplitPruningStrategyType {
  SPLIT_PRUNE_NONE = 0,
  SPLIT_PRUNE_HALF = 1,
  SPLIT_PRUNE_QUARTER = 2,
  SPLIT_PRUNE_10_PERCENT = 3,
  SPLIT_PRUNE_HOEFFDING = 4,
  SplitPruningStrategyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SplitPruningStrategyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SplitPruningStrategyType_IsValid(int value);
const SplitPruningStrategyType SplitPruningStrategyType_MIN = SPLIT_PRUNE_NONE;
const SplitPruningStrategyType SplitPruningStrategyType_MAX = SPLIT_PRUNE_HOEFFDING;
const int SplitPruningStrategyType_ARRAYSIZE = SplitPruningStrategyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SplitPruningStrategyType_descriptor();
inline const ::std::string& SplitPruningStrategyType_Name(SplitPruningStrategyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SplitPruningStrategyType_descriptor(), value);
}
inline bool SplitPruningStrategyType_Parse(
    const ::std::string& name, SplitPruningStrategyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SplitPruningStrategyType>(
    SplitPruningStrategyType_descriptor(), name, value);
}
enum SplitFinishStrategyType {
  SPLIT_FINISH_BASIC = 0,
  SPLIT_FINISH_DOMINATE_HOEFFDING = 2,
  SPLIT_FINISH_DOMINATE_BOOTSTRAP = 3,
  SplitFinishStrategyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SplitFinishStrategyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SplitFinishStrategyType_IsValid(int value);
const SplitFinishStrategyType SplitFinishStrategyType_MIN = SPLIT_FINISH_BASIC;
const SplitFinishStrategyType SplitFinishStrategyType_MAX = SPLIT_FINISH_DOMINATE_BOOTSTRAP;
const int SplitFinishStrategyType_ARRAYSIZE = SplitFinishStrategyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SplitFinishStrategyType_descriptor();
inline const ::std::string& SplitFinishStrategyType_Name(SplitFinishStrategyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SplitFinishStrategyType_descriptor(), value);
}
inline bool SplitFinishStrategyType_Parse(
    const ::std::string& name, SplitFinishStrategyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SplitFinishStrategyType>(
    SplitFinishStrategyType_descriptor(), name, value);
}
// ===================================================================

class SplitPruningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.SplitPruningConfig) */ {
 public:
  SplitPruningConfig();
  virtual ~SplitPruningConfig();

  SplitPruningConfig(const SplitPruningConfig& from);

  inline SplitPruningConfig& operator=(const SplitPruningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplitPruningConfig(SplitPruningConfig&& from) noexcept
    : SplitPruningConfig() {
    *this = ::std::move(from);
  }

  inline SplitPruningConfig& operator=(SplitPruningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitPruningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitPruningConfig* internal_default_instance() {
    return reinterpret_cast<const SplitPruningConfig*>(
               &_SplitPruningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SplitPruningConfig* other);
  friend void swap(SplitPruningConfig& a, SplitPruningConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitPruningConfig* New() const final {
    return CreateMaybeMessage<SplitPruningConfig>(NULL);
  }

  SplitPruningConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SplitPruningConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SplitPruningConfig& from);
  void MergeFrom(const SplitPruningConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitPruningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.tensorforest.DepthDependentParam prune_every_samples = 1;
  bool has_prune_every_samples() const;
  void clear_prune_every_samples();
  static const int kPruneEverySamplesFieldNumber = 1;
  private:
  const ::tensorflow::tensorforest::DepthDependentParam& _internal_prune_every_samples() const;
  public:
  const ::tensorflow::tensorforest::DepthDependentParam& prune_every_samples() const;
  ::tensorflow::tensorforest::DepthDependentParam* release_prune_every_samples();
  ::tensorflow::tensorforest::DepthDependentParam* mutable_prune_every_samples();
  void set_allocated_prune_every_samples(::tensorflow::tensorforest::DepthDependentParam* prune_every_samples);

  // .tensorflow.tensorforest.SplitPruningStrategyType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::tensorflow::tensorforest::SplitPruningStrategyType type() const;
  void set_type(::tensorflow::tensorforest::SplitPruningStrategyType value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.SplitPruningConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::tensorforest::DepthDependentParam* prune_every_samples_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SplitFinishConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.SplitFinishConfig) */ {
 public:
  SplitFinishConfig();
  virtual ~SplitFinishConfig();

  SplitFinishConfig(const SplitFinishConfig& from);

  inline SplitFinishConfig& operator=(const SplitFinishConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplitFinishConfig(SplitFinishConfig&& from) noexcept
    : SplitFinishConfig() {
    *this = ::std::move(from);
  }

  inline SplitFinishConfig& operator=(SplitFinishConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitFinishConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitFinishConfig* internal_default_instance() {
    return reinterpret_cast<const SplitFinishConfig*>(
               &_SplitFinishConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SplitFinishConfig* other);
  friend void swap(SplitFinishConfig& a, SplitFinishConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitFinishConfig* New() const final {
    return CreateMaybeMessage<SplitFinishConfig>(NULL);
  }

  SplitFinishConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SplitFinishConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SplitFinishConfig& from);
  void MergeFrom(const SplitFinishConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitFinishConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.tensorforest.DepthDependentParam check_every_steps = 1;
  bool has_check_every_steps() const;
  void clear_check_every_steps();
  static const int kCheckEveryStepsFieldNumber = 1;
  private:
  const ::tensorflow::tensorforest::DepthDependentParam& _internal_check_every_steps() const;
  public:
  const ::tensorflow::tensorforest::DepthDependentParam& check_every_steps() const;
  ::tensorflow::tensorforest::DepthDependentParam* release_check_every_steps();
  ::tensorflow::tensorforest::DepthDependentParam* mutable_check_every_steps();
  void set_allocated_check_every_steps(::tensorflow::tensorforest::DepthDependentParam* check_every_steps);

  // .tensorflow.tensorforest.SplitFinishStrategyType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::tensorflow::tensorforest::SplitFinishStrategyType type() const;
  void set_type(::tensorflow::tensorforest::SplitFinishStrategyType value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.SplitFinishConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::tensorforest::DepthDependentParam* check_every_steps_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinearParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.LinearParam) */ {
 public:
  LinearParam();
  virtual ~LinearParam();

  LinearParam(const LinearParam& from);

  inline LinearParam& operator=(const LinearParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinearParam(LinearParam&& from) noexcept
    : LinearParam() {
    *this = ::std::move(from);
  }

  inline LinearParam& operator=(LinearParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinearParam* internal_default_instance() {
    return reinterpret_cast<const LinearParam*>(
               &_LinearParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LinearParam* other);
  friend void swap(LinearParam& a, LinearParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinearParam* New() const final {
    return CreateMaybeMessage<LinearParam>(NULL);
  }

  LinearParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LinearParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LinearParam& from);
  void MergeFrom(const LinearParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float slope = 1;
  void clear_slope();
  static const int kSlopeFieldNumber = 1;
  float slope() const;
  void set_slope(float value);

  // float y_intercept = 2;
  void clear_y_intercept();
  static const int kYInterceptFieldNumber = 2;
  float y_intercept() const;
  void set_y_intercept(float value);

  // float min_val = 3;
  void clear_min_val();
  static const int kMinValFieldNumber = 3;
  float min_val() const;
  void set_min_val(float value);

  // float max_val = 4;
  void clear_max_val();
  static const int kMaxValFieldNumber = 4;
  float max_val() const;
  void set_max_val(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.LinearParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float slope_;
  float y_intercept_;
  float min_val_;
  float max_val_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExponentialParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.ExponentialParam) */ {
 public:
  ExponentialParam();
  virtual ~ExponentialParam();

  ExponentialParam(const ExponentialParam& from);

  inline ExponentialParam& operator=(const ExponentialParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExponentialParam(ExponentialParam&& from) noexcept
    : ExponentialParam() {
    *this = ::std::move(from);
  }

  inline ExponentialParam& operator=(ExponentialParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExponentialParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExponentialParam* internal_default_instance() {
    return reinterpret_cast<const ExponentialParam*>(
               &_ExponentialParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ExponentialParam* other);
  friend void swap(ExponentialParam& a, ExponentialParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExponentialParam* New() const final {
    return CreateMaybeMessage<ExponentialParam>(NULL);
  }

  ExponentialParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExponentialParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExponentialParam& from);
  void MergeFrom(const ExponentialParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExponentialParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float bias = 1;
  void clear_bias();
  static const int kBiasFieldNumber = 1;
  float bias() const;
  void set_bias(float value);

  // float base = 2;
  void clear_base();
  static const int kBaseFieldNumber = 2;
  float base() const;
  void set_base(float value);

  // float multiplier = 3;
  void clear_multiplier();
  static const int kMultiplierFieldNumber = 3;
  float multiplier() const;
  void set_multiplier(float value);

  // float depth_multiplier = 4;
  void clear_depth_multiplier();
  static const int kDepthMultiplierFieldNumber = 4;
  float depth_multiplier() const;
  void set_depth_multiplier(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.ExponentialParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float bias_;
  float base_;
  float multiplier_;
  float depth_multiplier_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThresholdParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.ThresholdParam) */ {
 public:
  ThresholdParam();
  virtual ~ThresholdParam();

  ThresholdParam(const ThresholdParam& from);

  inline ThresholdParam& operator=(const ThresholdParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThresholdParam(ThresholdParam&& from) noexcept
    : ThresholdParam() {
    *this = ::std::move(from);
  }

  inline ThresholdParam& operator=(ThresholdParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ThresholdParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThresholdParam* internal_default_instance() {
    return reinterpret_cast<const ThresholdParam*>(
               &_ThresholdParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ThresholdParam* other);
  friend void swap(ThresholdParam& a, ThresholdParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThresholdParam* New() const final {
    return CreateMaybeMessage<ThresholdParam>(NULL);
  }

  ThresholdParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ThresholdParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ThresholdParam& from);
  void MergeFrom(const ThresholdParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThresholdParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float on_value = 1;
  void clear_on_value();
  static const int kOnValueFieldNumber = 1;
  float on_value() const;
  void set_on_value(float value);

  // float off_value = 2;
  void clear_off_value();
  static const int kOffValueFieldNumber = 2;
  float off_value() const;
  void set_off_value(float value);

  // float threshold = 3;
  void clear_threshold();
  static const int kThresholdFieldNumber = 3;
  float threshold() const;
  void set_threshold(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.ThresholdParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float on_value_;
  float off_value_;
  float threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DepthDependentParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.DepthDependentParam) */ {
 public:
  DepthDependentParam();
  virtual ~DepthDependentParam();

  DepthDependentParam(const DepthDependentParam& from);

  inline DepthDependentParam& operator=(const DepthDependentParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DepthDependentParam(DepthDependentParam&& from) noexcept
    : DepthDependentParam() {
    *this = ::std::move(from);
  }

  inline DepthDependentParam& operator=(DepthDependentParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DepthDependentParam& default_instance();

  enum ParamTypeCase {
    kConstantValue = 1,
    kLinear = 2,
    kExponential = 3,
    kThreshold = 4,
    PARAMTYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthDependentParam* internal_default_instance() {
    return reinterpret_cast<const DepthDependentParam*>(
               &_DepthDependentParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DepthDependentParam* other);
  friend void swap(DepthDependentParam& a, DepthDependentParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepthDependentParam* New() const final {
    return CreateMaybeMessage<DepthDependentParam>(NULL);
  }

  DepthDependentParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DepthDependentParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DepthDependentParam& from);
  void MergeFrom(const DepthDependentParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthDependentParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float constant_value = 1;
  private:
  bool has_constant_value() const;
  public:
  void clear_constant_value();
  static const int kConstantValueFieldNumber = 1;
  float constant_value() const;
  void set_constant_value(float value);

  // .tensorflow.tensorforest.LinearParam linear = 2;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 2;
  private:
  const ::tensorflow::tensorforest::LinearParam& _internal_linear() const;
  public:
  const ::tensorflow::tensorforest::LinearParam& linear() const;
  ::tensorflow::tensorforest::LinearParam* release_linear();
  ::tensorflow::tensorforest::LinearParam* mutable_linear();
  void set_allocated_linear(::tensorflow::tensorforest::LinearParam* linear);

  // .tensorflow.tensorforest.ExponentialParam exponential = 3;
  bool has_exponential() const;
  void clear_exponential();
  static const int kExponentialFieldNumber = 3;
  private:
  const ::tensorflow::tensorforest::ExponentialParam& _internal_exponential() const;
  public:
  const ::tensorflow::tensorforest::ExponentialParam& exponential() const;
  ::tensorflow::tensorforest::ExponentialParam* release_exponential();
  ::tensorflow::tensorforest::ExponentialParam* mutable_exponential();
  void set_allocated_exponential(::tensorflow::tensorforest::ExponentialParam* exponential);

  // .tensorflow.tensorforest.ThresholdParam threshold = 4;
  bool has_threshold() const;
  void clear_threshold();
  static const int kThresholdFieldNumber = 4;
  private:
  const ::tensorflow::tensorforest::ThresholdParam& _internal_threshold() const;
  public:
  const ::tensorflow::tensorforest::ThresholdParam& threshold() const;
  ::tensorflow::tensorforest::ThresholdParam* release_threshold();
  ::tensorflow::tensorforest::ThresholdParam* mutable_threshold();
  void set_allocated_threshold(::tensorflow::tensorforest::ThresholdParam* threshold);

  void clear_ParamType();
  ParamTypeCase ParamType_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.DepthDependentParam)
 private:
  void set_has_constant_value();
  void set_has_linear();
  void set_has_exponential();
  void set_has_threshold();

  inline bool has_ParamType() const;
  inline void clear_has_ParamType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ParamTypeUnion {
    ParamTypeUnion() {}
    float constant_value_;
    ::tensorflow::tensorforest::LinearParam* linear_;
    ::tensorflow::tensorforest::ExponentialParam* exponential_;
    ::tensorflow::tensorforest::ThresholdParam* threshold_;
  } ParamType_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorForestParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.TensorForestParams) */ {
 public:
  TensorForestParams();
  virtual ~TensorForestParams();

  TensorForestParams(const TensorForestParams& from);

  inline TensorForestParams& operator=(const TensorForestParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorForestParams(TensorForestParams&& from) noexcept
    : TensorForestParams() {
    *this = ::std::move(from);
  }

  inline TensorForestParams& operator=(TensorForestParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorForestParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorForestParams* internal_default_instance() {
    return reinterpret_cast<const TensorForestParams*>(
               &_TensorForestParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TensorForestParams* other);
  friend void swap(TensorForestParams& a, TensorForestParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorForestParams* New() const final {
    return CreateMaybeMessage<TensorForestParams>(NULL);
  }

  TensorForestParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TensorForestParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TensorForestParams& from);
  void MergeFrom(const TensorForestParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorForestParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string graph_dir = 16;
  void clear_graph_dir();
  static const int kGraphDirFieldNumber = 16;
  const ::std::string& graph_dir() const;
  void set_graph_dir(const ::std::string& value);
  #if LANG_CXX11
  void set_graph_dir(::std::string&& value);
  #endif
  void set_graph_dir(const char* value);
  void set_graph_dir(const char* value, size_t size);
  ::std::string* mutable_graph_dir();
  ::std::string* release_graph_dir();
  void set_allocated_graph_dir(::std::string* graph_dir);

  // .tensorflow.tensorforest.SplitPruningConfig pruning_type = 4;
  bool has_pruning_type() const;
  void clear_pruning_type();
  static const int kPruningTypeFieldNumber = 4;
  private:
  const ::tensorflow::tensorforest::SplitPruningConfig& _internal_pruning_type() const;
  public:
  const ::tensorflow::tensorforest::SplitPruningConfig& pruning_type() const;
  ::tensorflow::tensorforest::SplitPruningConfig* release_pruning_type();
  ::tensorflow::tensorforest::SplitPruningConfig* mutable_pruning_type();
  void set_allocated_pruning_type(::tensorflow::tensorforest::SplitPruningConfig* pruning_type);

  // .tensorflow.tensorforest.SplitFinishConfig finish_type = 5;
  bool has_finish_type() const;
  void clear_finish_type();
  static const int kFinishTypeFieldNumber = 5;
  private:
  const ::tensorflow::tensorforest::SplitFinishConfig& _internal_finish_type() const;
  public:
  const ::tensorflow::tensorforest::SplitFinishConfig& finish_type() const;
  ::tensorflow::tensorforest::SplitFinishConfig* release_finish_type();
  ::tensorflow::tensorforest::SplitFinishConfig* mutable_finish_type();
  void set_allocated_finish_type(::tensorflow::tensorforest::SplitFinishConfig* finish_type);

  // .tensorflow.tensorforest.DepthDependentParam num_splits_to_consider = 13;
  bool has_num_splits_to_consider() const;
  void clear_num_splits_to_consider();
  static const int kNumSplitsToConsiderFieldNumber = 13;
  private:
  const ::tensorflow::tensorforest::DepthDependentParam& _internal_num_splits_to_consider() const;
  public:
  const ::tensorflow::tensorforest::DepthDependentParam& num_splits_to_consider() const;
  ::tensorflow::tensorforest::DepthDependentParam* release_num_splits_to_consider();
  ::tensorflow::tensorforest::DepthDependentParam* mutable_num_splits_to_consider();
  void set_allocated_num_splits_to_consider(::tensorflow::tensorforest::DepthDependentParam* num_splits_to_consider);

  // .tensorflow.tensorforest.DepthDependentParam split_after_samples = 14;
  bool has_split_after_samples() const;
  void clear_split_after_samples();
  static const int kSplitAfterSamplesFieldNumber = 14;
  private:
  const ::tensorflow::tensorforest::DepthDependentParam& _internal_split_after_samples() const;
  public:
  const ::tensorflow::tensorforest::DepthDependentParam& split_after_samples() const;
  ::tensorflow::tensorforest::DepthDependentParam* release_split_after_samples();
  ::tensorflow::tensorforest::DepthDependentParam* mutable_split_after_samples();
  void set_allocated_split_after_samples(::tensorflow::tensorforest::DepthDependentParam* split_after_samples);

  // .tensorflow.tensorforest.DepthDependentParam dominate_fraction = 15;
  bool has_dominate_fraction() const;
  void clear_dominate_fraction();
  static const int kDominateFractionFieldNumber = 15;
  private:
  const ::tensorflow::tensorforest::DepthDependentParam& _internal_dominate_fraction() const;
  public:
  const ::tensorflow::tensorforest::DepthDependentParam& dominate_fraction() const;
  ::tensorflow::tensorforest::DepthDependentParam* release_dominate_fraction();
  ::tensorflow::tensorforest::DepthDependentParam* mutable_dominate_fraction();
  void set_allocated_dominate_fraction(::tensorflow::tensorforest::DepthDependentParam* dominate_fraction);

  // .tensorflow.tensorforest.DepthDependentParam min_split_samples = 18;
  bool has_min_split_samples() const;
  void clear_min_split_samples();
  static const int kMinSplitSamplesFieldNumber = 18;
  private:
  const ::tensorflow::tensorforest::DepthDependentParam& _internal_min_split_samples() const;
  public:
  const ::tensorflow::tensorforest::DepthDependentParam& min_split_samples() const;
  ::tensorflow::tensorforest::DepthDependentParam* release_min_split_samples();
  ::tensorflow::tensorforest::DepthDependentParam* mutable_min_split_samples();
  void set_allocated_min_split_samples(::tensorflow::tensorforest::DepthDependentParam* min_split_samples);

  // .tensorflow.tensorforest.LeafModelType leaf_type = 1;
  void clear_leaf_type();
  static const int kLeafTypeFieldNumber = 1;
  ::tensorflow::tensorforest::LeafModelType leaf_type() const;
  void set_leaf_type(::tensorflow::tensorforest::LeafModelType value);

  // .tensorflow.tensorforest.StatsModelType stats_type = 2;
  void clear_stats_type();
  static const int kStatsTypeFieldNumber = 2;
  ::tensorflow::tensorforest::StatsModelType stats_type() const;
  void set_stats_type(::tensorflow::tensorforest::StatsModelType value);

  // .tensorflow.tensorforest.SplitCollectionType collection_type = 3;
  void clear_collection_type();
  static const int kCollectionTypeFieldNumber = 3;
  ::tensorflow::tensorforest::SplitCollectionType collection_type() const;
  void set_collection_type(::tensorflow::tensorforest::SplitCollectionType value);

  // int32 num_trees = 6;
  void clear_num_trees();
  static const int kNumTreesFieldNumber = 6;
  ::google::protobuf::int32 num_trees() const;
  void set_num_trees(::google::protobuf::int32 value);

  // int32 max_nodes = 7;
  void clear_max_nodes();
  static const int kMaxNodesFieldNumber = 7;
  ::google::protobuf::int32 max_nodes() const;
  void set_max_nodes(::google::protobuf::int32 value);

  // bool is_regression = 8;
  void clear_is_regression();
  static const int kIsRegressionFieldNumber = 8;
  bool is_regression() const;
  void set_is_regression(bool value);

  // bool drop_final_class = 9;
  void clear_drop_final_class();
  static const int kDropFinalClassFieldNumber = 9;
  bool drop_final_class() const;
  void set_drop_final_class(bool value);

  // bool collate_examples = 10;
  void clear_collate_examples();
  static const int kCollateExamplesFieldNumber = 10;
  bool collate_examples() const;
  void set_collate_examples(bool value);

  // bool checkpoint_stats = 11;
  void clear_checkpoint_stats();
  static const int kCheckpointStatsFieldNumber = 11;
  bool checkpoint_stats() const;
  void set_checkpoint_stats(bool value);

  // int32 num_outputs = 12;
  void clear_num_outputs();
  static const int kNumOutputsFieldNumber = 12;
  ::google::protobuf::int32 num_outputs() const;
  void set_num_outputs(::google::protobuf::int32 value);

  // int32 num_select_features = 17;
  void clear_num_select_features();
  static const int kNumSelectFeaturesFieldNumber = 17;
  ::google::protobuf::int32 num_select_features() const;
  void set_num_select_features(::google::protobuf::int32 value);

  // .tensorflow.decision_trees.InequalityTest.Type inequality_test_type = 19;
  void clear_inequality_test_type();
  static const int kInequalityTestTypeFieldNumber = 19;
  ::tensorflow::decision_trees::InequalityTest_Type inequality_test_type() const;
  void set_inequality_test_type(::tensorflow::decision_trees::InequalityTest_Type value);

  // int32 num_features = 21;
  void clear_num_features();
  static const int kNumFeaturesFieldNumber = 21;
  ::google::protobuf::int32 num_features() const;
  void set_num_features(::google::protobuf::int32 value);

  // bool use_running_stats_method = 20;
  void clear_use_running_stats_method();
  static const int kUseRunningStatsMethodFieldNumber = 20;
  bool use_running_stats_method() const;
  void set_use_running_stats_method(bool value);

  // bool initialize_average_splits = 22;
  void clear_initialize_average_splits();
  static const int kInitializeAverageSplitsFieldNumber = 22;
  bool initialize_average_splits() const;
  void set_initialize_average_splits(bool value);

  // bool inference_tree_paths = 23;
  void clear_inference_tree_paths();
  static const int kInferenceTreePathsFieldNumber = 23;
  bool inference_tree_paths() const;
  void set_inference_tree_paths(bool value);

  // int32 num_classes_to_track = 24;
  void clear_num_classes_to_track();
  static const int kNumClassesToTrackFieldNumber = 24;
  ::google::protobuf::int32 num_classes_to_track() const;
  void set_num_classes_to_track(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.TensorForestParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr graph_dir_;
  ::tensorflow::tensorforest::SplitPruningConfig* pruning_type_;
  ::tensorflow::tensorforest::SplitFinishConfig* finish_type_;
  ::tensorflow::tensorforest::DepthDependentParam* num_splits_to_consider_;
  ::tensorflow::tensorforest::DepthDependentParam* split_after_samples_;
  ::tensorflow::tensorforest::DepthDependentParam* dominate_fraction_;
  ::tensorflow::tensorforest::DepthDependentParam* min_split_samples_;
  int leaf_type_;
  int stats_type_;
  int collection_type_;
  ::google::protobuf::int32 num_trees_;
  ::google::protobuf::int32 max_nodes_;
  bool is_regression_;
  bool drop_final_class_;
  bool collate_examples_;
  bool checkpoint_stats_;
  ::google::protobuf::int32 num_outputs_;
  ::google::protobuf::int32 num_select_features_;
  int inequality_test_type_;
  ::google::protobuf::int32 num_features_;
  bool use_running_stats_method_;
  bool initialize_average_splits_;
  bool inference_tree_paths_;
  ::google::protobuf::int32 num_classes_to_track_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SplitPruningConfig

// .tensorflow.tensorforest.DepthDependentParam prune_every_samples = 1;
inline bool SplitPruningConfig::has_prune_every_samples() const {
  return this != internal_default_instance() && prune_every_samples_ != NULL;
}
inline void SplitPruningConfig::clear_prune_every_samples() {
  if (GetArenaNoVirtual() == NULL && prune_every_samples_ != NULL) {
    delete prune_every_samples_;
  }
  prune_every_samples_ = NULL;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& SplitPruningConfig::_internal_prune_every_samples() const {
  return *prune_every_samples_;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& SplitPruningConfig::prune_every_samples() const {
  const ::tensorflow::tensorforest::DepthDependentParam* p = prune_every_samples_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitPruningConfig.prune_every_samples)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::DepthDependentParam*>(
      &::tensorflow::tensorforest::_DepthDependentParam_default_instance_);
}
inline ::tensorflow::tensorforest::DepthDependentParam* SplitPruningConfig::release_prune_every_samples() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitPruningConfig.prune_every_samples)
  
  ::tensorflow::tensorforest::DepthDependentParam* temp = prune_every_samples_;
  prune_every_samples_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::DepthDependentParam* SplitPruningConfig::mutable_prune_every_samples() {
  
  if (prune_every_samples_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::DepthDependentParam>(GetArenaNoVirtual());
    prune_every_samples_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitPruningConfig.prune_every_samples)
  return prune_every_samples_;
}
inline void SplitPruningConfig::set_allocated_prune_every_samples(::tensorflow::tensorforest::DepthDependentParam* prune_every_samples) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prune_every_samples_;
  }
  if (prune_every_samples) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prune_every_samples = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prune_every_samples, submessage_arena);
    }
    
  } else {
    
  }
  prune_every_samples_ = prune_every_samples;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitPruningConfig.prune_every_samples)
}

// .tensorflow.tensorforest.SplitPruningStrategyType type = 2;
inline void SplitPruningConfig::clear_type() {
  type_ = 0;
}
inline ::tensorflow::tensorforest::SplitPruningStrategyType SplitPruningConfig::type() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitPruningConfig.type)
  return static_cast< ::tensorflow::tensorforest::SplitPruningStrategyType >(type_);
}
inline void SplitPruningConfig::set_type(::tensorflow::tensorforest::SplitPruningStrategyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.SplitPruningConfig.type)
}

// -------------------------------------------------------------------

// SplitFinishConfig

// .tensorflow.tensorforest.DepthDependentParam check_every_steps = 1;
inline bool SplitFinishConfig::has_check_every_steps() const {
  return this != internal_default_instance() && check_every_steps_ != NULL;
}
inline void SplitFinishConfig::clear_check_every_steps() {
  if (GetArenaNoVirtual() == NULL && check_every_steps_ != NULL) {
    delete check_every_steps_;
  }
  check_every_steps_ = NULL;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& SplitFinishConfig::_internal_check_every_steps() const {
  return *check_every_steps_;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& SplitFinishConfig::check_every_steps() const {
  const ::tensorflow::tensorforest::DepthDependentParam* p = check_every_steps_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitFinishConfig.check_every_steps)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::DepthDependentParam*>(
      &::tensorflow::tensorforest::_DepthDependentParam_default_instance_);
}
inline ::tensorflow::tensorforest::DepthDependentParam* SplitFinishConfig::release_check_every_steps() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitFinishConfig.check_every_steps)
  
  ::tensorflow::tensorforest::DepthDependentParam* temp = check_every_steps_;
  check_every_steps_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::DepthDependentParam* SplitFinishConfig::mutable_check_every_steps() {
  
  if (check_every_steps_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::DepthDependentParam>(GetArenaNoVirtual());
    check_every_steps_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitFinishConfig.check_every_steps)
  return check_every_steps_;
}
inline void SplitFinishConfig::set_allocated_check_every_steps(::tensorflow::tensorforest::DepthDependentParam* check_every_steps) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete check_every_steps_;
  }
  if (check_every_steps) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      check_every_steps = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, check_every_steps, submessage_arena);
    }
    
  } else {
    
  }
  check_every_steps_ = check_every_steps;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitFinishConfig.check_every_steps)
}

// .tensorflow.tensorforest.SplitFinishStrategyType type = 2;
inline void SplitFinishConfig::clear_type() {
  type_ = 0;
}
inline ::tensorflow::tensorforest::SplitFinishStrategyType SplitFinishConfig::type() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitFinishConfig.type)
  return static_cast< ::tensorflow::tensorforest::SplitFinishStrategyType >(type_);
}
inline void SplitFinishConfig::set_type(::tensorflow::tensorforest::SplitFinishStrategyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.SplitFinishConfig.type)
}

// -------------------------------------------------------------------

// LinearParam

// float slope = 1;
inline void LinearParam::clear_slope() {
  slope_ = 0;
}
inline float LinearParam::slope() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LinearParam.slope)
  return slope_;
}
inline void LinearParam::set_slope(float value) {
  
  slope_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.LinearParam.slope)
}

// float y_intercept = 2;
inline void LinearParam::clear_y_intercept() {
  y_intercept_ = 0;
}
inline float LinearParam::y_intercept() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LinearParam.y_intercept)
  return y_intercept_;
}
inline void LinearParam::set_y_intercept(float value) {
  
  y_intercept_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.LinearParam.y_intercept)
}

// float min_val = 3;
inline void LinearParam::clear_min_val() {
  min_val_ = 0;
}
inline float LinearParam::min_val() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LinearParam.min_val)
  return min_val_;
}
inline void LinearParam::set_min_val(float value) {
  
  min_val_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.LinearParam.min_val)
}

// float max_val = 4;
inline void LinearParam::clear_max_val() {
  max_val_ = 0;
}
inline float LinearParam::max_val() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LinearParam.max_val)
  return max_val_;
}
inline void LinearParam::set_max_val(float value) {
  
  max_val_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.LinearParam.max_val)
}

// -------------------------------------------------------------------

// ExponentialParam

// float bias = 1;
inline void ExponentialParam::clear_bias() {
  bias_ = 0;
}
inline float ExponentialParam::bias() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.ExponentialParam.bias)
  return bias_;
}
inline void ExponentialParam::set_bias(float value) {
  
  bias_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.ExponentialParam.bias)
}

// float base = 2;
inline void ExponentialParam::clear_base() {
  base_ = 0;
}
inline float ExponentialParam::base() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.ExponentialParam.base)
  return base_;
}
inline void ExponentialParam::set_base(float value) {
  
  base_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.ExponentialParam.base)
}

// float multiplier = 3;
inline void ExponentialParam::clear_multiplier() {
  multiplier_ = 0;
}
inline float ExponentialParam::multiplier() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.ExponentialParam.multiplier)
  return multiplier_;
}
inline void ExponentialParam::set_multiplier(float value) {
  
  multiplier_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.ExponentialParam.multiplier)
}

// float depth_multiplier = 4;
inline void ExponentialParam::clear_depth_multiplier() {
  depth_multiplier_ = 0;
}
inline float ExponentialParam::depth_multiplier() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.ExponentialParam.depth_multiplier)
  return depth_multiplier_;
}
inline void ExponentialParam::set_depth_multiplier(float value) {
  
  depth_multiplier_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.ExponentialParam.depth_multiplier)
}

// -------------------------------------------------------------------

// ThresholdParam

// float on_value = 1;
inline void ThresholdParam::clear_on_value() {
  on_value_ = 0;
}
inline float ThresholdParam::on_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.ThresholdParam.on_value)
  return on_value_;
}
inline void ThresholdParam::set_on_value(float value) {
  
  on_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.ThresholdParam.on_value)
}

// float off_value = 2;
inline void ThresholdParam::clear_off_value() {
  off_value_ = 0;
}
inline float ThresholdParam::off_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.ThresholdParam.off_value)
  return off_value_;
}
inline void ThresholdParam::set_off_value(float value) {
  
  off_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.ThresholdParam.off_value)
}

// float threshold = 3;
inline void ThresholdParam::clear_threshold() {
  threshold_ = 0;
}
inline float ThresholdParam::threshold() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.ThresholdParam.threshold)
  return threshold_;
}
inline void ThresholdParam::set_threshold(float value) {
  
  threshold_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.ThresholdParam.threshold)
}

// -------------------------------------------------------------------

// DepthDependentParam

// float constant_value = 1;
inline bool DepthDependentParam::has_constant_value() const {
  return ParamType_case() == kConstantValue;
}
inline void DepthDependentParam::set_has_constant_value() {
  _oneof_case_[0] = kConstantValue;
}
inline void DepthDependentParam::clear_constant_value() {
  if (has_constant_value()) {
    ParamType_.constant_value_ = 0;
    clear_has_ParamType();
  }
}
inline float DepthDependentParam::constant_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.DepthDependentParam.constant_value)
  if (has_constant_value()) {
    return ParamType_.constant_value_;
  }
  return 0;
}
inline void DepthDependentParam::set_constant_value(float value) {
  if (!has_constant_value()) {
    clear_ParamType();
    set_has_constant_value();
  }
  ParamType_.constant_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.DepthDependentParam.constant_value)
}

// .tensorflow.tensorforest.LinearParam linear = 2;
inline bool DepthDependentParam::has_linear() const {
  return ParamType_case() == kLinear;
}
inline void DepthDependentParam::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void DepthDependentParam::clear_linear() {
  if (has_linear()) {
    delete ParamType_.linear_;
    clear_has_ParamType();
  }
}
inline const ::tensorflow::tensorforest::LinearParam& DepthDependentParam::_internal_linear() const {
  return *ParamType_.linear_;
}
inline ::tensorflow::tensorforest::LinearParam* DepthDependentParam::release_linear() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.DepthDependentParam.linear)
  if (has_linear()) {
    clear_has_ParamType();
      ::tensorflow::tensorforest::LinearParam* temp = ParamType_.linear_;
    ParamType_.linear_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::tensorforest::LinearParam& DepthDependentParam::linear() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.DepthDependentParam.linear)
  return has_linear()
      ? *ParamType_.linear_
      : *reinterpret_cast< ::tensorflow::tensorforest::LinearParam*>(&::tensorflow::tensorforest::_LinearParam_default_instance_);
}
inline ::tensorflow::tensorforest::LinearParam* DepthDependentParam::mutable_linear() {
  if (!has_linear()) {
    clear_ParamType();
    set_has_linear();
    ParamType_.linear_ = CreateMaybeMessage< ::tensorflow::tensorforest::LinearParam >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.DepthDependentParam.linear)
  return ParamType_.linear_;
}

// .tensorflow.tensorforest.ExponentialParam exponential = 3;
inline bool DepthDependentParam::has_exponential() const {
  return ParamType_case() == kExponential;
}
inline void DepthDependentParam::set_has_exponential() {
  _oneof_case_[0] = kExponential;
}
inline void DepthDependentParam::clear_exponential() {
  if (has_exponential()) {
    delete ParamType_.exponential_;
    clear_has_ParamType();
  }
}
inline const ::tensorflow::tensorforest::ExponentialParam& DepthDependentParam::_internal_exponential() const {
  return *ParamType_.exponential_;
}
inline ::tensorflow::tensorforest::ExponentialParam* DepthDependentParam::release_exponential() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.DepthDependentParam.exponential)
  if (has_exponential()) {
    clear_has_ParamType();
      ::tensorflow::tensorforest::ExponentialParam* temp = ParamType_.exponential_;
    ParamType_.exponential_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::tensorforest::ExponentialParam& DepthDependentParam::exponential() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.DepthDependentParam.exponential)
  return has_exponential()
      ? *ParamType_.exponential_
      : *reinterpret_cast< ::tensorflow::tensorforest::ExponentialParam*>(&::tensorflow::tensorforest::_ExponentialParam_default_instance_);
}
inline ::tensorflow::tensorforest::ExponentialParam* DepthDependentParam::mutable_exponential() {
  if (!has_exponential()) {
    clear_ParamType();
    set_has_exponential();
    ParamType_.exponential_ = CreateMaybeMessage< ::tensorflow::tensorforest::ExponentialParam >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.DepthDependentParam.exponential)
  return ParamType_.exponential_;
}

// .tensorflow.tensorforest.ThresholdParam threshold = 4;
inline bool DepthDependentParam::has_threshold() const {
  return ParamType_case() == kThreshold;
}
inline void DepthDependentParam::set_has_threshold() {
  _oneof_case_[0] = kThreshold;
}
inline void DepthDependentParam::clear_threshold() {
  if (has_threshold()) {
    delete ParamType_.threshold_;
    clear_has_ParamType();
  }
}
inline const ::tensorflow::tensorforest::ThresholdParam& DepthDependentParam::_internal_threshold() const {
  return *ParamType_.threshold_;
}
inline ::tensorflow::tensorforest::ThresholdParam* DepthDependentParam::release_threshold() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.DepthDependentParam.threshold)
  if (has_threshold()) {
    clear_has_ParamType();
      ::tensorflow::tensorforest::ThresholdParam* temp = ParamType_.threshold_;
    ParamType_.threshold_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::tensorforest::ThresholdParam& DepthDependentParam::threshold() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.DepthDependentParam.threshold)
  return has_threshold()
      ? *ParamType_.threshold_
      : *reinterpret_cast< ::tensorflow::tensorforest::ThresholdParam*>(&::tensorflow::tensorforest::_ThresholdParam_default_instance_);
}
inline ::tensorflow::tensorforest::ThresholdParam* DepthDependentParam::mutable_threshold() {
  if (!has_threshold()) {
    clear_ParamType();
    set_has_threshold();
    ParamType_.threshold_ = CreateMaybeMessage< ::tensorflow::tensorforest::ThresholdParam >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.DepthDependentParam.threshold)
  return ParamType_.threshold_;
}

inline bool DepthDependentParam::has_ParamType() const {
  return ParamType_case() != PARAMTYPE_NOT_SET;
}
inline void DepthDependentParam::clear_has_ParamType() {
  _oneof_case_[0] = PARAMTYPE_NOT_SET;
}
inline DepthDependentParam::ParamTypeCase DepthDependentParam::ParamType_case() const {
  return DepthDependentParam::ParamTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TensorForestParams

// .tensorflow.tensorforest.LeafModelType leaf_type = 1;
inline void TensorForestParams::clear_leaf_type() {
  leaf_type_ = 0;
}
inline ::tensorflow::tensorforest::LeafModelType TensorForestParams::leaf_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.leaf_type)
  return static_cast< ::tensorflow::tensorforest::LeafModelType >(leaf_type_);
}
inline void TensorForestParams::set_leaf_type(::tensorflow::tensorforest::LeafModelType value) {
  
  leaf_type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.leaf_type)
}

// .tensorflow.tensorforest.StatsModelType stats_type = 2;
inline void TensorForestParams::clear_stats_type() {
  stats_type_ = 0;
}
inline ::tensorflow::tensorforest::StatsModelType TensorForestParams::stats_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.stats_type)
  return static_cast< ::tensorflow::tensorforest::StatsModelType >(stats_type_);
}
inline void TensorForestParams::set_stats_type(::tensorflow::tensorforest::StatsModelType value) {
  
  stats_type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.stats_type)
}

// .tensorflow.tensorforest.SplitCollectionType collection_type = 3;
inline void TensorForestParams::clear_collection_type() {
  collection_type_ = 0;
}
inline ::tensorflow::tensorforest::SplitCollectionType TensorForestParams::collection_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.collection_type)
  return static_cast< ::tensorflow::tensorforest::SplitCollectionType >(collection_type_);
}
inline void TensorForestParams::set_collection_type(::tensorflow::tensorforest::SplitCollectionType value) {
  
  collection_type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.collection_type)
}

// .tensorflow.tensorforest.SplitPruningConfig pruning_type = 4;
inline bool TensorForestParams::has_pruning_type() const {
  return this != internal_default_instance() && pruning_type_ != NULL;
}
inline void TensorForestParams::clear_pruning_type() {
  if (GetArenaNoVirtual() == NULL && pruning_type_ != NULL) {
    delete pruning_type_;
  }
  pruning_type_ = NULL;
}
inline const ::tensorflow::tensorforest::SplitPruningConfig& TensorForestParams::_internal_pruning_type() const {
  return *pruning_type_;
}
inline const ::tensorflow::tensorforest::SplitPruningConfig& TensorForestParams::pruning_type() const {
  const ::tensorflow::tensorforest::SplitPruningConfig* p = pruning_type_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.pruning_type)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::SplitPruningConfig*>(
      &::tensorflow::tensorforest::_SplitPruningConfig_default_instance_);
}
inline ::tensorflow::tensorforest::SplitPruningConfig* TensorForestParams::release_pruning_type() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.TensorForestParams.pruning_type)
  
  ::tensorflow::tensorforest::SplitPruningConfig* temp = pruning_type_;
  pruning_type_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::SplitPruningConfig* TensorForestParams::mutable_pruning_type() {
  
  if (pruning_type_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::SplitPruningConfig>(GetArenaNoVirtual());
    pruning_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TensorForestParams.pruning_type)
  return pruning_type_;
}
inline void TensorForestParams::set_allocated_pruning_type(::tensorflow::tensorforest::SplitPruningConfig* pruning_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pruning_type_;
  }
  if (pruning_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pruning_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pruning_type, submessage_arena);
    }
    
  } else {
    
  }
  pruning_type_ = pruning_type;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.TensorForestParams.pruning_type)
}

// .tensorflow.tensorforest.SplitFinishConfig finish_type = 5;
inline bool TensorForestParams::has_finish_type() const {
  return this != internal_default_instance() && finish_type_ != NULL;
}
inline void TensorForestParams::clear_finish_type() {
  if (GetArenaNoVirtual() == NULL && finish_type_ != NULL) {
    delete finish_type_;
  }
  finish_type_ = NULL;
}
inline const ::tensorflow::tensorforest::SplitFinishConfig& TensorForestParams::_internal_finish_type() const {
  return *finish_type_;
}
inline const ::tensorflow::tensorforest::SplitFinishConfig& TensorForestParams::finish_type() const {
  const ::tensorflow::tensorforest::SplitFinishConfig* p = finish_type_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.finish_type)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::SplitFinishConfig*>(
      &::tensorflow::tensorforest::_SplitFinishConfig_default_instance_);
}
inline ::tensorflow::tensorforest::SplitFinishConfig* TensorForestParams::release_finish_type() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.TensorForestParams.finish_type)
  
  ::tensorflow::tensorforest::SplitFinishConfig* temp = finish_type_;
  finish_type_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::SplitFinishConfig* TensorForestParams::mutable_finish_type() {
  
  if (finish_type_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::SplitFinishConfig>(GetArenaNoVirtual());
    finish_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TensorForestParams.finish_type)
  return finish_type_;
}
inline void TensorForestParams::set_allocated_finish_type(::tensorflow::tensorforest::SplitFinishConfig* finish_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete finish_type_;
  }
  if (finish_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      finish_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, finish_type, submessage_arena);
    }
    
  } else {
    
  }
  finish_type_ = finish_type;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.TensorForestParams.finish_type)
}

// int32 num_trees = 6;
inline void TensorForestParams::clear_num_trees() {
  num_trees_ = 0;
}
inline ::google::protobuf::int32 TensorForestParams::num_trees() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.num_trees)
  return num_trees_;
}
inline void TensorForestParams::set_num_trees(::google::protobuf::int32 value) {
  
  num_trees_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.num_trees)
}

// int32 max_nodes = 7;
inline void TensorForestParams::clear_max_nodes() {
  max_nodes_ = 0;
}
inline ::google::protobuf::int32 TensorForestParams::max_nodes() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.max_nodes)
  return max_nodes_;
}
inline void TensorForestParams::set_max_nodes(::google::protobuf::int32 value) {
  
  max_nodes_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.max_nodes)
}

// int32 num_features = 21;
inline void TensorForestParams::clear_num_features() {
  num_features_ = 0;
}
inline ::google::protobuf::int32 TensorForestParams::num_features() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.num_features)
  return num_features_;
}
inline void TensorForestParams::set_num_features(::google::protobuf::int32 value) {
  
  num_features_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.num_features)
}

// .tensorflow.decision_trees.InequalityTest.Type inequality_test_type = 19;
inline void TensorForestParams::clear_inequality_test_type() {
  inequality_test_type_ = 0;
}
inline ::tensorflow::decision_trees::InequalityTest_Type TensorForestParams::inequality_test_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.inequality_test_type)
  return static_cast< ::tensorflow::decision_trees::InequalityTest_Type >(inequality_test_type_);
}
inline void TensorForestParams::set_inequality_test_type(::tensorflow::decision_trees::InequalityTest_Type value) {
  
  inequality_test_type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.inequality_test_type)
}

// bool is_regression = 8;
inline void TensorForestParams::clear_is_regression() {
  is_regression_ = false;
}
inline bool TensorForestParams::is_regression() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.is_regression)
  return is_regression_;
}
inline void TensorForestParams::set_is_regression(bool value) {
  
  is_regression_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.is_regression)
}

// bool drop_final_class = 9;
inline void TensorForestParams::clear_drop_final_class() {
  drop_final_class_ = false;
}
inline bool TensorForestParams::drop_final_class() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.drop_final_class)
  return drop_final_class_;
}
inline void TensorForestParams::set_drop_final_class(bool value) {
  
  drop_final_class_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.drop_final_class)
}

// bool collate_examples = 10;
inline void TensorForestParams::clear_collate_examples() {
  collate_examples_ = false;
}
inline bool TensorForestParams::collate_examples() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.collate_examples)
  return collate_examples_;
}
inline void TensorForestParams::set_collate_examples(bool value) {
  
  collate_examples_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.collate_examples)
}

// bool checkpoint_stats = 11;
inline void TensorForestParams::clear_checkpoint_stats() {
  checkpoint_stats_ = false;
}
inline bool TensorForestParams::checkpoint_stats() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.checkpoint_stats)
  return checkpoint_stats_;
}
inline void TensorForestParams::set_checkpoint_stats(bool value) {
  
  checkpoint_stats_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.checkpoint_stats)
}

// bool use_running_stats_method = 20;
inline void TensorForestParams::clear_use_running_stats_method() {
  use_running_stats_method_ = false;
}
inline bool TensorForestParams::use_running_stats_method() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.use_running_stats_method)
  return use_running_stats_method_;
}
inline void TensorForestParams::set_use_running_stats_method(bool value) {
  
  use_running_stats_method_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.use_running_stats_method)
}

// bool initialize_average_splits = 22;
inline void TensorForestParams::clear_initialize_average_splits() {
  initialize_average_splits_ = false;
}
inline bool TensorForestParams::initialize_average_splits() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.initialize_average_splits)
  return initialize_average_splits_;
}
inline void TensorForestParams::set_initialize_average_splits(bool value) {
  
  initialize_average_splits_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.initialize_average_splits)
}

// bool inference_tree_paths = 23;
inline void TensorForestParams::clear_inference_tree_paths() {
  inference_tree_paths_ = false;
}
inline bool TensorForestParams::inference_tree_paths() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.inference_tree_paths)
  return inference_tree_paths_;
}
inline void TensorForestParams::set_inference_tree_paths(bool value) {
  
  inference_tree_paths_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.inference_tree_paths)
}

// int32 num_outputs = 12;
inline void TensorForestParams::clear_num_outputs() {
  num_outputs_ = 0;
}
inline ::google::protobuf::int32 TensorForestParams::num_outputs() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.num_outputs)
  return num_outputs_;
}
inline void TensorForestParams::set_num_outputs(::google::protobuf::int32 value) {
  
  num_outputs_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.num_outputs)
}

// .tensorflow.tensorforest.DepthDependentParam num_splits_to_consider = 13;
inline bool TensorForestParams::has_num_splits_to_consider() const {
  return this != internal_default_instance() && num_splits_to_consider_ != NULL;
}
inline void TensorForestParams::clear_num_splits_to_consider() {
  if (GetArenaNoVirtual() == NULL && num_splits_to_consider_ != NULL) {
    delete num_splits_to_consider_;
  }
  num_splits_to_consider_ = NULL;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& TensorForestParams::_internal_num_splits_to_consider() const {
  return *num_splits_to_consider_;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& TensorForestParams::num_splits_to_consider() const {
  const ::tensorflow::tensorforest::DepthDependentParam* p = num_splits_to_consider_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.num_splits_to_consider)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::DepthDependentParam*>(
      &::tensorflow::tensorforest::_DepthDependentParam_default_instance_);
}
inline ::tensorflow::tensorforest::DepthDependentParam* TensorForestParams::release_num_splits_to_consider() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.TensorForestParams.num_splits_to_consider)
  
  ::tensorflow::tensorforest::DepthDependentParam* temp = num_splits_to_consider_;
  num_splits_to_consider_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::DepthDependentParam* TensorForestParams::mutable_num_splits_to_consider() {
  
  if (num_splits_to_consider_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::DepthDependentParam>(GetArenaNoVirtual());
    num_splits_to_consider_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TensorForestParams.num_splits_to_consider)
  return num_splits_to_consider_;
}
inline void TensorForestParams::set_allocated_num_splits_to_consider(::tensorflow::tensorforest::DepthDependentParam* num_splits_to_consider) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete num_splits_to_consider_;
  }
  if (num_splits_to_consider) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      num_splits_to_consider = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, num_splits_to_consider, submessage_arena);
    }
    
  } else {
    
  }
  num_splits_to_consider_ = num_splits_to_consider;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.TensorForestParams.num_splits_to_consider)
}

// .tensorflow.tensorforest.DepthDependentParam split_after_samples = 14;
inline bool TensorForestParams::has_split_after_samples() const {
  return this != internal_default_instance() && split_after_samples_ != NULL;
}
inline void TensorForestParams::clear_split_after_samples() {
  if (GetArenaNoVirtual() == NULL && split_after_samples_ != NULL) {
    delete split_after_samples_;
  }
  split_after_samples_ = NULL;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& TensorForestParams::_internal_split_after_samples() const {
  return *split_after_samples_;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& TensorForestParams::split_after_samples() const {
  const ::tensorflow::tensorforest::DepthDependentParam* p = split_after_samples_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.split_after_samples)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::DepthDependentParam*>(
      &::tensorflow::tensorforest::_DepthDependentParam_default_instance_);
}
inline ::tensorflow::tensorforest::DepthDependentParam* TensorForestParams::release_split_after_samples() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.TensorForestParams.split_after_samples)
  
  ::tensorflow::tensorforest::DepthDependentParam* temp = split_after_samples_;
  split_after_samples_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::DepthDependentParam* TensorForestParams::mutable_split_after_samples() {
  
  if (split_after_samples_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::DepthDependentParam>(GetArenaNoVirtual());
    split_after_samples_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TensorForestParams.split_after_samples)
  return split_after_samples_;
}
inline void TensorForestParams::set_allocated_split_after_samples(::tensorflow::tensorforest::DepthDependentParam* split_after_samples) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete split_after_samples_;
  }
  if (split_after_samples) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      split_after_samples = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, split_after_samples, submessage_arena);
    }
    
  } else {
    
  }
  split_after_samples_ = split_after_samples;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.TensorForestParams.split_after_samples)
}

// .tensorflow.tensorforest.DepthDependentParam dominate_fraction = 15;
inline bool TensorForestParams::has_dominate_fraction() const {
  return this != internal_default_instance() && dominate_fraction_ != NULL;
}
inline void TensorForestParams::clear_dominate_fraction() {
  if (GetArenaNoVirtual() == NULL && dominate_fraction_ != NULL) {
    delete dominate_fraction_;
  }
  dominate_fraction_ = NULL;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& TensorForestParams::_internal_dominate_fraction() const {
  return *dominate_fraction_;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& TensorForestParams::dominate_fraction() const {
  const ::tensorflow::tensorforest::DepthDependentParam* p = dominate_fraction_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.dominate_fraction)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::DepthDependentParam*>(
      &::tensorflow::tensorforest::_DepthDependentParam_default_instance_);
}
inline ::tensorflow::tensorforest::DepthDependentParam* TensorForestParams::release_dominate_fraction() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.TensorForestParams.dominate_fraction)
  
  ::tensorflow::tensorforest::DepthDependentParam* temp = dominate_fraction_;
  dominate_fraction_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::DepthDependentParam* TensorForestParams::mutable_dominate_fraction() {
  
  if (dominate_fraction_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::DepthDependentParam>(GetArenaNoVirtual());
    dominate_fraction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TensorForestParams.dominate_fraction)
  return dominate_fraction_;
}
inline void TensorForestParams::set_allocated_dominate_fraction(::tensorflow::tensorforest::DepthDependentParam* dominate_fraction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dominate_fraction_;
  }
  if (dominate_fraction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dominate_fraction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dominate_fraction, submessage_arena);
    }
    
  } else {
    
  }
  dominate_fraction_ = dominate_fraction;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.TensorForestParams.dominate_fraction)
}

// .tensorflow.tensorforest.DepthDependentParam min_split_samples = 18;
inline bool TensorForestParams::has_min_split_samples() const {
  return this != internal_default_instance() && min_split_samples_ != NULL;
}
inline void TensorForestParams::clear_min_split_samples() {
  if (GetArenaNoVirtual() == NULL && min_split_samples_ != NULL) {
    delete min_split_samples_;
  }
  min_split_samples_ = NULL;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& TensorForestParams::_internal_min_split_samples() const {
  return *min_split_samples_;
}
inline const ::tensorflow::tensorforest::DepthDependentParam& TensorForestParams::min_split_samples() const {
  const ::tensorflow::tensorforest::DepthDependentParam* p = min_split_samples_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.min_split_samples)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::DepthDependentParam*>(
      &::tensorflow::tensorforest::_DepthDependentParam_default_instance_);
}
inline ::tensorflow::tensorforest::DepthDependentParam* TensorForestParams::release_min_split_samples() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.TensorForestParams.min_split_samples)
  
  ::tensorflow::tensorforest::DepthDependentParam* temp = min_split_samples_;
  min_split_samples_ = NULL;
  return temp;
}
inline ::tensorflow::tensorforest::DepthDependentParam* TensorForestParams::mutable_min_split_samples() {
  
  if (min_split_samples_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::DepthDependentParam>(GetArenaNoVirtual());
    min_split_samples_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TensorForestParams.min_split_samples)
  return min_split_samples_;
}
inline void TensorForestParams::set_allocated_min_split_samples(::tensorflow::tensorforest::DepthDependentParam* min_split_samples) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete min_split_samples_;
  }
  if (min_split_samples) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      min_split_samples = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_split_samples, submessage_arena);
    }
    
  } else {
    
  }
  min_split_samples_ = min_split_samples;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.TensorForestParams.min_split_samples)
}

// string graph_dir = 16;
inline void TensorForestParams::clear_graph_dir() {
  graph_dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorForestParams::graph_dir() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.graph_dir)
  return graph_dir_.GetNoArena();
}
inline void TensorForestParams::set_graph_dir(const ::std::string& value) {
  
  graph_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.graph_dir)
}
#if LANG_CXX11
inline void TensorForestParams::set_graph_dir(::std::string&& value) {
  
  graph_dir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.tensorforest.TensorForestParams.graph_dir)
}
#endif
inline void TensorForestParams::set_graph_dir(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  graph_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.tensorforest.TensorForestParams.graph_dir)
}
inline void TensorForestParams::set_graph_dir(const char* value, size_t size) {
  
  graph_dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.tensorforest.TensorForestParams.graph_dir)
}
inline ::std::string* TensorForestParams::mutable_graph_dir() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TensorForestParams.graph_dir)
  return graph_dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorForestParams::release_graph_dir() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.TensorForestParams.graph_dir)
  
  return graph_dir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorForestParams::set_allocated_graph_dir(::std::string* graph_dir) {
  if (graph_dir != NULL) {
    
  } else {
    
  }
  graph_dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), graph_dir);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.TensorForestParams.graph_dir)
}

// int32 num_select_features = 17;
inline void TensorForestParams::clear_num_select_features() {
  num_select_features_ = 0;
}
inline ::google::protobuf::int32 TensorForestParams::num_select_features() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.num_select_features)
  return num_select_features_;
}
inline void TensorForestParams::set_num_select_features(::google::protobuf::int32 value) {
  
  num_select_features_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.num_select_features)
}

// int32 num_classes_to_track = 24;
inline void TensorForestParams::clear_num_classes_to_track() {
  num_classes_to_track_ = 0;
}
inline ::google::protobuf::int32 TensorForestParams::num_classes_to_track() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TensorForestParams.num_classes_to_track)
  return num_classes_to_track_;
}
inline void TensorForestParams::set_num_classes_to_track(::google::protobuf::int32 value) {
  
  num_classes_to_track_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.TensorForestParams.num_classes_to_track)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorforest
}  // namespace tensorflow

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tensorflow::tensorforest::LeafModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::tensorforest::LeafModelType>() {
  return ::tensorflow::tensorforest::LeafModelType_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::tensorforest::StatsModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::tensorforest::StatsModelType>() {
  return ::tensorflow::tensorforest::StatsModelType_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::tensorforest::SplitCollectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::tensorforest::SplitCollectionType>() {
  return ::tensorflow::tensorforest::SplitCollectionType_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::tensorforest::SplitPruningStrategyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::tensorforest::SplitPruningStrategyType>() {
  return ::tensorflow::tensorforest::SplitPruningStrategyType_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::tensorforest::SplitFinishStrategyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::tensorforest::SplitFinishStrategyType>() {
  return ::tensorflow::tensorforest::SplitFinishStrategyType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcontrib_2ftensor_5fforest_2fproto_2ftensor_5fforest_5fparams_2eproto
