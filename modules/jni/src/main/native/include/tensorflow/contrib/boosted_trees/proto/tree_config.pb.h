// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/contrib/boosted_trees/proto/tree_config.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto 

namespace protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto
namespace tensorflow {
namespace boosted_trees {
namespace trees {
class CategoricalIdBinarySplit;
class CategoricalIdBinarySplitDefaultTypeInternal;
extern CategoricalIdBinarySplitDefaultTypeInternal _CategoricalIdBinarySplit_default_instance_;
class CategoricalIdSetMembershipBinarySplit;
class CategoricalIdSetMembershipBinarySplitDefaultTypeInternal;
extern CategoricalIdSetMembershipBinarySplitDefaultTypeInternal _CategoricalIdSetMembershipBinarySplit_default_instance_;
class DecisionTreeConfig;
class DecisionTreeConfigDefaultTypeInternal;
extern DecisionTreeConfigDefaultTypeInternal _DecisionTreeConfig_default_instance_;
class DecisionTreeEnsembleConfig;
class DecisionTreeEnsembleConfigDefaultTypeInternal;
extern DecisionTreeEnsembleConfigDefaultTypeInternal _DecisionTreeEnsembleConfig_default_instance_;
class DecisionTreeMetadata;
class DecisionTreeMetadataDefaultTypeInternal;
extern DecisionTreeMetadataDefaultTypeInternal _DecisionTreeMetadata_default_instance_;
class DenseFloatBinarySplit;
class DenseFloatBinarySplitDefaultTypeInternal;
extern DenseFloatBinarySplitDefaultTypeInternal _DenseFloatBinarySplit_default_instance_;
class GrowingMetadata;
class GrowingMetadataDefaultTypeInternal;
extern GrowingMetadataDefaultTypeInternal _GrowingMetadata_default_instance_;
class Leaf;
class LeafDefaultTypeInternal;
extern LeafDefaultTypeInternal _Leaf_default_instance_;
class ObliviousCategoricalIdBinarySplit;
class ObliviousCategoricalIdBinarySplitDefaultTypeInternal;
extern ObliviousCategoricalIdBinarySplitDefaultTypeInternal _ObliviousCategoricalIdBinarySplit_default_instance_;
class ObliviousDenseFloatBinarySplit;
class ObliviousDenseFloatBinarySplitDefaultTypeInternal;
extern ObliviousDenseFloatBinarySplitDefaultTypeInternal _ObliviousDenseFloatBinarySplit_default_instance_;
class SparseFloatBinarySplitDefaultLeft;
class SparseFloatBinarySplitDefaultLeftDefaultTypeInternal;
extern SparseFloatBinarySplitDefaultLeftDefaultTypeInternal _SparseFloatBinarySplitDefaultLeft_default_instance_;
class SparseFloatBinarySplitDefaultRight;
class SparseFloatBinarySplitDefaultRightDefaultTypeInternal;
extern SparseFloatBinarySplitDefaultRightDefaultTypeInternal _SparseFloatBinarySplitDefaultRight_default_instance_;
class SparseVector;
class SparseVectorDefaultTypeInternal;
extern SparseVectorDefaultTypeInternal _SparseVector_default_instance_;
class TreeNode;
class TreeNodeDefaultTypeInternal;
extern TreeNodeDefaultTypeInternal _TreeNode_default_instance_;
class TreeNodeMetadata;
class TreeNodeMetadataDefaultTypeInternal;
extern TreeNodeMetadataDefaultTypeInternal _TreeNodeMetadata_default_instance_;
class Vector;
class VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
}  // namespace trees
}  // namespace boosted_trees
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit>(Arena*);
template<> ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit>(Arena*);
template<> ::tensorflow::boosted_trees::trees::DecisionTreeConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::DecisionTreeConfig>(Arena*);
template<> ::tensorflow::boosted_trees::trees::DecisionTreeEnsembleConfig* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::DecisionTreeEnsembleConfig>(Arena*);
template<> ::tensorflow::boosted_trees::trees::DecisionTreeMetadata* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::DecisionTreeMetadata>(Arena*);
template<> ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::DenseFloatBinarySplit>(Arena*);
template<> ::tensorflow::boosted_trees::trees::GrowingMetadata* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::GrowingMetadata>(Arena*);
template<> ::tensorflow::boosted_trees::trees::Leaf* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::Leaf>(Arena*);
template<> ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit>(Arena*);
template<> ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit>(Arena*);
template<> ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft>(Arena*);
template<> ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight>(Arena*);
template<> ::tensorflow::boosted_trees::trees::SparseVector* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::SparseVector>(Arena*);
template<> ::tensorflow::boosted_trees::trees::TreeNode* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::TreeNode>(Arena*);
template<> ::tensorflow::boosted_trees::trees::TreeNodeMetadata* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::TreeNodeMetadata>(Arena*);
template<> ::tensorflow::boosted_trees::trees::Vector* Arena::CreateMaybeMessage<::tensorflow::boosted_trees::trees::Vector>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace boosted_trees {
namespace trees {

// ===================================================================

class TreeNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.TreeNode) */ {
 public:
  TreeNode();
  virtual ~TreeNode();

  TreeNode(const TreeNode& from);

  inline TreeNode& operator=(const TreeNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TreeNode(TreeNode&& from) noexcept
    : TreeNode() {
    *this = ::std::move(from);
  }

  inline TreeNode& operator=(TreeNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeNode& default_instance();

  enum NodeCase {
    kLeaf = 1,
    kDenseFloatBinarySplit = 2,
    kSparseFloatBinarySplitDefaultLeft = 3,
    kSparseFloatBinarySplitDefaultRight = 4,
    kCategoricalIdBinarySplit = 5,
    kCategoricalIdSetMembershipBinarySplit = 6,
    kObliviousDenseFloatBinarySplit = 7,
    kObliviousCategoricalIdBinarySplit = 8,
    NODE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeNode* internal_default_instance() {
    return reinterpret_cast<const TreeNode*>(
               &_TreeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(TreeNode* other);
  void Swap(TreeNode* other);
  friend void swap(TreeNode& a, TreeNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TreeNode* New() const final {
    return CreateMaybeMessage<TreeNode>(NULL);
  }

  TreeNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TreeNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TreeNode& from);
  void MergeFrom(const TreeNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeNode* other);
  protected:
  explicit TreeNode(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.boosted_trees.trees.TreeNodeMetadata node_metadata = 777;
  bool has_node_metadata() const;
  void clear_node_metadata();
  static const int kNodeMetadataFieldNumber = 777;
  private:
  const ::tensorflow::boosted_trees::trees::TreeNodeMetadata& _internal_node_metadata() const;
  public:
  const ::tensorflow::boosted_trees::trees::TreeNodeMetadata& node_metadata() const;
  ::tensorflow::boosted_trees::trees::TreeNodeMetadata* release_node_metadata();
  ::tensorflow::boosted_trees::trees::TreeNodeMetadata* mutable_node_metadata();
  void set_allocated_node_metadata(::tensorflow::boosted_trees::trees::TreeNodeMetadata* node_metadata);
  void unsafe_arena_set_allocated_node_metadata(
      ::tensorflow::boosted_trees::trees::TreeNodeMetadata* node_metadata);
  ::tensorflow::boosted_trees::trees::TreeNodeMetadata* unsafe_arena_release_node_metadata();

  // .tensorflow.boosted_trees.trees.Leaf leaf = 1;
  bool has_leaf() const;
  void clear_leaf();
  static const int kLeafFieldNumber = 1;
  private:
  const ::tensorflow::boosted_trees::trees::Leaf& _internal_leaf() const;
  public:
  const ::tensorflow::boosted_trees::trees::Leaf& leaf() const;
  ::tensorflow::boosted_trees::trees::Leaf* release_leaf();
  ::tensorflow::boosted_trees::trees::Leaf* mutable_leaf();
  void set_allocated_leaf(::tensorflow::boosted_trees::trees::Leaf* leaf);
  void unsafe_arena_set_allocated_leaf(
      ::tensorflow::boosted_trees::trees::Leaf* leaf);
  ::tensorflow::boosted_trees::trees::Leaf* unsafe_arena_release_leaf();

  // .tensorflow.boosted_trees.trees.DenseFloatBinarySplit dense_float_binary_split = 2;
  bool has_dense_float_binary_split() const;
  void clear_dense_float_binary_split();
  static const int kDenseFloatBinarySplitFieldNumber = 2;
  private:
  const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& _internal_dense_float_binary_split() const;
  public:
  const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& dense_float_binary_split() const;
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* release_dense_float_binary_split();
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* mutable_dense_float_binary_split();
  void set_allocated_dense_float_binary_split(::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* dense_float_binary_split);
  void unsafe_arena_set_allocated_dense_float_binary_split(
      ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* dense_float_binary_split);
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* unsafe_arena_release_dense_float_binary_split();

  // .tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft sparse_float_binary_split_default_left = 3;
  bool has_sparse_float_binary_split_default_left() const;
  void clear_sparse_float_binary_split_default_left();
  static const int kSparseFloatBinarySplitDefaultLeftFieldNumber = 3;
  private:
  const ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft& _internal_sparse_float_binary_split_default_left() const;
  public:
  const ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft& sparse_float_binary_split_default_left() const;
  ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* release_sparse_float_binary_split_default_left();
  ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* mutable_sparse_float_binary_split_default_left();
  void set_allocated_sparse_float_binary_split_default_left(::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* sparse_float_binary_split_default_left);
  void unsafe_arena_set_allocated_sparse_float_binary_split_default_left(
      ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* sparse_float_binary_split_default_left);
  ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* unsafe_arena_release_sparse_float_binary_split_default_left();

  // .tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight sparse_float_binary_split_default_right = 4;
  bool has_sparse_float_binary_split_default_right() const;
  void clear_sparse_float_binary_split_default_right();
  static const int kSparseFloatBinarySplitDefaultRightFieldNumber = 4;
  private:
  const ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight& _internal_sparse_float_binary_split_default_right() const;
  public:
  const ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight& sparse_float_binary_split_default_right() const;
  ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* release_sparse_float_binary_split_default_right();
  ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* mutable_sparse_float_binary_split_default_right();
  void set_allocated_sparse_float_binary_split_default_right(::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* sparse_float_binary_split_default_right);
  void unsafe_arena_set_allocated_sparse_float_binary_split_default_right(
      ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* sparse_float_binary_split_default_right);
  ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* unsafe_arena_release_sparse_float_binary_split_default_right();

  // .tensorflow.boosted_trees.trees.CategoricalIdBinarySplit categorical_id_binary_split = 5;
  bool has_categorical_id_binary_split() const;
  void clear_categorical_id_binary_split();
  static const int kCategoricalIdBinarySplitFieldNumber = 5;
  private:
  const ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit& _internal_categorical_id_binary_split() const;
  public:
  const ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit& categorical_id_binary_split() const;
  ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* release_categorical_id_binary_split();
  ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* mutable_categorical_id_binary_split();
  void set_allocated_categorical_id_binary_split(::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* categorical_id_binary_split);
  void unsafe_arena_set_allocated_categorical_id_binary_split(
      ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* categorical_id_binary_split);
  ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* unsafe_arena_release_categorical_id_binary_split();

  // .tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit categorical_id_set_membership_binary_split = 6;
  bool has_categorical_id_set_membership_binary_split() const;
  void clear_categorical_id_set_membership_binary_split();
  static const int kCategoricalIdSetMembershipBinarySplitFieldNumber = 6;
  private:
  const ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit& _internal_categorical_id_set_membership_binary_split() const;
  public:
  const ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit& categorical_id_set_membership_binary_split() const;
  ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* release_categorical_id_set_membership_binary_split();
  ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* mutable_categorical_id_set_membership_binary_split();
  void set_allocated_categorical_id_set_membership_binary_split(::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* categorical_id_set_membership_binary_split);
  void unsafe_arena_set_allocated_categorical_id_set_membership_binary_split(
      ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* categorical_id_set_membership_binary_split);
  ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* unsafe_arena_release_categorical_id_set_membership_binary_split();

  // .tensorflow.boosted_trees.trees.ObliviousDenseFloatBinarySplit oblivious_dense_float_binary_split = 7;
  bool has_oblivious_dense_float_binary_split() const;
  void clear_oblivious_dense_float_binary_split();
  static const int kObliviousDenseFloatBinarySplitFieldNumber = 7;
  private:
  const ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit& _internal_oblivious_dense_float_binary_split() const;
  public:
  const ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit& oblivious_dense_float_binary_split() const;
  ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* release_oblivious_dense_float_binary_split();
  ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* mutable_oblivious_dense_float_binary_split();
  void set_allocated_oblivious_dense_float_binary_split(::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* oblivious_dense_float_binary_split);
  void unsafe_arena_set_allocated_oblivious_dense_float_binary_split(
      ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* oblivious_dense_float_binary_split);
  ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* unsafe_arena_release_oblivious_dense_float_binary_split();

  // .tensorflow.boosted_trees.trees.ObliviousCategoricalIdBinarySplit oblivious_categorical_id_binary_split = 8;
  bool has_oblivious_categorical_id_binary_split() const;
  void clear_oblivious_categorical_id_binary_split();
  static const int kObliviousCategoricalIdBinarySplitFieldNumber = 8;
  private:
  const ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit& _internal_oblivious_categorical_id_binary_split() const;
  public:
  const ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit& oblivious_categorical_id_binary_split() const;
  ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* release_oblivious_categorical_id_binary_split();
  ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* mutable_oblivious_categorical_id_binary_split();
  void set_allocated_oblivious_categorical_id_binary_split(::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* oblivious_categorical_id_binary_split);
  void unsafe_arena_set_allocated_oblivious_categorical_id_binary_split(
      ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* oblivious_categorical_id_binary_split);
  ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* unsafe_arena_release_oblivious_categorical_id_binary_split();

  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.TreeNode)
 private:
  void set_has_leaf();
  void set_has_dense_float_binary_split();
  void set_has_sparse_float_binary_split_default_left();
  void set_has_sparse_float_binary_split_default_right();
  void set_has_categorical_id_binary_split();
  void set_has_categorical_id_set_membership_binary_split();
  void set_has_oblivious_dense_float_binary_split();
  void set_has_oblivious_categorical_id_binary_split();

  inline bool has_node() const;
  inline void clear_has_node();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::boosted_trees::trees::TreeNodeMetadata* node_metadata_;
  union NodeUnion {
    NodeUnion() {}
    ::tensorflow::boosted_trees::trees::Leaf* leaf_;
    ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* dense_float_binary_split_;
    ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* sparse_float_binary_split_default_left_;
    ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* sparse_float_binary_split_default_right_;
    ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* categorical_id_binary_split_;
    ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* categorical_id_set_membership_binary_split_;
    ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* oblivious_dense_float_binary_split_;
    ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* oblivious_categorical_id_binary_split_;
  } node_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TreeNodeMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.TreeNodeMetadata) */ {
 public:
  TreeNodeMetadata();
  virtual ~TreeNodeMetadata();

  TreeNodeMetadata(const TreeNodeMetadata& from);

  inline TreeNodeMetadata& operator=(const TreeNodeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TreeNodeMetadata(TreeNodeMetadata&& from) noexcept
    : TreeNodeMetadata() {
    *this = ::std::move(from);
  }

  inline TreeNodeMetadata& operator=(TreeNodeMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeNodeMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeNodeMetadata* internal_default_instance() {
    return reinterpret_cast<const TreeNodeMetadata*>(
               &_TreeNodeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(TreeNodeMetadata* other);
  void Swap(TreeNodeMetadata* other);
  friend void swap(TreeNodeMetadata& a, TreeNodeMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TreeNodeMetadata* New() const final {
    return CreateMaybeMessage<TreeNodeMetadata>(NULL);
  }

  TreeNodeMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TreeNodeMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TreeNodeMetadata& from);
  void MergeFrom(const TreeNodeMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeNodeMetadata* other);
  protected:
  explicit TreeNodeMetadata(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.boosted_trees.trees.Leaf original_oblivious_leaves = 3;
  int original_oblivious_leaves_size() const;
  void clear_original_oblivious_leaves();
  static const int kOriginalObliviousLeavesFieldNumber = 3;
  ::tensorflow::boosted_trees::trees::Leaf* mutable_original_oblivious_leaves(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::Leaf >*
      mutable_original_oblivious_leaves();
  const ::tensorflow::boosted_trees::trees::Leaf& original_oblivious_leaves(int index) const;
  ::tensorflow::boosted_trees::trees::Leaf* add_original_oblivious_leaves();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::Leaf >&
      original_oblivious_leaves() const;

  // .tensorflow.boosted_trees.trees.Leaf original_leaf = 2;
  bool has_original_leaf() const;
  void clear_original_leaf();
  static const int kOriginalLeafFieldNumber = 2;
  private:
  const ::tensorflow::boosted_trees::trees::Leaf& _internal_original_leaf() const;
  public:
  const ::tensorflow::boosted_trees::trees::Leaf& original_leaf() const;
  ::tensorflow::boosted_trees::trees::Leaf* release_original_leaf();
  ::tensorflow::boosted_trees::trees::Leaf* mutable_original_leaf();
  void set_allocated_original_leaf(::tensorflow::boosted_trees::trees::Leaf* original_leaf);
  void unsafe_arena_set_allocated_original_leaf(
      ::tensorflow::boosted_trees::trees::Leaf* original_leaf);
  ::tensorflow::boosted_trees::trees::Leaf* unsafe_arena_release_original_leaf();

  // float gain = 1;
  void clear_gain();
  static const int kGainFieldNumber = 1;
  float gain() const;
  void set_gain(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.TreeNodeMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::Leaf > original_oblivious_leaves_;
  ::tensorflow::boosted_trees::trees::Leaf* original_leaf_;
  float gain_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Leaf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.Leaf) */ {
 public:
  Leaf();
  virtual ~Leaf();

  Leaf(const Leaf& from);

  inline Leaf& operator=(const Leaf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Leaf(Leaf&& from) noexcept
    : Leaf() {
    *this = ::std::move(from);
  }

  inline Leaf& operator=(Leaf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Leaf& default_instance();

  enum LeafCase {
    kVector = 1,
    kSparseVector = 2,
    LEAF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Leaf* internal_default_instance() {
    return reinterpret_cast<const Leaf*>(
               &_Leaf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Leaf* other);
  void Swap(Leaf* other);
  friend void swap(Leaf& a, Leaf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Leaf* New() const final {
    return CreateMaybeMessage<Leaf>(NULL);
  }

  Leaf* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Leaf>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Leaf& from);
  void MergeFrom(const Leaf& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Leaf* other);
  protected:
  explicit Leaf(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.boosted_trees.trees.Vector vector = 1;
  bool has_vector() const;
  void clear_vector();
  static const int kVectorFieldNumber = 1;
  private:
  const ::tensorflow::boosted_trees::trees::Vector& _internal_vector() const;
  public:
  const ::tensorflow::boosted_trees::trees::Vector& vector() const;
  ::tensorflow::boosted_trees::trees::Vector* release_vector();
  ::tensorflow::boosted_trees::trees::Vector* mutable_vector();
  void set_allocated_vector(::tensorflow::boosted_trees::trees::Vector* vector);
  void unsafe_arena_set_allocated_vector(
      ::tensorflow::boosted_trees::trees::Vector* vector);
  ::tensorflow::boosted_trees::trees::Vector* unsafe_arena_release_vector();

  // .tensorflow.boosted_trees.trees.SparseVector sparse_vector = 2;
  bool has_sparse_vector() const;
  void clear_sparse_vector();
  static const int kSparseVectorFieldNumber = 2;
  private:
  const ::tensorflow::boosted_trees::trees::SparseVector& _internal_sparse_vector() const;
  public:
  const ::tensorflow::boosted_trees::trees::SparseVector& sparse_vector() const;
  ::tensorflow::boosted_trees::trees::SparseVector* release_sparse_vector();
  ::tensorflow::boosted_trees::trees::SparseVector* mutable_sparse_vector();
  void set_allocated_sparse_vector(::tensorflow::boosted_trees::trees::SparseVector* sparse_vector);
  void unsafe_arena_set_allocated_sparse_vector(
      ::tensorflow::boosted_trees::trees::SparseVector* sparse_vector);
  ::tensorflow::boosted_trees::trees::SparseVector* unsafe_arena_release_sparse_vector();

  void clear_leaf();
  LeafCase leaf_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.Leaf)
 private:
  void set_has_vector();
  void set_has_sparse_vector();

  inline bool has_leaf() const;
  inline void clear_has_leaf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union LeafUnion {
    LeafUnion() {}
    ::tensorflow::boosted_trees::trees::Vector* vector_;
    ::tensorflow::boosted_trees::trees::SparseVector* sparse_vector_;
  } leaf_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(Vector* other);
  void Swap(Vector* other);
  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const final {
    return CreateMaybeMessage<Vector>(NULL);
  }

  Vector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);
  protected:
  explicit Vector(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.Vector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SparseVector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.SparseVector) */ {
 public:
  SparseVector();
  virtual ~SparseVector();

  SparseVector(const SparseVector& from);

  inline SparseVector& operator=(const SparseVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SparseVector(SparseVector&& from) noexcept
    : SparseVector() {
    *this = ::std::move(from);
  }

  inline SparseVector& operator=(SparseVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SparseVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SparseVector* internal_default_instance() {
    return reinterpret_cast<const SparseVector*>(
               &_SparseVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(SparseVector* other);
  void Swap(SparseVector* other);
  friend void swap(SparseVector& a, SparseVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SparseVector* New() const final {
    return CreateMaybeMessage<SparseVector>(NULL);
  }

  SparseVector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SparseVector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SparseVector& from);
  void MergeFrom(const SparseVector& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SparseVector* other);
  protected:
  explicit SparseVector(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 index = 1;
  int index_size() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index(int index) const;
  void set_index(int index, ::google::protobuf::int32 value);
  void add_index(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      index() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_index();

  // repeated float value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.SparseVector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > index_;
  mutable int _index_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DenseFloatBinarySplit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.DenseFloatBinarySplit) */ {
 public:
  DenseFloatBinarySplit();
  virtual ~DenseFloatBinarySplit();

  DenseFloatBinarySplit(const DenseFloatBinarySplit& from);

  inline DenseFloatBinarySplit& operator=(const DenseFloatBinarySplit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DenseFloatBinarySplit(DenseFloatBinarySplit&& from) noexcept
    : DenseFloatBinarySplit() {
    *this = ::std::move(from);
  }

  inline DenseFloatBinarySplit& operator=(DenseFloatBinarySplit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DenseFloatBinarySplit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DenseFloatBinarySplit* internal_default_instance() {
    return reinterpret_cast<const DenseFloatBinarySplit*>(
               &_DenseFloatBinarySplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(DenseFloatBinarySplit* other);
  void Swap(DenseFloatBinarySplit* other);
  friend void swap(DenseFloatBinarySplit& a, DenseFloatBinarySplit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DenseFloatBinarySplit* New() const final {
    return CreateMaybeMessage<DenseFloatBinarySplit>(NULL);
  }

  DenseFloatBinarySplit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DenseFloatBinarySplit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DenseFloatBinarySplit& from);
  void MergeFrom(const DenseFloatBinarySplit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DenseFloatBinarySplit* other);
  protected:
  explicit DenseFloatBinarySplit(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 feature_column = 1;
  void clear_feature_column();
  static const int kFeatureColumnFieldNumber = 1;
  ::google::protobuf::int32 feature_column() const;
  void set_feature_column(::google::protobuf::int32 value);

  // float threshold = 2;
  void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  float threshold() const;
  void set_threshold(float value);

  // int32 left_id = 3;
  void clear_left_id();
  static const int kLeftIdFieldNumber = 3;
  ::google::protobuf::int32 left_id() const;
  void set_left_id(::google::protobuf::int32 value);

  // int32 right_id = 4;
  void clear_right_id();
  static const int kRightIdFieldNumber = 4;
  ::google::protobuf::int32 right_id() const;
  void set_right_id(::google::protobuf::int32 value);

  // int32 dimension_id = 5;
  void clear_dimension_id();
  static const int kDimensionIdFieldNumber = 5;
  ::google::protobuf::int32 dimension_id() const;
  void set_dimension_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.DenseFloatBinarySplit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int32 feature_column_;
  float threshold_;
  ::google::protobuf::int32 left_id_;
  ::google::protobuf::int32 right_id_;
  ::google::protobuf::int32 dimension_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SparseFloatBinarySplitDefaultLeft : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft) */ {
 public:
  SparseFloatBinarySplitDefaultLeft();
  virtual ~SparseFloatBinarySplitDefaultLeft();

  SparseFloatBinarySplitDefaultLeft(const SparseFloatBinarySplitDefaultLeft& from);

  inline SparseFloatBinarySplitDefaultLeft& operator=(const SparseFloatBinarySplitDefaultLeft& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SparseFloatBinarySplitDefaultLeft(SparseFloatBinarySplitDefaultLeft&& from) noexcept
    : SparseFloatBinarySplitDefaultLeft() {
    *this = ::std::move(from);
  }

  inline SparseFloatBinarySplitDefaultLeft& operator=(SparseFloatBinarySplitDefaultLeft&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SparseFloatBinarySplitDefaultLeft& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SparseFloatBinarySplitDefaultLeft* internal_default_instance() {
    return reinterpret_cast<const SparseFloatBinarySplitDefaultLeft*>(
               &_SparseFloatBinarySplitDefaultLeft_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(SparseFloatBinarySplitDefaultLeft* other);
  void Swap(SparseFloatBinarySplitDefaultLeft* other);
  friend void swap(SparseFloatBinarySplitDefaultLeft& a, SparseFloatBinarySplitDefaultLeft& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SparseFloatBinarySplitDefaultLeft* New() const final {
    return CreateMaybeMessage<SparseFloatBinarySplitDefaultLeft>(NULL);
  }

  SparseFloatBinarySplitDefaultLeft* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SparseFloatBinarySplitDefaultLeft>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SparseFloatBinarySplitDefaultLeft& from);
  void MergeFrom(const SparseFloatBinarySplitDefaultLeft& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SparseFloatBinarySplitDefaultLeft* other);
  protected:
  explicit SparseFloatBinarySplitDefaultLeft(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.boosted_trees.trees.DenseFloatBinarySplit split = 1;
  bool has_split() const;
  void clear_split();
  static const int kSplitFieldNumber = 1;
  private:
  const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& _internal_split() const;
  public:
  const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& split() const;
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* release_split();
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* mutable_split();
  void set_allocated_split(::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* split);
  void unsafe_arena_set_allocated_split(
      ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* split);
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* unsafe_arena_release_split();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* split_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SparseFloatBinarySplitDefaultRight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight) */ {
 public:
  SparseFloatBinarySplitDefaultRight();
  virtual ~SparseFloatBinarySplitDefaultRight();

  SparseFloatBinarySplitDefaultRight(const SparseFloatBinarySplitDefaultRight& from);

  inline SparseFloatBinarySplitDefaultRight& operator=(const SparseFloatBinarySplitDefaultRight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SparseFloatBinarySplitDefaultRight(SparseFloatBinarySplitDefaultRight&& from) noexcept
    : SparseFloatBinarySplitDefaultRight() {
    *this = ::std::move(from);
  }

  inline SparseFloatBinarySplitDefaultRight& operator=(SparseFloatBinarySplitDefaultRight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SparseFloatBinarySplitDefaultRight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SparseFloatBinarySplitDefaultRight* internal_default_instance() {
    return reinterpret_cast<const SparseFloatBinarySplitDefaultRight*>(
               &_SparseFloatBinarySplitDefaultRight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(SparseFloatBinarySplitDefaultRight* other);
  void Swap(SparseFloatBinarySplitDefaultRight* other);
  friend void swap(SparseFloatBinarySplitDefaultRight& a, SparseFloatBinarySplitDefaultRight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SparseFloatBinarySplitDefaultRight* New() const final {
    return CreateMaybeMessage<SparseFloatBinarySplitDefaultRight>(NULL);
  }

  SparseFloatBinarySplitDefaultRight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SparseFloatBinarySplitDefaultRight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SparseFloatBinarySplitDefaultRight& from);
  void MergeFrom(const SparseFloatBinarySplitDefaultRight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SparseFloatBinarySplitDefaultRight* other);
  protected:
  explicit SparseFloatBinarySplitDefaultRight(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.boosted_trees.trees.DenseFloatBinarySplit split = 1;
  bool has_split() const;
  void clear_split();
  static const int kSplitFieldNumber = 1;
  private:
  const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& _internal_split() const;
  public:
  const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& split() const;
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* release_split();
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* mutable_split();
  void set_allocated_split(::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* split);
  void unsafe_arena_set_allocated_split(
      ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* split);
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* unsafe_arena_release_split();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* split_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CategoricalIdBinarySplit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit) */ {
 public:
  CategoricalIdBinarySplit();
  virtual ~CategoricalIdBinarySplit();

  CategoricalIdBinarySplit(const CategoricalIdBinarySplit& from);

  inline CategoricalIdBinarySplit& operator=(const CategoricalIdBinarySplit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CategoricalIdBinarySplit(CategoricalIdBinarySplit&& from) noexcept
    : CategoricalIdBinarySplit() {
    *this = ::std::move(from);
  }

  inline CategoricalIdBinarySplit& operator=(CategoricalIdBinarySplit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CategoricalIdBinarySplit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CategoricalIdBinarySplit* internal_default_instance() {
    return reinterpret_cast<const CategoricalIdBinarySplit*>(
               &_CategoricalIdBinarySplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(CategoricalIdBinarySplit* other);
  void Swap(CategoricalIdBinarySplit* other);
  friend void swap(CategoricalIdBinarySplit& a, CategoricalIdBinarySplit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CategoricalIdBinarySplit* New() const final {
    return CreateMaybeMessage<CategoricalIdBinarySplit>(NULL);
  }

  CategoricalIdBinarySplit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CategoricalIdBinarySplit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CategoricalIdBinarySplit& from);
  void MergeFrom(const CategoricalIdBinarySplit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CategoricalIdBinarySplit* other);
  protected:
  explicit CategoricalIdBinarySplit(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 feature_id = 2;
  void clear_feature_id();
  static const int kFeatureIdFieldNumber = 2;
  ::google::protobuf::int64 feature_id() const;
  void set_feature_id(::google::protobuf::int64 value);

  // int32 feature_column = 1;
  void clear_feature_column();
  static const int kFeatureColumnFieldNumber = 1;
  ::google::protobuf::int32 feature_column() const;
  void set_feature_column(::google::protobuf::int32 value);

  // int32 left_id = 3;
  void clear_left_id();
  static const int kLeftIdFieldNumber = 3;
  ::google::protobuf::int32 left_id() const;
  void set_left_id(::google::protobuf::int32 value);

  // int32 right_id = 4;
  void clear_right_id();
  static const int kRightIdFieldNumber = 4;
  ::google::protobuf::int32 right_id() const;
  void set_right_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int64 feature_id_;
  ::google::protobuf::int32 feature_column_;
  ::google::protobuf::int32 left_id_;
  ::google::protobuf::int32 right_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CategoricalIdSetMembershipBinarySplit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit) */ {
 public:
  CategoricalIdSetMembershipBinarySplit();
  virtual ~CategoricalIdSetMembershipBinarySplit();

  CategoricalIdSetMembershipBinarySplit(const CategoricalIdSetMembershipBinarySplit& from);

  inline CategoricalIdSetMembershipBinarySplit& operator=(const CategoricalIdSetMembershipBinarySplit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CategoricalIdSetMembershipBinarySplit(CategoricalIdSetMembershipBinarySplit&& from) noexcept
    : CategoricalIdSetMembershipBinarySplit() {
    *this = ::std::move(from);
  }

  inline CategoricalIdSetMembershipBinarySplit& operator=(CategoricalIdSetMembershipBinarySplit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CategoricalIdSetMembershipBinarySplit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CategoricalIdSetMembershipBinarySplit* internal_default_instance() {
    return reinterpret_cast<const CategoricalIdSetMembershipBinarySplit*>(
               &_CategoricalIdSetMembershipBinarySplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(CategoricalIdSetMembershipBinarySplit* other);
  void Swap(CategoricalIdSetMembershipBinarySplit* other);
  friend void swap(CategoricalIdSetMembershipBinarySplit& a, CategoricalIdSetMembershipBinarySplit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CategoricalIdSetMembershipBinarySplit* New() const final {
    return CreateMaybeMessage<CategoricalIdSetMembershipBinarySplit>(NULL);
  }

  CategoricalIdSetMembershipBinarySplit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CategoricalIdSetMembershipBinarySplit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CategoricalIdSetMembershipBinarySplit& from);
  void MergeFrom(const CategoricalIdSetMembershipBinarySplit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CategoricalIdSetMembershipBinarySplit* other);
  protected:
  explicit CategoricalIdSetMembershipBinarySplit(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 feature_ids = 2;
  int feature_ids_size() const;
  void clear_feature_ids();
  static const int kFeatureIdsFieldNumber = 2;
  ::google::protobuf::int64 feature_ids(int index) const;
  void set_feature_ids(int index, ::google::protobuf::int64 value);
  void add_feature_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      feature_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_feature_ids();

  // int32 feature_column = 1;
  void clear_feature_column();
  static const int kFeatureColumnFieldNumber = 1;
  ::google::protobuf::int32 feature_column() const;
  void set_feature_column(::google::protobuf::int32 value);

  // int32 left_id = 3;
  void clear_left_id();
  static const int kLeftIdFieldNumber = 3;
  ::google::protobuf::int32 left_id() const;
  void set_left_id(::google::protobuf::int32 value);

  // int32 right_id = 4;
  void clear_right_id();
  static const int kRightIdFieldNumber = 4;
  ::google::protobuf::int32 right_id() const;
  void set_right_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > feature_ids_;
  mutable int _feature_ids_cached_byte_size_;
  ::google::protobuf::int32 feature_column_;
  ::google::protobuf::int32 left_id_;
  ::google::protobuf::int32 right_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObliviousDenseFloatBinarySplit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.ObliviousDenseFloatBinarySplit) */ {
 public:
  ObliviousDenseFloatBinarySplit();
  virtual ~ObliviousDenseFloatBinarySplit();

  ObliviousDenseFloatBinarySplit(const ObliviousDenseFloatBinarySplit& from);

  inline ObliviousDenseFloatBinarySplit& operator=(const ObliviousDenseFloatBinarySplit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObliviousDenseFloatBinarySplit(ObliviousDenseFloatBinarySplit&& from) noexcept
    : ObliviousDenseFloatBinarySplit() {
    *this = ::std::move(from);
  }

  inline ObliviousDenseFloatBinarySplit& operator=(ObliviousDenseFloatBinarySplit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObliviousDenseFloatBinarySplit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObliviousDenseFloatBinarySplit* internal_default_instance() {
    return reinterpret_cast<const ObliviousDenseFloatBinarySplit*>(
               &_ObliviousDenseFloatBinarySplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(ObliviousDenseFloatBinarySplit* other);
  void Swap(ObliviousDenseFloatBinarySplit* other);
  friend void swap(ObliviousDenseFloatBinarySplit& a, ObliviousDenseFloatBinarySplit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObliviousDenseFloatBinarySplit* New() const final {
    return CreateMaybeMessage<ObliviousDenseFloatBinarySplit>(NULL);
  }

  ObliviousDenseFloatBinarySplit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObliviousDenseFloatBinarySplit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObliviousDenseFloatBinarySplit& from);
  void MergeFrom(const ObliviousDenseFloatBinarySplit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObliviousDenseFloatBinarySplit* other);
  protected:
  explicit ObliviousDenseFloatBinarySplit(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 feature_column = 1;
  void clear_feature_column();
  static const int kFeatureColumnFieldNumber = 1;
  ::google::protobuf::int32 feature_column() const;
  void set_feature_column(::google::protobuf::int32 value);

  // float threshold = 2;
  void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  float threshold() const;
  void set_threshold(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.ObliviousDenseFloatBinarySplit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int32 feature_column_;
  float threshold_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObliviousCategoricalIdBinarySplit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.ObliviousCategoricalIdBinarySplit) */ {
 public:
  ObliviousCategoricalIdBinarySplit();
  virtual ~ObliviousCategoricalIdBinarySplit();

  ObliviousCategoricalIdBinarySplit(const ObliviousCategoricalIdBinarySplit& from);

  inline ObliviousCategoricalIdBinarySplit& operator=(const ObliviousCategoricalIdBinarySplit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObliviousCategoricalIdBinarySplit(ObliviousCategoricalIdBinarySplit&& from) noexcept
    : ObliviousCategoricalIdBinarySplit() {
    *this = ::std::move(from);
  }

  inline ObliviousCategoricalIdBinarySplit& operator=(ObliviousCategoricalIdBinarySplit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObliviousCategoricalIdBinarySplit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObliviousCategoricalIdBinarySplit* internal_default_instance() {
    return reinterpret_cast<const ObliviousCategoricalIdBinarySplit*>(
               &_ObliviousCategoricalIdBinarySplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(ObliviousCategoricalIdBinarySplit* other);
  void Swap(ObliviousCategoricalIdBinarySplit* other);
  friend void swap(ObliviousCategoricalIdBinarySplit& a, ObliviousCategoricalIdBinarySplit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObliviousCategoricalIdBinarySplit* New() const final {
    return CreateMaybeMessage<ObliviousCategoricalIdBinarySplit>(NULL);
  }

  ObliviousCategoricalIdBinarySplit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObliviousCategoricalIdBinarySplit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObliviousCategoricalIdBinarySplit& from);
  void MergeFrom(const ObliviousCategoricalIdBinarySplit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObliviousCategoricalIdBinarySplit* other);
  protected:
  explicit ObliviousCategoricalIdBinarySplit(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 feature_id = 2;
  void clear_feature_id();
  static const int kFeatureIdFieldNumber = 2;
  ::google::protobuf::int64 feature_id() const;
  void set_feature_id(::google::protobuf::int64 value);

  // int32 feature_column = 1;
  void clear_feature_column();
  static const int kFeatureColumnFieldNumber = 1;
  ::google::protobuf::int32 feature_column() const;
  void set_feature_column(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.ObliviousCategoricalIdBinarySplit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int64 feature_id_;
  ::google::protobuf::int32 feature_column_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecisionTreeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.DecisionTreeConfig) */ {
 public:
  DecisionTreeConfig();
  virtual ~DecisionTreeConfig();

  DecisionTreeConfig(const DecisionTreeConfig& from);

  inline DecisionTreeConfig& operator=(const DecisionTreeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DecisionTreeConfig(DecisionTreeConfig&& from) noexcept
    : DecisionTreeConfig() {
    *this = ::std::move(from);
  }

  inline DecisionTreeConfig& operator=(DecisionTreeConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DecisionTreeConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecisionTreeConfig* internal_default_instance() {
    return reinterpret_cast<const DecisionTreeConfig*>(
               &_DecisionTreeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(DecisionTreeConfig* other);
  void Swap(DecisionTreeConfig* other);
  friend void swap(DecisionTreeConfig& a, DecisionTreeConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DecisionTreeConfig* New() const final {
    return CreateMaybeMessage<DecisionTreeConfig>(NULL);
  }

  DecisionTreeConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DecisionTreeConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DecisionTreeConfig& from);
  void MergeFrom(const DecisionTreeConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecisionTreeConfig* other);
  protected:
  explicit DecisionTreeConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.boosted_trees.trees.TreeNode nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::tensorflow::boosted_trees::trees::TreeNode* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::TreeNode >*
      mutable_nodes();
  const ::tensorflow::boosted_trees::trees::TreeNode& nodes(int index) const;
  ::tensorflow::boosted_trees::trees::TreeNode* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::TreeNode >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.DecisionTreeConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::TreeNode > nodes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecisionTreeMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.DecisionTreeMetadata) */ {
 public:
  DecisionTreeMetadata();
  virtual ~DecisionTreeMetadata();

  DecisionTreeMetadata(const DecisionTreeMetadata& from);

  inline DecisionTreeMetadata& operator=(const DecisionTreeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DecisionTreeMetadata(DecisionTreeMetadata&& from) noexcept
    : DecisionTreeMetadata() {
    *this = ::std::move(from);
  }

  inline DecisionTreeMetadata& operator=(DecisionTreeMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DecisionTreeMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecisionTreeMetadata* internal_default_instance() {
    return reinterpret_cast<const DecisionTreeMetadata*>(
               &_DecisionTreeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(DecisionTreeMetadata* other);
  void Swap(DecisionTreeMetadata* other);
  friend void swap(DecisionTreeMetadata& a, DecisionTreeMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DecisionTreeMetadata* New() const final {
    return CreateMaybeMessage<DecisionTreeMetadata>(NULL);
  }

  DecisionTreeMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DecisionTreeMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DecisionTreeMetadata& from);
  void MergeFrom(const DecisionTreeMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecisionTreeMetadata* other);
  protected:
  explicit DecisionTreeMetadata(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 num_tree_weight_updates = 1;
  void clear_num_tree_weight_updates();
  static const int kNumTreeWeightUpdatesFieldNumber = 1;
  ::google::protobuf::int32 num_tree_weight_updates() const;
  void set_num_tree_weight_updates(::google::protobuf::int32 value);

  // int32 num_layers_grown = 2;
  void clear_num_layers_grown();
  static const int kNumLayersGrownFieldNumber = 2;
  ::google::protobuf::int32 num_layers_grown() const;
  void set_num_layers_grown(::google::protobuf::int32 value);

  // bool is_finalized = 3;
  void clear_is_finalized();
  static const int kIsFinalizedFieldNumber = 3;
  bool is_finalized() const;
  void set_is_finalized(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.DecisionTreeMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int32 num_tree_weight_updates_;
  ::google::protobuf::int32 num_layers_grown_;
  bool is_finalized_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GrowingMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.GrowingMetadata) */ {
 public:
  GrowingMetadata();
  virtual ~GrowingMetadata();

  GrowingMetadata(const GrowingMetadata& from);

  inline GrowingMetadata& operator=(const GrowingMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GrowingMetadata(GrowingMetadata&& from) noexcept
    : GrowingMetadata() {
    *this = ::std::move(from);
  }

  inline GrowingMetadata& operator=(GrowingMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GrowingMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GrowingMetadata* internal_default_instance() {
    return reinterpret_cast<const GrowingMetadata*>(
               &_GrowingMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(GrowingMetadata* other);
  void Swap(GrowingMetadata* other);
  friend void swap(GrowingMetadata& a, GrowingMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GrowingMetadata* New() const final {
    return CreateMaybeMessage<GrowingMetadata>(NULL);
  }

  GrowingMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GrowingMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GrowingMetadata& from);
  void MergeFrom(const GrowingMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrowingMetadata* other);
  protected:
  explicit GrowingMetadata(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 used_handler_ids = 3;
  int used_handler_ids_size() const;
  void clear_used_handler_ids();
  static const int kUsedHandlerIdsFieldNumber = 3;
  ::google::protobuf::int64 used_handler_ids(int index) const;
  void set_used_handler_ids(int index, ::google::protobuf::int64 value);
  void add_used_handler_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      used_handler_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_used_handler_ids();

  // int64 num_trees_attempted = 1;
  void clear_num_trees_attempted();
  static const int kNumTreesAttemptedFieldNumber = 1;
  ::google::protobuf::int64 num_trees_attempted() const;
  void set_num_trees_attempted(::google::protobuf::int64 value);

  // int64 num_layers_attempted = 2;
  void clear_num_layers_attempted();
  static const int kNumLayersAttemptedFieldNumber = 2;
  ::google::protobuf::int64 num_layers_attempted() const;
  void set_num_layers_attempted(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.GrowingMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > used_handler_ids_;
  mutable int _used_handler_ids_cached_byte_size_;
  ::google::protobuf::int64 num_trees_attempted_;
  ::google::protobuf::int64 num_layers_attempted_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecisionTreeEnsembleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig) */ {
 public:
  DecisionTreeEnsembleConfig();
  virtual ~DecisionTreeEnsembleConfig();

  DecisionTreeEnsembleConfig(const DecisionTreeEnsembleConfig& from);

  inline DecisionTreeEnsembleConfig& operator=(const DecisionTreeEnsembleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DecisionTreeEnsembleConfig(DecisionTreeEnsembleConfig&& from) noexcept
    : DecisionTreeEnsembleConfig() {
    *this = ::std::move(from);
  }

  inline DecisionTreeEnsembleConfig& operator=(DecisionTreeEnsembleConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DecisionTreeEnsembleConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecisionTreeEnsembleConfig* internal_default_instance() {
    return reinterpret_cast<const DecisionTreeEnsembleConfig*>(
               &_DecisionTreeEnsembleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(DecisionTreeEnsembleConfig* other);
  void Swap(DecisionTreeEnsembleConfig* other);
  friend void swap(DecisionTreeEnsembleConfig& a, DecisionTreeEnsembleConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DecisionTreeEnsembleConfig* New() const final {
    return CreateMaybeMessage<DecisionTreeEnsembleConfig>(NULL);
  }

  DecisionTreeEnsembleConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DecisionTreeEnsembleConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DecisionTreeEnsembleConfig& from);
  void MergeFrom(const DecisionTreeEnsembleConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecisionTreeEnsembleConfig* other);
  protected:
  explicit DecisionTreeEnsembleConfig(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.boosted_trees.trees.DecisionTreeConfig trees = 1;
  int trees_size() const;
  void clear_trees();
  static const int kTreesFieldNumber = 1;
  ::tensorflow::boosted_trees::trees::DecisionTreeConfig* mutable_trees(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeConfig >*
      mutable_trees();
  const ::tensorflow::boosted_trees::trees::DecisionTreeConfig& trees(int index) const;
  ::tensorflow::boosted_trees::trees::DecisionTreeConfig* add_trees();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeConfig >&
      trees() const;

  // repeated float tree_weights = 2;
  int tree_weights_size() const;
  void clear_tree_weights();
  static const int kTreeWeightsFieldNumber = 2;
  float tree_weights(int index) const;
  void set_tree_weights(int index, float value);
  void add_tree_weights(float value);
  const ::google::protobuf::RepeatedField< float >&
      tree_weights() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_tree_weights();

  // repeated .tensorflow.boosted_trees.trees.DecisionTreeMetadata tree_metadata = 3;
  int tree_metadata_size() const;
  void clear_tree_metadata();
  static const int kTreeMetadataFieldNumber = 3;
  ::tensorflow::boosted_trees::trees::DecisionTreeMetadata* mutable_tree_metadata(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeMetadata >*
      mutable_tree_metadata();
  const ::tensorflow::boosted_trees::trees::DecisionTreeMetadata& tree_metadata(int index) const;
  ::tensorflow::boosted_trees::trees::DecisionTreeMetadata* add_tree_metadata();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeMetadata >&
      tree_metadata() const;

  // .tensorflow.boosted_trees.trees.GrowingMetadata growing_metadata = 4;
  bool has_growing_metadata() const;
  void clear_growing_metadata();
  static const int kGrowingMetadataFieldNumber = 4;
  private:
  const ::tensorflow::boosted_trees::trees::GrowingMetadata& _internal_growing_metadata() const;
  public:
  const ::tensorflow::boosted_trees::trees::GrowingMetadata& growing_metadata() const;
  ::tensorflow::boosted_trees::trees::GrowingMetadata* release_growing_metadata();
  ::tensorflow::boosted_trees::trees::GrowingMetadata* mutable_growing_metadata();
  void set_allocated_growing_metadata(::tensorflow::boosted_trees::trees::GrowingMetadata* growing_metadata);
  void unsafe_arena_set_allocated_growing_metadata(
      ::tensorflow::boosted_trees::trees::GrowingMetadata* growing_metadata);
  ::tensorflow::boosted_trees::trees::GrowingMetadata* unsafe_arena_release_growing_metadata();

  // @@protoc_insertion_point(class_scope:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeConfig > trees_;
  ::google::protobuf::RepeatedField< float > tree_weights_;
  mutable int _tree_weights_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeMetadata > tree_metadata_;
  ::tensorflow::boosted_trees::trees::GrowingMetadata* growing_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TreeNode

// .tensorflow.boosted_trees.trees.Leaf leaf = 1;
inline bool TreeNode::has_leaf() const {
  return node_case() == kLeaf;
}
inline void TreeNode::set_has_leaf() {
  _oneof_case_[0] = kLeaf;
}
inline void TreeNode::clear_leaf() {
  if (has_leaf()) {
    if (GetArenaNoVirtual() == NULL) {
      delete node_.leaf_;
    }
    clear_has_node();
  }
}
inline const ::tensorflow::boosted_trees::trees::Leaf& TreeNode::_internal_leaf() const {
  return *node_.leaf_;
}
inline ::tensorflow::boosted_trees::trees::Leaf* TreeNode::release_leaf() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.leaf)
  if (has_leaf()) {
    clear_has_node();
      ::tensorflow::boosted_trees::trees::Leaf* temp = node_.leaf_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    node_.leaf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::Leaf& TreeNode::leaf() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.leaf)
  return has_leaf()
      ? *node_.leaf_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::Leaf*>(&::tensorflow::boosted_trees::trees::_Leaf_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::Leaf* TreeNode::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.leaf)
  if (has_leaf()) {
    clear_has_node();
    ::tensorflow::boosted_trees::trees::Leaf* temp = node_.leaf_;
    node_.leaf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_leaf(::tensorflow::boosted_trees::trees::Leaf* leaf) {
  clear_node();
  if (leaf) {
    set_has_leaf();
    node_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.TreeNode.leaf)
}
inline ::tensorflow::boosted_trees::trees::Leaf* TreeNode::mutable_leaf() {
  if (!has_leaf()) {
    clear_node();
    set_has_leaf();
    node_.leaf_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::Leaf >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.leaf)
  return node_.leaf_;
}

// .tensorflow.boosted_trees.trees.DenseFloatBinarySplit dense_float_binary_split = 2;
inline bool TreeNode::has_dense_float_binary_split() const {
  return node_case() == kDenseFloatBinarySplit;
}
inline void TreeNode::set_has_dense_float_binary_split() {
  _oneof_case_[0] = kDenseFloatBinarySplit;
}
inline void TreeNode::clear_dense_float_binary_split() {
  if (has_dense_float_binary_split()) {
    if (GetArenaNoVirtual() == NULL) {
      delete node_.dense_float_binary_split_;
    }
    clear_has_node();
  }
}
inline const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& TreeNode::_internal_dense_float_binary_split() const {
  return *node_.dense_float_binary_split_;
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* TreeNode::release_dense_float_binary_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.dense_float_binary_split)
  if (has_dense_float_binary_split()) {
    clear_has_node();
      ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* temp = node_.dense_float_binary_split_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    node_.dense_float_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& TreeNode::dense_float_binary_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.dense_float_binary_split)
  return has_dense_float_binary_split()
      ? *node_.dense_float_binary_split_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit*>(&::tensorflow::boosted_trees::trees::_DenseFloatBinarySplit_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* TreeNode::unsafe_arena_release_dense_float_binary_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.dense_float_binary_split)
  if (has_dense_float_binary_split()) {
    clear_has_node();
    ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* temp = node_.dense_float_binary_split_;
    node_.dense_float_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_dense_float_binary_split(::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* dense_float_binary_split) {
  clear_node();
  if (dense_float_binary_split) {
    set_has_dense_float_binary_split();
    node_.dense_float_binary_split_ = dense_float_binary_split;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.TreeNode.dense_float_binary_split)
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* TreeNode::mutable_dense_float_binary_split() {
  if (!has_dense_float_binary_split()) {
    clear_node();
    set_has_dense_float_binary_split();
    node_.dense_float_binary_split_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.dense_float_binary_split)
  return node_.dense_float_binary_split_;
}

// .tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft sparse_float_binary_split_default_left = 3;
inline bool TreeNode::has_sparse_float_binary_split_default_left() const {
  return node_case() == kSparseFloatBinarySplitDefaultLeft;
}
inline void TreeNode::set_has_sparse_float_binary_split_default_left() {
  _oneof_case_[0] = kSparseFloatBinarySplitDefaultLeft;
}
inline void TreeNode::clear_sparse_float_binary_split_default_left() {
  if (has_sparse_float_binary_split_default_left()) {
    if (GetArenaNoVirtual() == NULL) {
      delete node_.sparse_float_binary_split_default_left_;
    }
    clear_has_node();
  }
}
inline const ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft& TreeNode::_internal_sparse_float_binary_split_default_left() const {
  return *node_.sparse_float_binary_split_default_left_;
}
inline ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* TreeNode::release_sparse_float_binary_split_default_left() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_left)
  if (has_sparse_float_binary_split_default_left()) {
    clear_has_node();
      ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* temp = node_.sparse_float_binary_split_default_left_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    node_.sparse_float_binary_split_default_left_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft& TreeNode::sparse_float_binary_split_default_left() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_left)
  return has_sparse_float_binary_split_default_left()
      ? *node_.sparse_float_binary_split_default_left_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft*>(&::tensorflow::boosted_trees::trees::_SparseFloatBinarySplitDefaultLeft_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* TreeNode::unsafe_arena_release_sparse_float_binary_split_default_left() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_left)
  if (has_sparse_float_binary_split_default_left()) {
    clear_has_node();
    ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* temp = node_.sparse_float_binary_split_default_left_;
    node_.sparse_float_binary_split_default_left_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_sparse_float_binary_split_default_left(::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* sparse_float_binary_split_default_left) {
  clear_node();
  if (sparse_float_binary_split_default_left) {
    set_has_sparse_float_binary_split_default_left();
    node_.sparse_float_binary_split_default_left_ = sparse_float_binary_split_default_left;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_left)
}
inline ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft* TreeNode::mutable_sparse_float_binary_split_default_left() {
  if (!has_sparse_float_binary_split_default_left()) {
    clear_node();
    set_has_sparse_float_binary_split_default_left();
    node_.sparse_float_binary_split_default_left_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultLeft >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_left)
  return node_.sparse_float_binary_split_default_left_;
}

// .tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight sparse_float_binary_split_default_right = 4;
inline bool TreeNode::has_sparse_float_binary_split_default_right() const {
  return node_case() == kSparseFloatBinarySplitDefaultRight;
}
inline void TreeNode::set_has_sparse_float_binary_split_default_right() {
  _oneof_case_[0] = kSparseFloatBinarySplitDefaultRight;
}
inline void TreeNode::clear_sparse_float_binary_split_default_right() {
  if (has_sparse_float_binary_split_default_right()) {
    if (GetArenaNoVirtual() == NULL) {
      delete node_.sparse_float_binary_split_default_right_;
    }
    clear_has_node();
  }
}
inline const ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight& TreeNode::_internal_sparse_float_binary_split_default_right() const {
  return *node_.sparse_float_binary_split_default_right_;
}
inline ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* TreeNode::release_sparse_float_binary_split_default_right() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_right)
  if (has_sparse_float_binary_split_default_right()) {
    clear_has_node();
      ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* temp = node_.sparse_float_binary_split_default_right_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    node_.sparse_float_binary_split_default_right_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight& TreeNode::sparse_float_binary_split_default_right() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_right)
  return has_sparse_float_binary_split_default_right()
      ? *node_.sparse_float_binary_split_default_right_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight*>(&::tensorflow::boosted_trees::trees::_SparseFloatBinarySplitDefaultRight_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* TreeNode::unsafe_arena_release_sparse_float_binary_split_default_right() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_right)
  if (has_sparse_float_binary_split_default_right()) {
    clear_has_node();
    ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* temp = node_.sparse_float_binary_split_default_right_;
    node_.sparse_float_binary_split_default_right_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_sparse_float_binary_split_default_right(::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* sparse_float_binary_split_default_right) {
  clear_node();
  if (sparse_float_binary_split_default_right) {
    set_has_sparse_float_binary_split_default_right();
    node_.sparse_float_binary_split_default_right_ = sparse_float_binary_split_default_right;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_right)
}
inline ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight* TreeNode::mutable_sparse_float_binary_split_default_right() {
  if (!has_sparse_float_binary_split_default_right()) {
    clear_node();
    set_has_sparse_float_binary_split_default_right();
    node_.sparse_float_binary_split_default_right_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::SparseFloatBinarySplitDefaultRight >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.sparse_float_binary_split_default_right)
  return node_.sparse_float_binary_split_default_right_;
}

// .tensorflow.boosted_trees.trees.CategoricalIdBinarySplit categorical_id_binary_split = 5;
inline bool TreeNode::has_categorical_id_binary_split() const {
  return node_case() == kCategoricalIdBinarySplit;
}
inline void TreeNode::set_has_categorical_id_binary_split() {
  _oneof_case_[0] = kCategoricalIdBinarySplit;
}
inline void TreeNode::clear_categorical_id_binary_split() {
  if (has_categorical_id_binary_split()) {
    if (GetArenaNoVirtual() == NULL) {
      delete node_.categorical_id_binary_split_;
    }
    clear_has_node();
  }
}
inline const ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit& TreeNode::_internal_categorical_id_binary_split() const {
  return *node_.categorical_id_binary_split_;
}
inline ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* TreeNode::release_categorical_id_binary_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.categorical_id_binary_split)
  if (has_categorical_id_binary_split()) {
    clear_has_node();
      ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* temp = node_.categorical_id_binary_split_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    node_.categorical_id_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit& TreeNode::categorical_id_binary_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.categorical_id_binary_split)
  return has_categorical_id_binary_split()
      ? *node_.categorical_id_binary_split_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit*>(&::tensorflow::boosted_trees::trees::_CategoricalIdBinarySplit_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* TreeNode::unsafe_arena_release_categorical_id_binary_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.categorical_id_binary_split)
  if (has_categorical_id_binary_split()) {
    clear_has_node();
    ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* temp = node_.categorical_id_binary_split_;
    node_.categorical_id_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_categorical_id_binary_split(::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* categorical_id_binary_split) {
  clear_node();
  if (categorical_id_binary_split) {
    set_has_categorical_id_binary_split();
    node_.categorical_id_binary_split_ = categorical_id_binary_split;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.TreeNode.categorical_id_binary_split)
}
inline ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit* TreeNode::mutable_categorical_id_binary_split() {
  if (!has_categorical_id_binary_split()) {
    clear_node();
    set_has_categorical_id_binary_split();
    node_.categorical_id_binary_split_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::CategoricalIdBinarySplit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.categorical_id_binary_split)
  return node_.categorical_id_binary_split_;
}

// .tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit categorical_id_set_membership_binary_split = 6;
inline bool TreeNode::has_categorical_id_set_membership_binary_split() const {
  return node_case() == kCategoricalIdSetMembershipBinarySplit;
}
inline void TreeNode::set_has_categorical_id_set_membership_binary_split() {
  _oneof_case_[0] = kCategoricalIdSetMembershipBinarySplit;
}
inline void TreeNode::clear_categorical_id_set_membership_binary_split() {
  if (has_categorical_id_set_membership_binary_split()) {
    if (GetArenaNoVirtual() == NULL) {
      delete node_.categorical_id_set_membership_binary_split_;
    }
    clear_has_node();
  }
}
inline const ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit& TreeNode::_internal_categorical_id_set_membership_binary_split() const {
  return *node_.categorical_id_set_membership_binary_split_;
}
inline ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* TreeNode::release_categorical_id_set_membership_binary_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.categorical_id_set_membership_binary_split)
  if (has_categorical_id_set_membership_binary_split()) {
    clear_has_node();
      ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* temp = node_.categorical_id_set_membership_binary_split_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    node_.categorical_id_set_membership_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit& TreeNode::categorical_id_set_membership_binary_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.categorical_id_set_membership_binary_split)
  return has_categorical_id_set_membership_binary_split()
      ? *node_.categorical_id_set_membership_binary_split_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit*>(&::tensorflow::boosted_trees::trees::_CategoricalIdSetMembershipBinarySplit_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* TreeNode::unsafe_arena_release_categorical_id_set_membership_binary_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.categorical_id_set_membership_binary_split)
  if (has_categorical_id_set_membership_binary_split()) {
    clear_has_node();
    ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* temp = node_.categorical_id_set_membership_binary_split_;
    node_.categorical_id_set_membership_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_categorical_id_set_membership_binary_split(::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* categorical_id_set_membership_binary_split) {
  clear_node();
  if (categorical_id_set_membership_binary_split) {
    set_has_categorical_id_set_membership_binary_split();
    node_.categorical_id_set_membership_binary_split_ = categorical_id_set_membership_binary_split;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.TreeNode.categorical_id_set_membership_binary_split)
}
inline ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit* TreeNode::mutable_categorical_id_set_membership_binary_split() {
  if (!has_categorical_id_set_membership_binary_split()) {
    clear_node();
    set_has_categorical_id_set_membership_binary_split();
    node_.categorical_id_set_membership_binary_split_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::CategoricalIdSetMembershipBinarySplit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.categorical_id_set_membership_binary_split)
  return node_.categorical_id_set_membership_binary_split_;
}

// .tensorflow.boosted_trees.trees.ObliviousDenseFloatBinarySplit oblivious_dense_float_binary_split = 7;
inline bool TreeNode::has_oblivious_dense_float_binary_split() const {
  return node_case() == kObliviousDenseFloatBinarySplit;
}
inline void TreeNode::set_has_oblivious_dense_float_binary_split() {
  _oneof_case_[0] = kObliviousDenseFloatBinarySplit;
}
inline void TreeNode::clear_oblivious_dense_float_binary_split() {
  if (has_oblivious_dense_float_binary_split()) {
    if (GetArenaNoVirtual() == NULL) {
      delete node_.oblivious_dense_float_binary_split_;
    }
    clear_has_node();
  }
}
inline const ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit& TreeNode::_internal_oblivious_dense_float_binary_split() const {
  return *node_.oblivious_dense_float_binary_split_;
}
inline ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* TreeNode::release_oblivious_dense_float_binary_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.oblivious_dense_float_binary_split)
  if (has_oblivious_dense_float_binary_split()) {
    clear_has_node();
      ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* temp = node_.oblivious_dense_float_binary_split_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    node_.oblivious_dense_float_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit& TreeNode::oblivious_dense_float_binary_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.oblivious_dense_float_binary_split)
  return has_oblivious_dense_float_binary_split()
      ? *node_.oblivious_dense_float_binary_split_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit*>(&::tensorflow::boosted_trees::trees::_ObliviousDenseFloatBinarySplit_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* TreeNode::unsafe_arena_release_oblivious_dense_float_binary_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.oblivious_dense_float_binary_split)
  if (has_oblivious_dense_float_binary_split()) {
    clear_has_node();
    ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* temp = node_.oblivious_dense_float_binary_split_;
    node_.oblivious_dense_float_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_oblivious_dense_float_binary_split(::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* oblivious_dense_float_binary_split) {
  clear_node();
  if (oblivious_dense_float_binary_split) {
    set_has_oblivious_dense_float_binary_split();
    node_.oblivious_dense_float_binary_split_ = oblivious_dense_float_binary_split;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.TreeNode.oblivious_dense_float_binary_split)
}
inline ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit* TreeNode::mutable_oblivious_dense_float_binary_split() {
  if (!has_oblivious_dense_float_binary_split()) {
    clear_node();
    set_has_oblivious_dense_float_binary_split();
    node_.oblivious_dense_float_binary_split_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::ObliviousDenseFloatBinarySplit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.oblivious_dense_float_binary_split)
  return node_.oblivious_dense_float_binary_split_;
}

// .tensorflow.boosted_trees.trees.ObliviousCategoricalIdBinarySplit oblivious_categorical_id_binary_split = 8;
inline bool TreeNode::has_oblivious_categorical_id_binary_split() const {
  return node_case() == kObliviousCategoricalIdBinarySplit;
}
inline void TreeNode::set_has_oblivious_categorical_id_binary_split() {
  _oneof_case_[0] = kObliviousCategoricalIdBinarySplit;
}
inline void TreeNode::clear_oblivious_categorical_id_binary_split() {
  if (has_oblivious_categorical_id_binary_split()) {
    if (GetArenaNoVirtual() == NULL) {
      delete node_.oblivious_categorical_id_binary_split_;
    }
    clear_has_node();
  }
}
inline const ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit& TreeNode::_internal_oblivious_categorical_id_binary_split() const {
  return *node_.oblivious_categorical_id_binary_split_;
}
inline ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* TreeNode::release_oblivious_categorical_id_binary_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.oblivious_categorical_id_binary_split)
  if (has_oblivious_categorical_id_binary_split()) {
    clear_has_node();
      ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* temp = node_.oblivious_categorical_id_binary_split_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    node_.oblivious_categorical_id_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit& TreeNode::oblivious_categorical_id_binary_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.oblivious_categorical_id_binary_split)
  return has_oblivious_categorical_id_binary_split()
      ? *node_.oblivious_categorical_id_binary_split_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit*>(&::tensorflow::boosted_trees::trees::_ObliviousCategoricalIdBinarySplit_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* TreeNode::unsafe_arena_release_oblivious_categorical_id_binary_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.oblivious_categorical_id_binary_split)
  if (has_oblivious_categorical_id_binary_split()) {
    clear_has_node();
    ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* temp = node_.oblivious_categorical_id_binary_split_;
    node_.oblivious_categorical_id_binary_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_oblivious_categorical_id_binary_split(::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* oblivious_categorical_id_binary_split) {
  clear_node();
  if (oblivious_categorical_id_binary_split) {
    set_has_oblivious_categorical_id_binary_split();
    node_.oblivious_categorical_id_binary_split_ = oblivious_categorical_id_binary_split;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.TreeNode.oblivious_categorical_id_binary_split)
}
inline ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit* TreeNode::mutable_oblivious_categorical_id_binary_split() {
  if (!has_oblivious_categorical_id_binary_split()) {
    clear_node();
    set_has_oblivious_categorical_id_binary_split();
    node_.oblivious_categorical_id_binary_split_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::ObliviousCategoricalIdBinarySplit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.oblivious_categorical_id_binary_split)
  return node_.oblivious_categorical_id_binary_split_;
}

// .tensorflow.boosted_trees.trees.TreeNodeMetadata node_metadata = 777;
inline bool TreeNode::has_node_metadata() const {
  return this != internal_default_instance() && node_metadata_ != NULL;
}
inline void TreeNode::clear_node_metadata() {
  if (GetArenaNoVirtual() == NULL && node_metadata_ != NULL) {
    delete node_metadata_;
  }
  node_metadata_ = NULL;
}
inline const ::tensorflow::boosted_trees::trees::TreeNodeMetadata& TreeNode::_internal_node_metadata() const {
  return *node_metadata_;
}
inline const ::tensorflow::boosted_trees::trees::TreeNodeMetadata& TreeNode::node_metadata() const {
  const ::tensorflow::boosted_trees::trees::TreeNodeMetadata* p = node_metadata_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNode.node_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::trees::TreeNodeMetadata*>(
      &::tensorflow::boosted_trees::trees::_TreeNodeMetadata_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::TreeNodeMetadata* TreeNode::release_node_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNode.node_metadata)
  
  ::tensorflow::boosted_trees::trees::TreeNodeMetadata* temp = node_metadata_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  node_metadata_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::TreeNodeMetadata* TreeNode::unsafe_arena_release_node_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNode.node_metadata)
  
  ::tensorflow::boosted_trees::trees::TreeNodeMetadata* temp = node_metadata_;
  node_metadata_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::TreeNodeMetadata* TreeNode::mutable_node_metadata() {
  
  if (node_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::trees::TreeNodeMetadata>(GetArenaNoVirtual());
    node_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNode.node_metadata)
  return node_metadata_;
}
inline void TreeNode::set_allocated_node_metadata(::tensorflow::boosted_trees::trees::TreeNodeMetadata* node_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete node_metadata_;
  }
  if (node_metadata) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(node_metadata);
    if (message_arena != submessage_arena) {
      node_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_metadata, submessage_arena);
    }
    
  } else {
    
  }
  node_metadata_ = node_metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.trees.TreeNode.node_metadata)
}

inline bool TreeNode::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void TreeNode::clear_has_node() {
  _oneof_case_[0] = NODE_NOT_SET;
}
inline TreeNode::NodeCase TreeNode::node_case() const {
  return TreeNode::NodeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TreeNodeMetadata

// float gain = 1;
inline void TreeNodeMetadata::clear_gain() {
  gain_ = 0;
}
inline float TreeNodeMetadata::gain() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNodeMetadata.gain)
  return gain_;
}
inline void TreeNodeMetadata::set_gain(float value) {
  
  gain_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.TreeNodeMetadata.gain)
}

// .tensorflow.boosted_trees.trees.Leaf original_leaf = 2;
inline bool TreeNodeMetadata::has_original_leaf() const {
  return this != internal_default_instance() && original_leaf_ != NULL;
}
inline void TreeNodeMetadata::clear_original_leaf() {
  if (GetArenaNoVirtual() == NULL && original_leaf_ != NULL) {
    delete original_leaf_;
  }
  original_leaf_ = NULL;
}
inline const ::tensorflow::boosted_trees::trees::Leaf& TreeNodeMetadata::_internal_original_leaf() const {
  return *original_leaf_;
}
inline const ::tensorflow::boosted_trees::trees::Leaf& TreeNodeMetadata::original_leaf() const {
  const ::tensorflow::boosted_trees::trees::Leaf* p = original_leaf_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_leaf)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::trees::Leaf*>(
      &::tensorflow::boosted_trees::trees::_Leaf_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::Leaf* TreeNodeMetadata::release_original_leaf() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_leaf)
  
  ::tensorflow::boosted_trees::trees::Leaf* temp = original_leaf_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  original_leaf_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::Leaf* TreeNodeMetadata::unsafe_arena_release_original_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_leaf)
  
  ::tensorflow::boosted_trees::trees::Leaf* temp = original_leaf_;
  original_leaf_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::Leaf* TreeNodeMetadata::mutable_original_leaf() {
  
  if (original_leaf_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::trees::Leaf>(GetArenaNoVirtual());
    original_leaf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_leaf)
  return original_leaf_;
}
inline void TreeNodeMetadata::set_allocated_original_leaf(::tensorflow::boosted_trees::trees::Leaf* original_leaf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete original_leaf_;
  }
  if (original_leaf) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(original_leaf);
    if (message_arena != submessage_arena) {
      original_leaf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, original_leaf, submessage_arena);
    }
    
  } else {
    
  }
  original_leaf_ = original_leaf;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_leaf)
}

// repeated .tensorflow.boosted_trees.trees.Leaf original_oblivious_leaves = 3;
inline int TreeNodeMetadata::original_oblivious_leaves_size() const {
  return original_oblivious_leaves_.size();
}
inline void TreeNodeMetadata::clear_original_oblivious_leaves() {
  original_oblivious_leaves_.Clear();
}
inline ::tensorflow::boosted_trees::trees::Leaf* TreeNodeMetadata::mutable_original_oblivious_leaves(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_oblivious_leaves)
  return original_oblivious_leaves_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::Leaf >*
TreeNodeMetadata::mutable_original_oblivious_leaves() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_oblivious_leaves)
  return &original_oblivious_leaves_;
}
inline const ::tensorflow::boosted_trees::trees::Leaf& TreeNodeMetadata::original_oblivious_leaves(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_oblivious_leaves)
  return original_oblivious_leaves_.Get(index);
}
inline ::tensorflow::boosted_trees::trees::Leaf* TreeNodeMetadata::add_original_oblivious_leaves() {
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_oblivious_leaves)
  return original_oblivious_leaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::Leaf >&
TreeNodeMetadata::original_oblivious_leaves() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.TreeNodeMetadata.original_oblivious_leaves)
  return original_oblivious_leaves_;
}

// -------------------------------------------------------------------

// Leaf

// .tensorflow.boosted_trees.trees.Vector vector = 1;
inline bool Leaf::has_vector() const {
  return leaf_case() == kVector;
}
inline void Leaf::set_has_vector() {
  _oneof_case_[0] = kVector;
}
inline void Leaf::clear_vector() {
  if (has_vector()) {
    if (GetArenaNoVirtual() == NULL) {
      delete leaf_.vector_;
    }
    clear_has_leaf();
  }
}
inline const ::tensorflow::boosted_trees::trees::Vector& Leaf::_internal_vector() const {
  return *leaf_.vector_;
}
inline ::tensorflow::boosted_trees::trees::Vector* Leaf::release_vector() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.Leaf.vector)
  if (has_vector()) {
    clear_has_leaf();
      ::tensorflow::boosted_trees::trees::Vector* temp = leaf_.vector_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    leaf_.vector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::Vector& Leaf::vector() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.Leaf.vector)
  return has_vector()
      ? *leaf_.vector_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::Vector*>(&::tensorflow::boosted_trees::trees::_Vector_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::Vector* Leaf::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.Leaf.vector)
  if (has_vector()) {
    clear_has_leaf();
    ::tensorflow::boosted_trees::trees::Vector* temp = leaf_.vector_;
    leaf_.vector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Leaf::unsafe_arena_set_allocated_vector(::tensorflow::boosted_trees::trees::Vector* vector) {
  clear_leaf();
  if (vector) {
    set_has_vector();
    leaf_.vector_ = vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.Leaf.vector)
}
inline ::tensorflow::boosted_trees::trees::Vector* Leaf::mutable_vector() {
  if (!has_vector()) {
    clear_leaf();
    set_has_vector();
    leaf_.vector_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::Vector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.Leaf.vector)
  return leaf_.vector_;
}

// .tensorflow.boosted_trees.trees.SparseVector sparse_vector = 2;
inline bool Leaf::has_sparse_vector() const {
  return leaf_case() == kSparseVector;
}
inline void Leaf::set_has_sparse_vector() {
  _oneof_case_[0] = kSparseVector;
}
inline void Leaf::clear_sparse_vector() {
  if (has_sparse_vector()) {
    if (GetArenaNoVirtual() == NULL) {
      delete leaf_.sparse_vector_;
    }
    clear_has_leaf();
  }
}
inline const ::tensorflow::boosted_trees::trees::SparseVector& Leaf::_internal_sparse_vector() const {
  return *leaf_.sparse_vector_;
}
inline ::tensorflow::boosted_trees::trees::SparseVector* Leaf::release_sparse_vector() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.Leaf.sparse_vector)
  if (has_sparse_vector()) {
    clear_has_leaf();
      ::tensorflow::boosted_trees::trees::SparseVector* temp = leaf_.sparse_vector_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    leaf_.sparse_vector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::boosted_trees::trees::SparseVector& Leaf::sparse_vector() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.Leaf.sparse_vector)
  return has_sparse_vector()
      ? *leaf_.sparse_vector_
      : *reinterpret_cast< ::tensorflow::boosted_trees::trees::SparseVector*>(&::tensorflow::boosted_trees::trees::_SparseVector_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::SparseVector* Leaf::unsafe_arena_release_sparse_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.Leaf.sparse_vector)
  if (has_sparse_vector()) {
    clear_has_leaf();
    ::tensorflow::boosted_trees::trees::SparseVector* temp = leaf_.sparse_vector_;
    leaf_.sparse_vector_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Leaf::unsafe_arena_set_allocated_sparse_vector(::tensorflow::boosted_trees::trees::SparseVector* sparse_vector) {
  clear_leaf();
  if (sparse_vector) {
    set_has_sparse_vector();
    leaf_.sparse_vector_ = sparse_vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.boosted_trees.trees.Leaf.sparse_vector)
}
inline ::tensorflow::boosted_trees::trees::SparseVector* Leaf::mutable_sparse_vector() {
  if (!has_sparse_vector()) {
    clear_leaf();
    set_has_sparse_vector();
    leaf_.sparse_vector_ = CreateMaybeMessage< ::tensorflow::boosted_trees::trees::SparseVector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.Leaf.sparse_vector)
  return leaf_.sparse_vector_;
}

inline bool Leaf::has_leaf() const {
  return leaf_case() != LEAF_NOT_SET;
}
inline void Leaf::clear_has_leaf() {
  _oneof_case_[0] = LEAF_NOT_SET;
}
inline Leaf::LeafCase Leaf::leaf_case() const {
  return Leaf::LeafCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Vector

// repeated float value = 1;
inline int Vector::value_size() const {
  return value_.size();
}
inline void Vector::clear_value() {
  value_.Clear();
}
inline float Vector::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.Vector.value)
  return value_.Get(index);
}
inline void Vector::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.Vector.value)
}
inline void Vector::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.Vector.value)
}
inline const ::google::protobuf::RepeatedField< float >&
Vector::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.Vector.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
Vector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.Vector.value)
  return &value_;
}

// -------------------------------------------------------------------

// SparseVector

// repeated int32 index = 1;
inline int SparseVector::index_size() const {
  return index_.size();
}
inline void SparseVector::clear_index() {
  index_.Clear();
}
inline ::google::protobuf::int32 SparseVector::index(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.SparseVector.index)
  return index_.Get(index);
}
inline void SparseVector::set_index(int index, ::google::protobuf::int32 value) {
  index_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.SparseVector.index)
}
inline void SparseVector::add_index(::google::protobuf::int32 value) {
  index_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.SparseVector.index)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SparseVector::index() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.SparseVector.index)
  return index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SparseVector::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.SparseVector.index)
  return &index_;
}

// repeated float value = 2;
inline int SparseVector::value_size() const {
  return value_.size();
}
inline void SparseVector::clear_value() {
  value_.Clear();
}
inline float SparseVector::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.SparseVector.value)
  return value_.Get(index);
}
inline void SparseVector::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.SparseVector.value)
}
inline void SparseVector::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.SparseVector.value)
}
inline const ::google::protobuf::RepeatedField< float >&
SparseVector::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.SparseVector.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
SparseVector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.SparseVector.value)
  return &value_;
}

// -------------------------------------------------------------------

// DenseFloatBinarySplit

// int32 feature_column = 1;
inline void DenseFloatBinarySplit::clear_feature_column() {
  feature_column_ = 0;
}
inline ::google::protobuf::int32 DenseFloatBinarySplit::feature_column() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.feature_column)
  return feature_column_;
}
inline void DenseFloatBinarySplit::set_feature_column(::google::protobuf::int32 value) {
  
  feature_column_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.feature_column)
}

// int32 dimension_id = 5;
inline void DenseFloatBinarySplit::clear_dimension_id() {
  dimension_id_ = 0;
}
inline ::google::protobuf::int32 DenseFloatBinarySplit::dimension_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.dimension_id)
  return dimension_id_;
}
inline void DenseFloatBinarySplit::set_dimension_id(::google::protobuf::int32 value) {
  
  dimension_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.dimension_id)
}

// float threshold = 2;
inline void DenseFloatBinarySplit::clear_threshold() {
  threshold_ = 0;
}
inline float DenseFloatBinarySplit::threshold() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.threshold)
  return threshold_;
}
inline void DenseFloatBinarySplit::set_threshold(float value) {
  
  threshold_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.threshold)
}

// int32 left_id = 3;
inline void DenseFloatBinarySplit::clear_left_id() {
  left_id_ = 0;
}
inline ::google::protobuf::int32 DenseFloatBinarySplit::left_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.left_id)
  return left_id_;
}
inline void DenseFloatBinarySplit::set_left_id(::google::protobuf::int32 value) {
  
  left_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.left_id)
}

// int32 right_id = 4;
inline void DenseFloatBinarySplit::clear_right_id() {
  right_id_ = 0;
}
inline ::google::protobuf::int32 DenseFloatBinarySplit::right_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.right_id)
  return right_id_;
}
inline void DenseFloatBinarySplit::set_right_id(::google::protobuf::int32 value) {
  
  right_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DenseFloatBinarySplit.right_id)
}

// -------------------------------------------------------------------

// SparseFloatBinarySplitDefaultLeft

// .tensorflow.boosted_trees.trees.DenseFloatBinarySplit split = 1;
inline bool SparseFloatBinarySplitDefaultLeft::has_split() const {
  return this != internal_default_instance() && split_ != NULL;
}
inline void SparseFloatBinarySplitDefaultLeft::clear_split() {
  if (GetArenaNoVirtual() == NULL && split_ != NULL) {
    delete split_;
  }
  split_ = NULL;
}
inline const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& SparseFloatBinarySplitDefaultLeft::_internal_split() const {
  return *split_;
}
inline const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& SparseFloatBinarySplitDefaultLeft::split() const {
  const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* p = split_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft.split)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit*>(
      &::tensorflow::boosted_trees::trees::_DenseFloatBinarySplit_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* SparseFloatBinarySplitDefaultLeft::release_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft.split)
  
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* temp = split_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  split_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* SparseFloatBinarySplitDefaultLeft::unsafe_arena_release_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft.split)
  
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* temp = split_;
  split_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* SparseFloatBinarySplitDefaultLeft::mutable_split() {
  
  if (split_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::trees::DenseFloatBinarySplit>(GetArenaNoVirtual());
    split_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft.split)
  return split_;
}
inline void SparseFloatBinarySplitDefaultLeft::set_allocated_split(::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* split) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete split_;
  }
  if (split) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(split);
    if (message_arena != submessage_arena) {
      split = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, split, submessage_arena);
    }
    
  } else {
    
  }
  split_ = split;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft.split)
}

// -------------------------------------------------------------------

// SparseFloatBinarySplitDefaultRight

// .tensorflow.boosted_trees.trees.DenseFloatBinarySplit split = 1;
inline bool SparseFloatBinarySplitDefaultRight::has_split() const {
  return this != internal_default_instance() && split_ != NULL;
}
inline void SparseFloatBinarySplitDefaultRight::clear_split() {
  if (GetArenaNoVirtual() == NULL && split_ != NULL) {
    delete split_;
  }
  split_ = NULL;
}
inline const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& SparseFloatBinarySplitDefaultRight::_internal_split() const {
  return *split_;
}
inline const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit& SparseFloatBinarySplitDefaultRight::split() const {
  const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* p = split_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight.split)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit*>(
      &::tensorflow::boosted_trees::trees::_DenseFloatBinarySplit_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* SparseFloatBinarySplitDefaultRight::release_split() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight.split)
  
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* temp = split_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  split_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* SparseFloatBinarySplitDefaultRight::unsafe_arena_release_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight.split)
  
  ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* temp = split_;
  split_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* SparseFloatBinarySplitDefaultRight::mutable_split() {
  
  if (split_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::trees::DenseFloatBinarySplit>(GetArenaNoVirtual());
    split_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight.split)
  return split_;
}
inline void SparseFloatBinarySplitDefaultRight::set_allocated_split(::tensorflow::boosted_trees::trees::DenseFloatBinarySplit* split) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete split_;
  }
  if (split) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(split);
    if (message_arena != submessage_arena) {
      split = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, split, submessage_arena);
    }
    
  } else {
    
  }
  split_ = split;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight.split)
}

// -------------------------------------------------------------------

// CategoricalIdBinarySplit

// int32 feature_column = 1;
inline void CategoricalIdBinarySplit::clear_feature_column() {
  feature_column_ = 0;
}
inline ::google::protobuf::int32 CategoricalIdBinarySplit::feature_column() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit.feature_column)
  return feature_column_;
}
inline void CategoricalIdBinarySplit::set_feature_column(::google::protobuf::int32 value) {
  
  feature_column_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit.feature_column)
}

// int64 feature_id = 2;
inline void CategoricalIdBinarySplit::clear_feature_id() {
  feature_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CategoricalIdBinarySplit::feature_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit.feature_id)
  return feature_id_;
}
inline void CategoricalIdBinarySplit::set_feature_id(::google::protobuf::int64 value) {
  
  feature_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit.feature_id)
}

// int32 left_id = 3;
inline void CategoricalIdBinarySplit::clear_left_id() {
  left_id_ = 0;
}
inline ::google::protobuf::int32 CategoricalIdBinarySplit::left_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit.left_id)
  return left_id_;
}
inline void CategoricalIdBinarySplit::set_left_id(::google::protobuf::int32 value) {
  
  left_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit.left_id)
}

// int32 right_id = 4;
inline void CategoricalIdBinarySplit::clear_right_id() {
  right_id_ = 0;
}
inline ::google::protobuf::int32 CategoricalIdBinarySplit::right_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit.right_id)
  return right_id_;
}
inline void CategoricalIdBinarySplit::set_right_id(::google::protobuf::int32 value) {
  
  right_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.CategoricalIdBinarySplit.right_id)
}

// -------------------------------------------------------------------

// CategoricalIdSetMembershipBinarySplit

// int32 feature_column = 1;
inline void CategoricalIdSetMembershipBinarySplit::clear_feature_column() {
  feature_column_ = 0;
}
inline ::google::protobuf::int32 CategoricalIdSetMembershipBinarySplit::feature_column() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.feature_column)
  return feature_column_;
}
inline void CategoricalIdSetMembershipBinarySplit::set_feature_column(::google::protobuf::int32 value) {
  
  feature_column_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.feature_column)
}

// repeated int64 feature_ids = 2;
inline int CategoricalIdSetMembershipBinarySplit::feature_ids_size() const {
  return feature_ids_.size();
}
inline void CategoricalIdSetMembershipBinarySplit::clear_feature_ids() {
  feature_ids_.Clear();
}
inline ::google::protobuf::int64 CategoricalIdSetMembershipBinarySplit::feature_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.feature_ids)
  return feature_ids_.Get(index);
}
inline void CategoricalIdSetMembershipBinarySplit::set_feature_ids(int index, ::google::protobuf::int64 value) {
  feature_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.feature_ids)
}
inline void CategoricalIdSetMembershipBinarySplit::add_feature_ids(::google::protobuf::int64 value) {
  feature_ids_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.feature_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CategoricalIdSetMembershipBinarySplit::feature_ids() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.feature_ids)
  return feature_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CategoricalIdSetMembershipBinarySplit::mutable_feature_ids() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.feature_ids)
  return &feature_ids_;
}

// int32 left_id = 3;
inline void CategoricalIdSetMembershipBinarySplit::clear_left_id() {
  left_id_ = 0;
}
inline ::google::protobuf::int32 CategoricalIdSetMembershipBinarySplit::left_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.left_id)
  return left_id_;
}
inline void CategoricalIdSetMembershipBinarySplit::set_left_id(::google::protobuf::int32 value) {
  
  left_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.left_id)
}

// int32 right_id = 4;
inline void CategoricalIdSetMembershipBinarySplit::clear_right_id() {
  right_id_ = 0;
}
inline ::google::protobuf::int32 CategoricalIdSetMembershipBinarySplit::right_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.right_id)
  return right_id_;
}
inline void CategoricalIdSetMembershipBinarySplit::set_right_id(::google::protobuf::int32 value) {
  
  right_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit.right_id)
}

// -------------------------------------------------------------------

// ObliviousDenseFloatBinarySplit

// int32 feature_column = 1;
inline void ObliviousDenseFloatBinarySplit::clear_feature_column() {
  feature_column_ = 0;
}
inline ::google::protobuf::int32 ObliviousDenseFloatBinarySplit::feature_column() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.ObliviousDenseFloatBinarySplit.feature_column)
  return feature_column_;
}
inline void ObliviousDenseFloatBinarySplit::set_feature_column(::google::protobuf::int32 value) {
  
  feature_column_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.ObliviousDenseFloatBinarySplit.feature_column)
}

// float threshold = 2;
inline void ObliviousDenseFloatBinarySplit::clear_threshold() {
  threshold_ = 0;
}
inline float ObliviousDenseFloatBinarySplit::threshold() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.ObliviousDenseFloatBinarySplit.threshold)
  return threshold_;
}
inline void ObliviousDenseFloatBinarySplit::set_threshold(float value) {
  
  threshold_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.ObliviousDenseFloatBinarySplit.threshold)
}

// -------------------------------------------------------------------

// ObliviousCategoricalIdBinarySplit

// int32 feature_column = 1;
inline void ObliviousCategoricalIdBinarySplit::clear_feature_column() {
  feature_column_ = 0;
}
inline ::google::protobuf::int32 ObliviousCategoricalIdBinarySplit::feature_column() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.ObliviousCategoricalIdBinarySplit.feature_column)
  return feature_column_;
}
inline void ObliviousCategoricalIdBinarySplit::set_feature_column(::google::protobuf::int32 value) {
  
  feature_column_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.ObliviousCategoricalIdBinarySplit.feature_column)
}

// int64 feature_id = 2;
inline void ObliviousCategoricalIdBinarySplit::clear_feature_id() {
  feature_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ObliviousCategoricalIdBinarySplit::feature_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.ObliviousCategoricalIdBinarySplit.feature_id)
  return feature_id_;
}
inline void ObliviousCategoricalIdBinarySplit::set_feature_id(::google::protobuf::int64 value) {
  
  feature_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.ObliviousCategoricalIdBinarySplit.feature_id)
}

// -------------------------------------------------------------------

// DecisionTreeConfig

// repeated .tensorflow.boosted_trees.trees.TreeNode nodes = 1;
inline int DecisionTreeConfig::nodes_size() const {
  return nodes_.size();
}
inline void DecisionTreeConfig::clear_nodes() {
  nodes_.Clear();
}
inline ::tensorflow::boosted_trees::trees::TreeNode* DecisionTreeConfig::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.DecisionTreeConfig.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::TreeNode >*
DecisionTreeConfig::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.DecisionTreeConfig.nodes)
  return &nodes_;
}
inline const ::tensorflow::boosted_trees::trees::TreeNode& DecisionTreeConfig::nodes(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DecisionTreeConfig.nodes)
  return nodes_.Get(index);
}
inline ::tensorflow::boosted_trees::trees::TreeNode* DecisionTreeConfig::add_nodes() {
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.DecisionTreeConfig.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::TreeNode >&
DecisionTreeConfig::nodes() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.DecisionTreeConfig.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// DecisionTreeMetadata

// int32 num_tree_weight_updates = 1;
inline void DecisionTreeMetadata::clear_num_tree_weight_updates() {
  num_tree_weight_updates_ = 0;
}
inline ::google::protobuf::int32 DecisionTreeMetadata::num_tree_weight_updates() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DecisionTreeMetadata.num_tree_weight_updates)
  return num_tree_weight_updates_;
}
inline void DecisionTreeMetadata::set_num_tree_weight_updates(::google::protobuf::int32 value) {
  
  num_tree_weight_updates_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DecisionTreeMetadata.num_tree_weight_updates)
}

// int32 num_layers_grown = 2;
inline void DecisionTreeMetadata::clear_num_layers_grown() {
  num_layers_grown_ = 0;
}
inline ::google::protobuf::int32 DecisionTreeMetadata::num_layers_grown() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DecisionTreeMetadata.num_layers_grown)
  return num_layers_grown_;
}
inline void DecisionTreeMetadata::set_num_layers_grown(::google::protobuf::int32 value) {
  
  num_layers_grown_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DecisionTreeMetadata.num_layers_grown)
}

// bool is_finalized = 3;
inline void DecisionTreeMetadata::clear_is_finalized() {
  is_finalized_ = false;
}
inline bool DecisionTreeMetadata::is_finalized() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DecisionTreeMetadata.is_finalized)
  return is_finalized_;
}
inline void DecisionTreeMetadata::set_is_finalized(bool value) {
  
  is_finalized_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DecisionTreeMetadata.is_finalized)
}

// -------------------------------------------------------------------

// GrowingMetadata

// int64 num_trees_attempted = 1;
inline void GrowingMetadata::clear_num_trees_attempted() {
  num_trees_attempted_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GrowingMetadata::num_trees_attempted() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.GrowingMetadata.num_trees_attempted)
  return num_trees_attempted_;
}
inline void GrowingMetadata::set_num_trees_attempted(::google::protobuf::int64 value) {
  
  num_trees_attempted_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.GrowingMetadata.num_trees_attempted)
}

// int64 num_layers_attempted = 2;
inline void GrowingMetadata::clear_num_layers_attempted() {
  num_layers_attempted_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GrowingMetadata::num_layers_attempted() const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.GrowingMetadata.num_layers_attempted)
  return num_layers_attempted_;
}
inline void GrowingMetadata::set_num_layers_attempted(::google::protobuf::int64 value) {
  
  num_layers_attempted_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.GrowingMetadata.num_layers_attempted)
}

// repeated int64 used_handler_ids = 3;
inline int GrowingMetadata::used_handler_ids_size() const {
  return used_handler_ids_.size();
}
inline void GrowingMetadata::clear_used_handler_ids() {
  used_handler_ids_.Clear();
}
inline ::google::protobuf::int64 GrowingMetadata::used_handler_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.GrowingMetadata.used_handler_ids)
  return used_handler_ids_.Get(index);
}
inline void GrowingMetadata::set_used_handler_ids(int index, ::google::protobuf::int64 value) {
  used_handler_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.GrowingMetadata.used_handler_ids)
}
inline void GrowingMetadata::add_used_handler_ids(::google::protobuf::int64 value) {
  used_handler_ids_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.GrowingMetadata.used_handler_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GrowingMetadata::used_handler_ids() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.GrowingMetadata.used_handler_ids)
  return used_handler_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GrowingMetadata::mutable_used_handler_ids() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.GrowingMetadata.used_handler_ids)
  return &used_handler_ids_;
}

// -------------------------------------------------------------------

// DecisionTreeEnsembleConfig

// repeated .tensorflow.boosted_trees.trees.DecisionTreeConfig trees = 1;
inline int DecisionTreeEnsembleConfig::trees_size() const {
  return trees_.size();
}
inline void DecisionTreeEnsembleConfig::clear_trees() {
  trees_.Clear();
}
inline ::tensorflow::boosted_trees::trees::DecisionTreeConfig* DecisionTreeEnsembleConfig::mutable_trees(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.trees)
  return trees_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeConfig >*
DecisionTreeEnsembleConfig::mutable_trees() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.trees)
  return &trees_;
}
inline const ::tensorflow::boosted_trees::trees::DecisionTreeConfig& DecisionTreeEnsembleConfig::trees(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.trees)
  return trees_.Get(index);
}
inline ::tensorflow::boosted_trees::trees::DecisionTreeConfig* DecisionTreeEnsembleConfig::add_trees() {
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.trees)
  return trees_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeConfig >&
DecisionTreeEnsembleConfig::trees() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.trees)
  return trees_;
}

// repeated float tree_weights = 2;
inline int DecisionTreeEnsembleConfig::tree_weights_size() const {
  return tree_weights_.size();
}
inline void DecisionTreeEnsembleConfig::clear_tree_weights() {
  tree_weights_.Clear();
}
inline float DecisionTreeEnsembleConfig::tree_weights(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_weights)
  return tree_weights_.Get(index);
}
inline void DecisionTreeEnsembleConfig::set_tree_weights(int index, float value) {
  tree_weights_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_weights)
}
inline void DecisionTreeEnsembleConfig::add_tree_weights(float value) {
  tree_weights_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_weights)
}
inline const ::google::protobuf::RepeatedField< float >&
DecisionTreeEnsembleConfig::tree_weights() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_weights)
  return tree_weights_;
}
inline ::google::protobuf::RepeatedField< float >*
DecisionTreeEnsembleConfig::mutable_tree_weights() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_weights)
  return &tree_weights_;
}

// repeated .tensorflow.boosted_trees.trees.DecisionTreeMetadata tree_metadata = 3;
inline int DecisionTreeEnsembleConfig::tree_metadata_size() const {
  return tree_metadata_.size();
}
inline void DecisionTreeEnsembleConfig::clear_tree_metadata() {
  tree_metadata_.Clear();
}
inline ::tensorflow::boosted_trees::trees::DecisionTreeMetadata* DecisionTreeEnsembleConfig::mutable_tree_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_metadata)
  return tree_metadata_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeMetadata >*
DecisionTreeEnsembleConfig::mutable_tree_metadata() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_metadata)
  return &tree_metadata_;
}
inline const ::tensorflow::boosted_trees::trees::DecisionTreeMetadata& DecisionTreeEnsembleConfig::tree_metadata(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_metadata)
  return tree_metadata_.Get(index);
}
inline ::tensorflow::boosted_trees::trees::DecisionTreeMetadata* DecisionTreeEnsembleConfig::add_tree_metadata() {
  // @@protoc_insertion_point(field_add:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_metadata)
  return tree_metadata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::boosted_trees::trees::DecisionTreeMetadata >&
DecisionTreeEnsembleConfig::tree_metadata() const {
  // @@protoc_insertion_point(field_list:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.tree_metadata)
  return tree_metadata_;
}

// .tensorflow.boosted_trees.trees.GrowingMetadata growing_metadata = 4;
inline bool DecisionTreeEnsembleConfig::has_growing_metadata() const {
  return this != internal_default_instance() && growing_metadata_ != NULL;
}
inline void DecisionTreeEnsembleConfig::clear_growing_metadata() {
  if (GetArenaNoVirtual() == NULL && growing_metadata_ != NULL) {
    delete growing_metadata_;
  }
  growing_metadata_ = NULL;
}
inline const ::tensorflow::boosted_trees::trees::GrowingMetadata& DecisionTreeEnsembleConfig::_internal_growing_metadata() const {
  return *growing_metadata_;
}
inline const ::tensorflow::boosted_trees::trees::GrowingMetadata& DecisionTreeEnsembleConfig::growing_metadata() const {
  const ::tensorflow::boosted_trees::trees::GrowingMetadata* p = growing_metadata_;
  // @@protoc_insertion_point(field_get:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.growing_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::boosted_trees::trees::GrowingMetadata*>(
      &::tensorflow::boosted_trees::trees::_GrowingMetadata_default_instance_);
}
inline ::tensorflow::boosted_trees::trees::GrowingMetadata* DecisionTreeEnsembleConfig::release_growing_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.growing_metadata)
  
  ::tensorflow::boosted_trees::trees::GrowingMetadata* temp = growing_metadata_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  growing_metadata_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::GrowingMetadata* DecisionTreeEnsembleConfig::unsafe_arena_release_growing_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.growing_metadata)
  
  ::tensorflow::boosted_trees::trees::GrowingMetadata* temp = growing_metadata_;
  growing_metadata_ = NULL;
  return temp;
}
inline ::tensorflow::boosted_trees::trees::GrowingMetadata* DecisionTreeEnsembleConfig::mutable_growing_metadata() {
  
  if (growing_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::boosted_trees::trees::GrowingMetadata>(GetArenaNoVirtual());
    growing_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.growing_metadata)
  return growing_metadata_;
}
inline void DecisionTreeEnsembleConfig::set_allocated_growing_metadata(::tensorflow::boosted_trees::trees::GrowingMetadata* growing_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete growing_metadata_;
  }
  if (growing_metadata) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(growing_metadata);
    if (message_arena != submessage_arena) {
      growing_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, growing_metadata, submessage_arena);
    }
    
  } else {
    
  }
  growing_metadata_ = growing_metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig.growing_metadata)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace trees
}  // namespace boosted_trees
}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcontrib_2fboosted_5ftrees_2fproto_2ftree_5fconfig_2eproto
