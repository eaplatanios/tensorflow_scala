/* DO NOT EDIT THIS FILE - it is machine generated */

/* Copyright 2017, Emmanouil Antonios Platanios. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#include "tensor_basic_ops.h"
#include "exception.h"
#include "utilities.h"

#include <algorithm>
#include <cstring>
#include <memory>
#include <sstream>

#include "tensorflow/c/c_api.h"
#include "tensorflow/c/c_eager_api.h"

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_zerosLike(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ZerosLike", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_onesLike(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "OnesLike", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_fill(
    JNIEnv* env, jobject object, jlong context_handle, jlong dims, jlong value) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Fill", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(dims_handle, TFE_TensorHandle, dims, 0);
  TFE_OpAddInput(op.get(), dims_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_handle, TFE_TensorHandle, value, 0);
  TFE_OpAddInput(op.get(), value_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_value_handle, TFE_TensorHandle, value, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_rank(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Rank", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_size(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Size", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_shape(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Shape", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_expandDims(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong dim) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ExpandDims", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(dim_handle, TFE_TensorHandle, dim, 0);
  TFE_OpAddInput(op.get(), dim_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tdim_dim_handle, TFE_TensorHandle, dim, 0);
  const TF_DataType attr_Tdim = TFE_TensorHandleDataType(attr_Tdim_dim_handle);
  TFE_OpSetAttrType(op.get(), "Tdim", attr_Tdim);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_squeeze(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray squeeze_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Squeeze", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int squeeze_dims_n = env->GetArrayLength(squeeze_dims);
  std::unique_ptr<int64_t[]> squeeze_dims_c_value(new int64_t[squeeze_dims_n]);
  jlong* squeeze_dims_elems = env->GetLongArrayElements(squeeze_dims, nullptr);
  for (int i = 0; i < squeeze_dims_n; ++i) {
    squeeze_dims_c_value[i] = static_cast<int64_t>(squeeze_dims_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "squeeze_dims", squeeze_dims_c_value.get(), squeeze_dims_n);
  env->ReleaseLongArrayElements(squeeze_dims, squeeze_dims_elems, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_pack(
    JNIEnv* env, jobject object, jlong context_handle, jlongArray values, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Pack", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  const int values_num_tensors = env->GetArrayLength(values);
  jlong *values_elems = env->GetLongArrayElements(values, nullptr);
  for (int i = 0; i < values_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, values_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), 0);
  }
  env->ReleaseLongArrayElements(values, values_elems, JNI_ABORT);

  const int attr_N = env->GetArrayLength(values);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(attr_N));

  jlong *values_attr_T_elems = env->GetLongArrayElements(values, nullptr);
  REQUIRE_HANDLE(values_attr_T_elems_head, TFE_TensorHandle, values_attr_T_elems[0], 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(values_attr_T_elems_head);
  TFE_OpSetAttrType(op.get(), "T", attr_T);
  env->ReleaseLongArrayElements(values, values_attr_T_elems, JNI_ABORT);

  TFE_OpSetAttrInt(op.get(), "axis", static_cast<int64_t>(axis));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_parallelConcat(
    JNIEnv* env, jobject object, jlong context_handle, jlongArray values, jlongArray shape) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ParallelConcat", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  const int values_num_tensors = env->GetArrayLength(values);
  jlong *values_elems = env->GetLongArrayElements(values, nullptr);
  for (int i = 0; i < values_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, values_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), 0);
  }
  env->ReleaseLongArrayElements(values, values_elems, JNI_ABORT);

  const int attr_N = env->GetArrayLength(values);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(attr_N));

  jlong *values_attr_T_elems = env->GetLongArrayElements(values, nullptr);
  REQUIRE_HANDLE(values_attr_T_elems_head, TFE_TensorHandle, values_attr_T_elems[0], 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(values_attr_T_elems_head);
  TFE_OpSetAttrType(op.get(), "T", attr_T);
  env->ReleaseLongArrayElements(values, values_attr_T_elems, JNI_ABORT);

  std::unique_ptr<int64_t[]> shape_c_value;
  int shape_num_dims = -1;
  if (shape != nullptr) {
    shape_num_dims = env->GetArrayLength(shape);
    shape_c_value.reset(new int64_t[shape_num_dims]);
    jlong *shape_elems = env->GetLongArrayElements(shape, nullptr);
    for (int i = 0; i < shape_num_dims; ++i) {
      shape_c_value[i] = static_cast<int64_t>(shape_elems[i]);
    }
    env->ReleaseLongArrayElements(shape, shape_elems, JNI_ABORT);
  }
  TFE_OpSetAttrShape(
      op.get(), "shape", shape_c_value.get(), static_cast<int>(shape_num_dims),
      status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_unpack(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jlong num, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Unpack", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_value_handle, TFE_TensorHandle, value, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrInt(op.get(), "num", static_cast<int64_t>(num));

  TFE_OpSetAttrInt(op.get(), "axis", static_cast<int64_t>(axis));

  const int num_outputs = num;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_concatV2(
    JNIEnv* env, jobject object, jlong context_handle, jlongArray values, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ConcatV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  const int values_num_tensors = env->GetArrayLength(values);
  jlong *values_elems = env->GetLongArrayElements(values, nullptr);
  for (int i = 0; i < values_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, values_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), 0);
  }
  env->ReleaseLongArrayElements(values, values_elems, JNI_ABORT);

  REQUIRE_HANDLE(axis_handle, TFE_TensorHandle, axis, 0);
  TFE_OpAddInput(op.get(), axis_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int attr_N = env->GetArrayLength(values);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(attr_N));

  jlong *values_attr_T_elems = env->GetLongArrayElements(values, nullptr);
  REQUIRE_HANDLE(values_attr_T_elems_head, TFE_TensorHandle, values_attr_T_elems[0], 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(values_attr_T_elems_head);
  TFE_OpSetAttrType(op.get(), "T", attr_T);
  env->ReleaseLongArrayElements(values, values_attr_T_elems, JNI_ABORT);

  REQUIRE_HANDLE(attr_Tidx_axis_handle, TFE_TensorHandle, axis, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_axis_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_concatOffset(
    JNIEnv* env, jobject object, jlong context_handle, jlong concat_dim, jlongArray shape) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ConcatOffset", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(concat_dim_handle, TFE_TensorHandle, concat_dim, nullptr);
  TFE_OpAddInput(op.get(), concat_dim_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  const int shape_num_tensors = env->GetArrayLength(shape);
  jlong *shape_elems = env->GetLongArrayElements(shape, nullptr);
  for (int i = 0; i < shape_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, shape_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), nullptr);
  }
  env->ReleaseLongArrayElements(shape, shape_elems, JNI_ABORT);

  const int attr_N = env->GetArrayLength(shape);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(attr_N));

  const int num_outputs = attr_N;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_split(
    JNIEnv* env, jobject object, jlong context_handle, jlong split_dim, jlong value, jlong num_split) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Split", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(split_dim_handle, TFE_TensorHandle, split_dim, nullptr);
  TFE_OpAddInput(op.get(), split_dim_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_value_handle, TFE_TensorHandle, value, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrInt(op.get(), "num_split", static_cast<int64_t>(num_split));

  const int num_outputs = num_split;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_splitV(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jlong size_splits, jlong split_dim, jlong num_split) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SplitV", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(size_splits_handle, TFE_TensorHandle, size_splits, nullptr);
  TFE_OpAddInput(op.get(), size_splits_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(split_dim_handle, TFE_TensorHandle, split_dim, nullptr);
  TFE_OpAddInput(op.get(), split_dim_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_value_handle, TFE_TensorHandle, value, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tlen_size_splits_handle, TFE_TensorHandle, size_splits, nullptr);
  const TF_DataType attr_Tlen = TFE_TensorHandleDataType(attr_Tlen_size_splits_handle);
  TFE_OpSetAttrType(op.get(), "Tlen", attr_Tlen);

  TFE_OpSetAttrInt(op.get(), "num_split", static_cast<int64_t>(num_split));

  const int num_outputs = num_split;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_tile(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong multiples) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Tile", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(multiples_handle, TFE_TensorHandle, multiples, 0);
  TFE_OpAddInput(op.get(), multiples_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tmultiples_multiples_handle, TFE_TensorHandle, multiples, 0);
  const TF_DataType attr_Tmultiples = TFE_TensorHandleDataType(attr_Tmultiples_multiples_handle);
  TFE_OpSetAttrType(op.get(), "Tmultiples", attr_Tmultiples);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_pad(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong paddings) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Pad", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tpaddings_paddings_handle, TFE_TensorHandle, paddings, 0);
  const TF_DataType attr_Tpaddings = TFE_TensorHandleDataType(attr_Tpaddings_paddings_handle);
  TFE_OpSetAttrType(op.get(), "Tpaddings", attr_Tpaddings);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_padV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong paddings, jlong constant_values) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "PadV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(constant_values_handle, TFE_TensorHandle, constant_values, 0);
  TFE_OpAddInput(op.get(), constant_values_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tpaddings_paddings_handle, TFE_TensorHandle, paddings, 0);
  const TF_DataType attr_Tpaddings = TFE_TensorHandleDataType(attr_Tpaddings_paddings_handle);
  TFE_OpSetAttrType(op.get(), "Tpaddings", attr_Tpaddings);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_constant_values_handle, TFE_TensorHandle, constant_values, 0);
  const TF_DataType attr_T_constant_values = TFE_TensorHandleDataType(attr_T_constant_values_handle);
  if (attr_T != attr_T_constant_values) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'constant_values' of 'padV2' op with data type '"
          << attr_T_constant_values
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_mirrorPad(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong paddings, jbyteArray mode) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MirrorPad", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tpaddings_paddings_handle, TFE_TensorHandle, paddings, 0);
  const TF_DataType attr_Tpaddings = TFE_TensorHandleDataType(attr_Tpaddings_paddings_handle);
  TFE_OpSetAttrType(op.get(), "Tpaddings", attr_Tpaddings);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  jbyte *mode_c_value = env->GetByteArrayElements(mode, nullptr);
  TFE_OpSetAttrString(op.get(), "mode", reinterpret_cast<const char *>(mode_c_value));
  env->ReleaseByteArrayElements(mode, mode_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_reshape(
    JNIEnv* env, jobject object, jlong context_handle, jlong tensor, jlong shape) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Reshape", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, tensor, 0);
  TFE_OpAddInput(op.get(), tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(shape_handle, TFE_TensorHandle, shape, 0);
  TFE_OpAddInput(op.get(), shape_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tshape_shape_handle, TFE_TensorHandle, shape, 0);
  const TF_DataType attr_Tshape = TFE_TensorHandleDataType(attr_Tshape_shape_handle);
  TFE_OpSetAttrType(op.get(), "Tshape", attr_Tshape);

  REQUIRE_HANDLE(attr_T_tensor_handle, TFE_TensorHandle, tensor, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_tensor_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_transpose(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong perm) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Transpose", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(perm_handle, TFE_TensorHandle, perm, 0);
  TFE_OpAddInput(op.get(), perm_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tperm_perm_handle, TFE_TensorHandle, perm, 0);
  const TF_DataType attr_Tperm = TFE_TensorHandleDataType(attr_Tperm_perm_handle);
  TFE_OpSetAttrType(op.get(), "Tperm", attr_Tperm);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_conjugateTranspose(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong perm) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ConjugateTranspose", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(perm_handle, TFE_TensorHandle, perm, 0);
  TFE_OpAddInput(op.get(), perm_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tperm_perm_handle, TFE_TensorHandle, perm, 0);
  const TF_DataType attr_Tperm = TFE_TensorHandleDataType(attr_Tperm_perm_handle);
  TFE_OpSetAttrType(op.get(), "Tperm", attr_Tperm);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_invertPermutation(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "InvertPermutation", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_reverseV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong tensor, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ReverseV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, tensor, 0);
  TFE_OpAddInput(op.get(), tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(axis_handle, TFE_TensorHandle, axis, 0);
  TFE_OpAddInput(op.get(), axis_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_tensor_handle, TFE_TensorHandle, tensor, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_tensor_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_axis_handle, TFE_TensorHandle, axis, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_axis_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_reverseSequence(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong seq_lengths, jlong seq_dim, jlong batch_dim) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ReverseSequence", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(seq_lengths_handle, TFE_TensorHandle, seq_lengths, 0);
  TFE_OpAddInput(op.get(), seq_lengths_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tlen_seq_lengths_handle, TFE_TensorHandle, seq_lengths, 0);
  const TF_DataType attr_Tlen = TFE_TensorHandleDataType(attr_Tlen_seq_lengths_handle);
  TFE_OpSetAttrType(op.get(), "Tlen", attr_Tlen);

  TFE_OpSetAttrInt(op.get(), "seq_dim", static_cast<int64_t>(seq_dim));

  TFE_OpSetAttrInt(op.get(), "batch_dim", static_cast<int64_t>(batch_dim));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_spaceToBatchND(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong block_shape, jlong paddings) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SpaceToBatchND", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(block_shape_handle, TFE_TensorHandle, block_shape, 0);
  TFE_OpAddInput(op.get(), block_shape_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tpaddings_paddings_handle, TFE_TensorHandle, paddings, 0);
  const TF_DataType attr_Tpaddings = TFE_TensorHandleDataType(attr_Tpaddings_paddings_handle);
  TFE_OpSetAttrType(op.get(), "Tpaddings", attr_Tpaddings);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tblock_shape_block_shape_handle, TFE_TensorHandle, block_shape, 0);
  const TF_DataType attr_Tblock_shape = TFE_TensorHandleDataType(attr_Tblock_shape_block_shape_handle);
  TFE_OpSetAttrType(op.get(), "Tblock_shape", attr_Tblock_shape);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_batchToSpaceND(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong block_shape, jlong crops) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BatchToSpaceND", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(block_shape_handle, TFE_TensorHandle, block_shape, 0);
  TFE_OpAddInput(op.get(), block_shape_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(crops_handle, TFE_TensorHandle, crops, 0);
  TFE_OpAddInput(op.get(), crops_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tcrops_crops_handle, TFE_TensorHandle, crops, 0);
  const TF_DataType attr_Tcrops = TFE_TensorHandleDataType(attr_Tcrops_crops_handle);
  TFE_OpSetAttrType(op.get(), "Tcrops", attr_Tcrops);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tblock_shape_block_shape_handle, TFE_TensorHandle, block_shape, 0);
  const TF_DataType attr_Tblock_shape = TFE_TensorHandleDataType(attr_Tblock_shape_block_shape_handle);
  TFE_OpSetAttrType(op.get(), "Tblock_shape", attr_Tblock_shape);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_spaceToDepth(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong block_size, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SpaceToDepth", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrInt(op.get(), "block_size", static_cast<int64_t>(block_size));

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_depthToSpace(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong block_size, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "DepthToSpace", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrInt(op.get(), "block_size", static_cast<int64_t>(block_size));

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_where(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Where", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_unique(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jint out_idx) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Unique", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "out_idx", static_cast<TF_DataType>(out_idx));

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_uniqueWithCounts(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jint out_idx) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "UniqueWithCounts", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "out_idx", static_cast<TF_DataType>(out_idx));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_listDiff(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y, jint out_idx) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ListDiff", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, nullptr);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, nullptr);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'listDiff' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrType(op.get(), "out_idx", static_cast<TF_DataType>(out_idx));

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_gatherV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong params, jlong indices, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "GatherV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(params_handle, TFE_TensorHandle, params, 0);
  TFE_OpAddInput(op.get(), params_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(axis_handle, TFE_TensorHandle, axis, 0);
  TFE_OpAddInput(op.get(), axis_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tparams_params_handle, TFE_TensorHandle, params, 0);
  const TF_DataType attr_Tparams = TFE_TensorHandleDataType(attr_Tparams_params_handle);
  TFE_OpSetAttrType(op.get(), "Tparams", attr_Tparams);

  REQUIRE_HANDLE(attr_Taxis_axis_handle, TFE_TensorHandle, axis, 0);
  const TF_DataType attr_Taxis = TFE_TensorHandleDataType(attr_Taxis_axis_handle);
  TFE_OpSetAttrType(op.get(), "Taxis", attr_Taxis);

  REQUIRE_HANDLE(attr_Tindices_indices_handle, TFE_TensorHandle, indices, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_gatherNd(
    JNIEnv* env, jobject object, jlong context_handle, jlong params, jlong indices) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "GatherNd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(params_handle, TFE_TensorHandle, params, 0);
  TFE_OpAddInput(op.get(), params_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tparams_params_handle, TFE_TensorHandle, params, 0);
  const TF_DataType attr_Tparams = TFE_TensorHandleDataType(attr_Tparams_params_handle);
  TFE_OpSetAttrType(op.get(), "Tparams", attr_Tparams);

  REQUIRE_HANDLE(attr_Tindices_indices_handle, TFE_TensorHandle, indices, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_scatterNd(
    JNIEnv* env, jobject object, jlong context_handle, jlong indices, jlong updates, jlong shape) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ScatterNd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(updates_handle, TFE_TensorHandle, updates, 0);
  TFE_OpAddInput(op.get(), updates_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(shape_handle, TFE_TensorHandle, shape, 0);
  TFE_OpAddInput(op.get(), shape_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_updates_handle, TFE_TensorHandle, updates, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_updates_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_indices_handle, TFE_TensorHandle, indices, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  REQUIRE_HANDLE(attr_Tindices_shape_handle, TFE_TensorHandle, shape, 0);
  const TF_DataType attr_Tindices_shape = TFE_TensorHandleDataType(attr_Tindices_shape_handle);
  if (attr_Tindices != attr_Tindices_shape) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'shape' of 'scatterNd' op with data type '"
          << attr_Tindices_shape
          << "' must match data type '"
          << attr_Tindices
          << "' of argument 'indices'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_slice(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong begin, jlong size) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Slice", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(begin_handle, TFE_TensorHandle, begin, 0);
  TFE_OpAddInput(op.get(), begin_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(size_handle, TFE_TensorHandle, size, 0);
  TFE_OpAddInput(op.get(), size_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Index_begin_handle, TFE_TensorHandle, begin, 0);
  const TF_DataType attr_Index = TFE_TensorHandleDataType(attr_Index_begin_handle);
  TFE_OpSetAttrType(op.get(), "Index", attr_Index);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Index_size_handle, TFE_TensorHandle, size, 0);
  const TF_DataType attr_Index_size = TFE_TensorHandleDataType(attr_Index_size_handle);
  if (attr_Index != attr_Index_size) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'size' of 'slice' op with data type '"
          << attr_Index_size
          << "' must match data type '"
          << attr_Index
          << "' of argument 'begin'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_stridedSlice(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong begin, jlong end, jlong strides, jlong begin_mask, jlong end_mask, jlong ellipsis_mask, jlong new_axis_mask, jlong shrink_axis_mask) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StridedSlice", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(begin_handle, TFE_TensorHandle, begin, 0);
  TFE_OpAddInput(op.get(), begin_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(end_handle, TFE_TensorHandle, end, 0);
  TFE_OpAddInput(op.get(), end_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(strides_handle, TFE_TensorHandle, strides, 0);
  TFE_OpAddInput(op.get(), strides_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Index_begin_handle, TFE_TensorHandle, begin, 0);
  const TF_DataType attr_Index = TFE_TensorHandleDataType(attr_Index_begin_handle);
  TFE_OpSetAttrType(op.get(), "Index", attr_Index);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Index_end_handle, TFE_TensorHandle, end, 0);
  const TF_DataType attr_Index_end = TFE_TensorHandleDataType(attr_Index_end_handle);
  if (attr_Index != attr_Index_end) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'end' of 'stridedSlice' op with data type '"
          << attr_Index_end
          << "' must match data type '"
          << attr_Index
          << "' of argument 'begin'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_Index_strides_handle, TFE_TensorHandle, strides, 0);
  const TF_DataType attr_Index_strides = TFE_TensorHandleDataType(attr_Index_strides_handle);
  if (attr_Index != attr_Index_strides) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'strides' of 'stridedSlice' op with data type '"
          << attr_Index_strides
          << "' must match data type '"
          << attr_Index
          << "' of argument 'begin'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrInt(op.get(), "begin_mask", static_cast<int64_t>(begin_mask));

  TFE_OpSetAttrInt(op.get(), "end_mask", static_cast<int64_t>(end_mask));

  TFE_OpSetAttrInt(op.get(), "ellipsis_mask", static_cast<int64_t>(ellipsis_mask));

  TFE_OpSetAttrInt(op.get(), "new_axis_mask", static_cast<int64_t>(new_axis_mask));

  TFE_OpSetAttrInt(op.get(), "shrink_axis_mask", static_cast<int64_t>(shrink_axis_mask));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_checkNumerics(
    JNIEnv* env, jobject object, jlong context_handle, jlong tensor, jbyteArray message) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "CheckNumerics", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, tensor, 0);
  TFE_OpAddInput(op.get(), tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_tensor_handle, TFE_TensorHandle, tensor, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_tensor_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  jbyte *message_c_value = env->GetByteArrayElements(message, nullptr);
  TFE_OpSetAttrString(op.get(), "message", reinterpret_cast<const char *>(message_c_value));
  env->ReleaseByteArrayElements(message, message_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_editDistance(
    JNIEnv* env, jobject object, jlong context_handle, jlong hypothesis_indices, jlong hypothesis_values, jlong hypothesis_shape, jlong truth_indices, jlong truth_values, jlong truth_shape, jboolean normalize) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "EditDistance", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(hypothesis_indices_handle, TFE_TensorHandle, hypothesis_indices, 0);
  TFE_OpAddInput(op.get(), hypothesis_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(hypothesis_values_handle, TFE_TensorHandle, hypothesis_values, 0);
  TFE_OpAddInput(op.get(), hypothesis_values_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(hypothesis_shape_handle, TFE_TensorHandle, hypothesis_shape, 0);
  TFE_OpAddInput(op.get(), hypothesis_shape_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(truth_indices_handle, TFE_TensorHandle, truth_indices, 0);
  TFE_OpAddInput(op.get(), truth_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(truth_values_handle, TFE_TensorHandle, truth_values, 0);
  TFE_OpAddInput(op.get(), truth_values_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(truth_shape_handle, TFE_TensorHandle, truth_shape, 0);
  TFE_OpAddInput(op.get(), truth_shape_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_hypothesis_values_handle, TFE_TensorHandle, hypothesis_values, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_hypothesis_values_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_truth_values_handle, TFE_TensorHandle, truth_values, 0);
  const TF_DataType attr_T_truth_values = TFE_TensorHandleDataType(attr_T_truth_values_handle);
  if (attr_T != attr_T_truth_values) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'truth_values' of 'editDistance' op with data type '"
          << attr_T_truth_values
          << "' must match data type '"
          << attr_T
          << "' of argument 'hypothesis_values'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrBool(op.get(), "normalize", static_cast<unsigned char>(normalize));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_oneHot(
    JNIEnv* env, jobject object, jlong context_handle, jlong indices, jlong depth, jlong on_value, jlong off_value, jlong axis) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "OneHot", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(depth_handle, TFE_TensorHandle, depth, 0);
  TFE_OpAddInput(op.get(), depth_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(on_value_handle, TFE_TensorHandle, on_value, 0);
  TFE_OpAddInput(op.get(), on_value_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(off_value_handle, TFE_TensorHandle, off_value, 0);
  TFE_OpAddInput(op.get(), off_value_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_TI_indices_handle, TFE_TensorHandle, indices, 0);
  const TF_DataType attr_TI = TFE_TensorHandleDataType(attr_TI_indices_handle);
  TFE_OpSetAttrType(op.get(), "TI", attr_TI);

  REQUIRE_HANDLE(attr_T_on_value_handle, TFE_TensorHandle, on_value, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_on_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_off_value_handle, TFE_TensorHandle, off_value, 0);
  const TF_DataType attr_T_off_value = TFE_TensorHandleDataType(attr_T_off_value_handle);
  if (attr_T != attr_T_off_value) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'off_value' of 'oneHot' op with data type '"
          << attr_T_off_value
          << "' must match data type '"
          << attr_T
          << "' of argument 'on_value'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrInt(op.get(), "axis", static_cast<int64_t>(axis));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_broadcastArgs(
    JNIEnv* env, jobject object, jlong context_handle, jlong s0, jlong s1) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BroadcastArgs", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(s0_handle, TFE_TensorHandle, s0, 0);
  TFE_OpAddInput(op.get(), s0_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(s1_handle, TFE_TensorHandle, s1, 0);
  TFE_OpAddInput(op.get(), s1_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_s0_handle, TFE_TensorHandle, s0, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_s0_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_s1_handle, TFE_TensorHandle, s1, 0);
  const TF_DataType attr_T_s1 = TFE_TensorHandleDataType(attr_T_s1_handle);
  if (attr_T != attr_T_s1) {
      std::stringstream error_msg;
      error_msg
          << "Argument 's1' of 'broadcastArgs' op with data type '"
          << attr_T_s1
          << "' must match data type '"
          << attr_T
          << "' of argument 's0'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_stopGradient(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StopGradient", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_preventGradient(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jbyteArray message) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "PreventGradient", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  jbyte *message_c_value = env->GetByteArrayElements(message, nullptr);
  TFE_OpSetAttrString(op.get(), "message", reinterpret_cast<const char *>(message_c_value));
  env->ReleaseByteArrayElements(message, message_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_identity(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Identity", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_identityN(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "IdentityN", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  const int num_outputs = input;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_scatterNdNonAliasingAdd(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong indices, jlong updates) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ScatterNdNonAliasingAdd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(updates_handle, TFE_TensorHandle, updates, 0);
  TFE_OpAddInput(op.get(), updates_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_indices_handle, TFE_TensorHandle, indices, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  REQUIRE_HANDLE(attr_T_updates_handle, TFE_TensorHandle, updates, 0);
  const TF_DataType attr_T_updates = TFE_TensorHandleDataType(attr_T_updates_handle);
  if (attr_T != attr_T_updates) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'updates' of 'scatterNdNonAliasingAdd' op with data type '"
          << attr_T_updates
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_quantizeAndDequantizeV3(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong input_min, jlong input_max, jlong num_bits, jboolean signed_input, jboolean range_given) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizeAndDequantizeV3", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_min_handle, TFE_TensorHandle, input_min, 0);
  TFE_OpAddInput(op.get(), input_min_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_max_handle, TFE_TensorHandle, input_max, 0);
  TFE_OpAddInput(op.get(), input_max_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(num_bits_handle, TFE_TensorHandle, num_bits, 0);
  TFE_OpAddInput(op.get(), num_bits_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_input_min_handle, TFE_TensorHandle, input_min, 0);
  const TF_DataType attr_T_input_min = TFE_TensorHandleDataType(attr_T_input_min_handle);
  if (attr_T != attr_T_input_min) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'input_min' of 'quantizeAndDequantizeV3' op with data type '"
          << attr_T_input_min
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_input_max_handle, TFE_TensorHandle, input_max, 0);
  const TF_DataType attr_T_input_max = TFE_TensorHandleDataType(attr_T_input_max_handle);
  if (attr_T != attr_T_input_max) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'input_max' of 'quantizeAndDequantizeV3' op with data type '"
          << attr_T_input_max
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrBool(op.get(), "signed_input", static_cast<unsigned char>(signed_input));

  TFE_OpSetAttrBool(op.get(), "range_given", static_cast<unsigned char>(range_given));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_quantizeV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong min_range, jlong max_range, jint t, jbyteArray mode, jbyteArray round_mode) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizeV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_range_handle, TFE_TensorHandle, min_range, nullptr);
  TFE_OpAddInput(op.get(), min_range_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_range_handle, TFE_TensorHandle, max_range, nullptr);
  TFE_OpAddInput(op.get(), max_range_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  TFE_OpSetAttrType(op.get(), "T", static_cast<TF_DataType>(t));

  jbyte *mode_c_value = env->GetByteArrayElements(mode, nullptr);
  TFE_OpSetAttrString(op.get(), "mode", reinterpret_cast<const char *>(mode_c_value));
  env->ReleaseByteArrayElements(mode, mode_c_value, JNI_ABORT);

  jbyte *round_mode_c_value = env->GetByteArrayElements(round_mode, nullptr);
  TFE_OpSetAttrString(op.get(), "round_mode", reinterpret_cast<const char *>(round_mode_c_value));
  env->ReleaseByteArrayElements(round_mode, round_mode_c_value, JNI_ABORT);

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_dequantize(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong min_range, jlong max_range, jbyteArray mode) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Dequantize", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(min_range_handle, TFE_TensorHandle, min_range, 0);
  TFE_OpAddInput(op.get(), min_range_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(max_range_handle, TFE_TensorHandle, max_range, 0);
  TFE_OpAddInput(op.get(), max_range_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  jbyte *mode_c_value = env->GetByteArrayElements(mode, nullptr);
  TFE_OpSetAttrString(op.get(), "mode", reinterpret_cast<const char *>(mode_c_value));
  env->ReleaseByteArrayElements(mode, mode_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_quantizedConcat(
    JNIEnv* env, jobject object, jlong context_handle, jlong concat_dim, jlongArray values, jlongArray input_mins, jlongArray input_maxes) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedConcat", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(concat_dim_handle, TFE_TensorHandle, concat_dim, nullptr);
  TFE_OpAddInput(op.get(), concat_dim_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  const int values_num_tensors = env->GetArrayLength(values);
  jlong *values_elems = env->GetLongArrayElements(values, nullptr);
  for (int i = 0; i < values_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, values_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), nullptr);
  }
  env->ReleaseLongArrayElements(values, values_elems, JNI_ABORT);

  const int input_mins_num_tensors = env->GetArrayLength(input_mins);
  jlong *input_mins_elems = env->GetLongArrayElements(input_mins, nullptr);
  for (int i = 0; i < input_mins_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, input_mins_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), nullptr);
  }
  env->ReleaseLongArrayElements(input_mins, input_mins_elems, JNI_ABORT);

  const int input_maxes_num_tensors = env->GetArrayLength(input_maxes);
  jlong *input_maxes_elems = env->GetLongArrayElements(input_maxes, nullptr);
  for (int i = 0; i < input_maxes_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, input_maxes_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), nullptr);
  }
  env->ReleaseLongArrayElements(input_maxes, input_maxes_elems, JNI_ABORT);

  const int attr_N = env->GetArrayLength(values);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(attr_N));

  jlong *values_attr_T_elems = env->GetLongArrayElements(values, nullptr);
  REQUIRE_HANDLE(values_attr_T_elems_head, TFE_TensorHandle, values_attr_T_elems[0], nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(values_attr_T_elems_head);
  TFE_OpSetAttrType(op.get(), "T", attr_T);
  env->ReleaseLongArrayElements(values, values_attr_T_elems, JNI_ABORT);

  const int attr_N_input_mins = env->GetArrayLength(input_mins);
  if (attr_N != attr_N_input_mins) {
      std::stringstream error_msg;
      error_msg
          << "List argument 'input_mins' of 'quantizedConcat' op with length '"
          << attr_N_input_mins
          << "' must match length '"
          << attr_N
          << "' of argument 'values'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int attr_N_input_maxes = env->GetArrayLength(input_maxes);
  if (attr_N != attr_N_input_maxes) {
      std::stringstream error_msg;
      error_msg
          << "List argument 'input_maxes' of 'quantizedConcat' op with length '"
          << attr_N_input_maxes
          << "' must match length '"
          << attr_N
          << "' of argument 'values'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_quantizedReshape(
    JNIEnv* env, jobject object, jlong context_handle, jlong tensor, jlong shape, jlong input_min, jlong input_max) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedReshape", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, tensor, nullptr);
  TFE_OpAddInput(op.get(), tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(shape_handle, TFE_TensorHandle, shape, nullptr);
  TFE_OpAddInput(op.get(), shape_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_min_handle, TFE_TensorHandle, input_min, nullptr);
  TFE_OpAddInput(op.get(), input_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_max_handle, TFE_TensorHandle, input_max, nullptr);
  TFE_OpAddInput(op.get(), input_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tshape_shape_handle, TFE_TensorHandle, shape, nullptr);
  const TF_DataType attr_Tshape = TFE_TensorHandleDataType(attr_Tshape_shape_handle);
  TFE_OpSetAttrType(op.get(), "Tshape", attr_Tshape);

  REQUIRE_HANDLE(attr_T_tensor_handle, TFE_TensorHandle, tensor, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_tensor_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_quantizedInstanceNorm(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong x_min, jlong x_max, jboolean output_range_given, jfloat given_y_min, jfloat given_y_max, jfloat variance_epsilon, jfloat min_separation) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedInstanceNorm", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_min_handle, TFE_TensorHandle, x_min, nullptr);
  TFE_OpAddInput(op.get(), x_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_max_handle, TFE_TensorHandle, x_max, nullptr);
  TFE_OpAddInput(op.get(), x_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrBool(op.get(), "output_range_given", static_cast<unsigned char>(output_range_given));

  TFE_OpSetAttrFloat(op.get(), "given_y_min", static_cast<float>(given_y_min));

  TFE_OpSetAttrFloat(op.get(), "given_y_max", static_cast<float>(given_y_max));

  TFE_OpSetAttrFloat(op.get(), "variance_epsilon", static_cast<float>(variance_epsilon));

  TFE_OpSetAttrFloat(op.get(), "min_separation", static_cast<float>(min_separation));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_fakeQuantWithMinMaxArgs(
    JNIEnv* env, jobject object, jlong context_handle, jlong inputs, jfloat min, jfloat max, jlong num_bits, jboolean narrow_range) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FakeQuantWithMinMaxArgs", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(inputs_handle, TFE_TensorHandle, inputs, 0);
  TFE_OpAddInput(op.get(), inputs_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  TFE_OpSetAttrFloat(op.get(), "min", static_cast<float>(min));

  TFE_OpSetAttrFloat(op.get(), "max", static_cast<float>(max));

  TFE_OpSetAttrInt(op.get(), "num_bits", static_cast<int64_t>(num_bits));

  TFE_OpSetAttrBool(op.get(), "narrow_range", static_cast<unsigned char>(narrow_range));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_fakeQuantWithMinMaxVars(
    JNIEnv* env, jobject object, jlong context_handle, jlong inputs, jlong min, jlong max, jlong num_bits, jboolean narrow_range) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FakeQuantWithMinMaxVars", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(inputs_handle, TFE_TensorHandle, inputs, 0);
  TFE_OpAddInput(op.get(), inputs_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(min_handle, TFE_TensorHandle, min, 0);
  TFE_OpAddInput(op.get(), min_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(max_handle, TFE_TensorHandle, max, 0);
  TFE_OpAddInput(op.get(), max_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  TFE_OpSetAttrInt(op.get(), "num_bits", static_cast<int64_t>(num_bits));

  TFE_OpSetAttrBool(op.get(), "narrow_range", static_cast<unsigned char>(narrow_range));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Basic_00024_fakeQuantWithMinMaxVarsPerChannel(
    JNIEnv* env, jobject object, jlong context_handle, jlong inputs, jlong min, jlong max, jlong num_bits, jboolean narrow_range) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FakeQuantWithMinMaxVarsPerChannel", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(inputs_handle, TFE_TensorHandle, inputs, 0);
  TFE_OpAddInput(op.get(), inputs_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(min_handle, TFE_TensorHandle, min, 0);
  TFE_OpAddInput(op.get(), min_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(max_handle, TFE_TensorHandle, max, 0);
  TFE_OpAddInput(op.get(), max_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  TFE_OpSetAttrInt(op.get(), "num_bits", static_cast<int64_t>(num_bits));

  TFE_OpSetAttrBool(op.get(), "narrow_range", static_cast<unsigned char>(narrow_range));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}
