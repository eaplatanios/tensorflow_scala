/* DO NOT EDIT THIS FILE - it is machine generated */

/* Copyright 2017-18, Emmanouil Antonios Platanios. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#include "tensor_sparse_ops.h"
#include "exception.h"
#include "utilities.h"

#include <algorithm>
#include <cstring>
#include <memory>
#include <sstream>

#include "tensorflow/c/c_api.h"
#include "tensorflow/c/eager/c_api.h"

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Sparse_00024_sparseToDense(
    JNIEnv* env, jobject object, jlong context_handle, jlong sparse_indices, jlong output_shape, jlong sparse_values, jlong default_value, jboolean validate_indices) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SparseToDense", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(sparse_indices_handle, TFE_TensorHandle, sparse_indices, 0);
  TFE_OpAddInput(op.get(), sparse_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(output_shape_handle, TFE_TensorHandle, output_shape, 0);
  TFE_OpAddInput(op.get(), output_shape_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(sparse_values_handle, TFE_TensorHandle, sparse_values, 0);
  TFE_OpAddInput(op.get(), sparse_values_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(default_value_handle, TFE_TensorHandle, default_value, 0);
  TFE_OpAddInput(op.get(), default_value_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_sparse_values_handle, TFE_TensorHandle, sparse_values, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_sparse_values_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_sparse_indices_handle, TFE_TensorHandle, sparse_indices, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_sparse_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  REQUIRE_HANDLE(attr_T_default_value_handle, TFE_TensorHandle, default_value, 0);
  const TF_DataType attr_T_default_value = TFE_TensorHandleDataType(attr_T_default_value_handle);
  if (attr_T != attr_T_default_value) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'default_value' of 'sparseToDense' op with data type '"
          << attr_T_default_value
          << "' must match data type '"
          << attr_T
          << "' of argument 'sparse_values'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_Tindices_output_shape_handle, TFE_TensorHandle, output_shape, 0);
  const TF_DataType attr_Tindices_output_shape = TFE_TensorHandleDataType(attr_Tindices_output_shape_handle);
  if (attr_Tindices != attr_Tindices_output_shape) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'output_shape' of 'sparseToDense' op with data type '"
          << attr_Tindices_output_shape
          << "' must match data type '"
          << attr_Tindices
          << "' of argument 'sparse_indices'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrBool(op.get(), "validate_indices", static_cast<unsigned char>(validate_indices));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}
