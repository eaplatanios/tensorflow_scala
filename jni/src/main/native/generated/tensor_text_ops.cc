/* DO NOT EDIT THIS FILE - it is machine generated */

/* Copyright 2017-18, Emmanouil Antonios Platanios. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#include "tensor_text_ops.h"
#include "exception.h"
#include "utilities.h"

#include <algorithm>
#include <cstring>
#include <memory>
#include <sstream>

#include "tensorflow/c/c_api.h"
#include "tensorflow/c/c_eager_api.h"

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Text_00024_stringJoin(
    JNIEnv* env, jobject object, jlong context_handle, jlongArray inputs, jbyteArray separator) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StringJoin", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  const int inputs_num_tensors = env->GetArrayLength(inputs);
  jlong *inputs_elems = env->GetLongArrayElements(inputs, nullptr);
  for (int i = 0; i < inputs_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, inputs_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), 0);
  }
  env->ReleaseLongArrayElements(inputs, inputs_elems, JNI_ABORT);

  const int attr_N = env->GetArrayLength(inputs);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(attr_N));

  jbyte *separator_c_value = env->GetByteArrayElements(separator, nullptr);
  TFE_OpSetAttrString(op.get(), "separator", reinterpret_cast<const char *>(separator_c_value));
  env->ReleaseByteArrayElements(separator, separator_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Text_00024_stringSplit(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong delimiter, jboolean skip_empty) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StringSplit", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(delimiter_handle, TFE_TensorHandle, delimiter, nullptr);
  TFE_OpAddInput(op.get(), delimiter_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  TFE_OpSetAttrBool(op.get(), "skip_empty", static_cast<unsigned char>(skip_empty));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Text_00024_encodeBase64(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jboolean pad) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "EncodeBase64", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  TFE_OpSetAttrBool(op.get(), "pad", static_cast<unsigned char>(pad));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Text_00024_decodeBase64(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "DecodeBase64", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Text_00024_stringToHashBucket(
    JNIEnv* env, jobject object, jlong context_handle, jlong string_tensor, jlong num_buckets) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StringToHashBucket", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(string_tensor_handle, TFE_TensorHandle, string_tensor, 0);
  TFE_OpAddInput(op.get(), string_tensor_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  TFE_OpSetAttrInt(op.get(), "num_buckets", static_cast<int64_t>(num_buckets));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Text_00024_stringToHashBucketFast(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong num_buckets) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StringToHashBucketFast", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  TFE_OpSetAttrInt(op.get(), "num_buckets", static_cast<int64_t>(num_buckets));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Text_00024_stringToHashBucketStrong(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong num_buckets, jlongArray key) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "StringToHashBucketStrong", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  TFE_OpSetAttrInt(op.get(), "num_buckets", static_cast<int64_t>(num_buckets));

  const int key_n = env->GetArrayLength(key);
  std::unique_ptr<int64_t[]> key_c_value(new int64_t[key_n]);
  jlong* key_elems = env->GetLongArrayElements(key, nullptr);
  for (int i = 0; i < key_n; ++i) {
    key_c_value[i] = static_cast<int64_t>(key_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "key", key_c_value.get(), key_n);
  env->ReleaseLongArrayElements(key, key_elems, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}
