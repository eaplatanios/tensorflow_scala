/* DO NOT EDIT THIS FILE - it is machine generated */

/* Copyright 2017, Emmanouil Antonios Platanios. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#include "tensor_math_ops.h"

#include <algorithm>
#include <cstring>
#include <memory>
#include <sstream>

#include "exception.h"
#include "tf_c_api.h"
#include "tf_c_eager_api.h"
#include "utilities.h"

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_select(
    JNIEnv* env, jobject object, jlong context_handle, jlong condition, jlong t, jlong e) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Select", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(condition_handle, TFE_TensorHandle, condition, 0);
  TFE_OpAddInput(op.get(), condition_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(t_handle, TFE_TensorHandle, t, 0);
  TFE_OpAddInput(op.get(), t_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(e_handle, TFE_TensorHandle, e, 0);
  TFE_OpAddInput(op.get(), e_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_t_handle, TFE_TensorHandle, t, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_t_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_e_handle, TFE_TensorHandle, e, 0);
  const TF_DataType attr_T_e = TFE_TensorHandleDataType(attr_T_e_handle);
  if (attr_T != attr_T_e) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'e' of 'select' op with data type '"
          << attr_T_e
          << "' must match data type '"
          << attr_T
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_range(
    JNIEnv* env, jobject object, jlong context_handle, jlong start, jlong limit, jlong delta) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Range", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(start_handle, TFE_TensorHandle, start, 0);
  TFE_OpAddInput(op.get(), start_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(limit_handle, TFE_TensorHandle, limit, 0);
  TFE_OpAddInput(op.get(), limit_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(delta_handle, TFE_TensorHandle, delta, 0);
  TFE_OpAddInput(op.get(), delta_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tidx_start_handle, TFE_TensorHandle, start, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_start_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  REQUIRE_HANDLE(attr_Tidx_limit_handle, TFE_TensorHandle, limit, 0);
  const TF_DataType attr_Tidx_limit = TFE_TensorHandleDataType(attr_Tidx_limit_handle);
  if (attr_Tidx != attr_Tidx_limit) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'limit' of 'range' op with data type '"
          << attr_Tidx_limit
          << "' must match data type '"
          << attr_Tidx
          << "' of argument 'start'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_Tidx_delta_handle, TFE_TensorHandle, delta, 0);
  const TF_DataType attr_Tidx_delta = TFE_TensorHandleDataType(attr_Tidx_delta_handle);
  if (attr_Tidx != attr_Tidx_delta) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'delta' of 'range' op with data type '"
          << attr_Tidx_delta
          << "' must match data type '"
          << attr_Tidx
          << "' of argument 'start'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_linSpace(
    JNIEnv* env, jobject object, jlong context_handle, jlong start, jlong stop, jlong num) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LinSpace", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(start_handle, TFE_TensorHandle, start, 0);
  TFE_OpAddInput(op.get(), start_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(stop_handle, TFE_TensorHandle, stop, 0);
  TFE_OpAddInput(op.get(), stop_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(num_handle, TFE_TensorHandle, num, 0);
  TFE_OpAddInput(op.get(), num_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_start_handle, TFE_TensorHandle, start, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_start_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_num_handle, TFE_TensorHandle, num, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_num_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  REQUIRE_HANDLE(attr_T_stop_handle, TFE_TensorHandle, stop, 0);
  const TF_DataType attr_T_stop = TFE_TensorHandleDataType(attr_T_stop_handle);
  if (attr_T != attr_T_stop) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'stop' of 'linSpace' op with data type '"
          << attr_T_stop
          << "' must match data type '"
          << attr_T
          << "' of argument 'start'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_cast(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jint dstT) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Cast", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_SrcT_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_SrcT = TFE_TensorHandleDataType(attr_SrcT_x_handle);
  TFE_OpSetAttrType(op.get(), "SrcT", attr_SrcT);

  TFE_OpSetAttrType(op.get(), "DstT", static_cast<TF_DataType>(dstT));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_bitcast(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jint _type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Bitcast", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "type", static_cast<TF_DataType>(_type));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_addN(
    JNIEnv* env, jobject object, jlong context_handle, jlongArray inputs) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "AddN", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  const int inputs_num_tensors = env->GetArrayLength(inputs);
  jlong *inputs_elems = env->GetLongArrayElements(inputs, nullptr);
  for (int i = 0; i < inputs_num_tensors; ++i) {
    REQUIRE_HANDLE(tensor_handle, TFE_TensorHandle, inputs_elems[i], 0);
    TFE_OpAddInput(op.get(), tensor_handle, status.get());
    CHECK_STATUS(env, status.get(), 0);
  }
  env->ReleaseLongArrayElements(inputs, inputs_elems, JNI_ABORT);

  const int attr_N = env->GetArrayLength(inputs);
  TFE_OpSetAttrInt(op.get(), "N", static_cast<int64_t>(attr_N));

  jlong *inputs_attr_T_elems = env->GetLongArrayElements(inputs, nullptr);
  REQUIRE_HANDLE(inputs_attr_T_elems_head, TFE_TensorHandle, inputs_attr_T_elems[0], 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(inputs_attr_T_elems_head);
  TFE_OpSetAttrType(op.get(), "T", attr_T);
  env->ReleaseLongArrayElements(inputs, inputs_attr_T_elems, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_abs(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Abs", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_complexAbs(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jint tout) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ComplexAbs", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "Tout", static_cast<TF_DataType>(tout));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_neg(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Neg", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_reciprocal(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Reciprocal", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_square(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Square", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sqrt(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Sqrt", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_rsqrt(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Rsqrt", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_exp(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Exp", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_expm1(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Expm1", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_log(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Log", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_log1p(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Log1p", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sin(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Sin", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_cos(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Cos", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_tan(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Tan", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_asin(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Asin", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_acos(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Acos", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_atan(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Atan", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sinh(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Sinh", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_cosh(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Cosh", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_tanh(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Tanh", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_asinh(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Asinh", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_acosh(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Acosh", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_atanh(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Atanh", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_lgamma(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Lgamma", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_digamma(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Digamma", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_erf(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Erf", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_erfc(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Erfc", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sigmoid(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Sigmoid", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sign(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Sign", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_round(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Round", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_rint(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Rint", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_floor(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Floor", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_ceil(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Ceil", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_isNan(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "IsNan", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_isInf(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "IsInf", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_isFinite(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "IsFinite", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_add(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Add", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'add' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sub(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Sub", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'sub' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_mul(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Mul", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'mul' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_div(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Div", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'div' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_floorDiv(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FloorDiv", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'floorDiv' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_truncateDiv(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "TruncateDiv", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'truncateDiv' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_realDiv(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "RealDiv", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'realDiv' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_squaredDifference(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SquaredDifference", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'squaredDifference' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_mod(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Mod", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'mod' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_floorMod(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FloorMod", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'floorMod' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_truncateMod(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "TruncateMod", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'truncateMod' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_pow(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Pow", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'pow' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_igammac(
    JNIEnv* env, jobject object, jlong context_handle, jlong a, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Igammac", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(a_handle, TFE_TensorHandle, a, 0);
  TFE_OpAddInput(op.get(), a_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_a_handle, TFE_TensorHandle, a, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_a_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T_x = TFE_TensorHandleDataType(attr_T_x_handle);
  if (attr_T != attr_T_x) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'x' of 'igammac' op with data type '"
          << attr_T_x
          << "' must match data type '"
          << attr_T
          << "' of argument 'a'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_igamma(
    JNIEnv* env, jobject object, jlong context_handle, jlong a, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Igamma", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(a_handle, TFE_TensorHandle, a, 0);
  TFE_OpAddInput(op.get(), a_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_a_handle, TFE_TensorHandle, a, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_a_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T_x = TFE_TensorHandleDataType(attr_T_x_handle);
  if (attr_T != attr_T_x) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'x' of 'igamma' op with data type '"
          << attr_T_x
          << "' must match data type '"
          << attr_T
          << "' of argument 'a'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_zeta(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong q) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Zeta", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(q_handle, TFE_TensorHandle, q, 0);
  TFE_OpAddInput(op.get(), q_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_q_handle, TFE_TensorHandle, q, 0);
  const TF_DataType attr_T_q = TFE_TensorHandleDataType(attr_T_q_handle);
  if (attr_T != attr_T_q) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'q' of 'zeta' op with data type '"
          << attr_T_q
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_polygamma(
    JNIEnv* env, jobject object, jlong context_handle, jlong a, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Polygamma", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(a_handle, TFE_TensorHandle, a, 0);
  TFE_OpAddInput(op.get(), a_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_a_handle, TFE_TensorHandle, a, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_a_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T_x = TFE_TensorHandleDataType(attr_T_x_handle);
  if (attr_T != attr_T_x) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'x' of 'polygamma' op with data type '"
          << attr_T_x
          << "' must match data type '"
          << attr_T
          << "' of argument 'a'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_atan2(
    JNIEnv* env, jobject object, jlong context_handle, jlong y, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Atan2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_y_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T_x = TFE_TensorHandleDataType(attr_T_x_handle);
  if (attr_T != attr_T_x) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'x' of 'atan2' op with data type '"
          << attr_T_x
          << "' must match data type '"
          << attr_T
          << "' of argument 'y'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_maximum(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Maximum", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'maximum' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_minimum(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Minimum", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'minimum' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_betainc(
    JNIEnv* env, jobject object, jlong context_handle, jlong a, jlong b, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Betainc", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(a_handle, TFE_TensorHandle, a, 0);
  TFE_OpAddInput(op.get(), a_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(b_handle, TFE_TensorHandle, b, 0);
  TFE_OpAddInput(op.get(), b_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_a_handle, TFE_TensorHandle, a, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_a_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_b_handle, TFE_TensorHandle, b, 0);
  const TF_DataType attr_T_b = TFE_TensorHandleDataType(attr_T_b_handle);
  if (attr_T != attr_T_b) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'b' of 'betainc' op with data type '"
          << attr_T_b
          << "' must match data type '"
          << attr_T
          << "' of argument 'a'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T_x = TFE_TensorHandleDataType(attr_T_x_handle);
  if (attr_T != attr_T_x) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'x' of 'betainc' op with data type '"
          << attr_T_x
          << "' must match data type '"
          << attr_T
          << "' of argument 'a'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_logicalNot(
    JNIEnv* env, jobject object, jlong context_handle, jlong x) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LogicalNot", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_logicalAnd(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LogicalAnd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_logicalOr(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LogicalOr", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_equal(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Equal", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'equal' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_notEqual(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "NotEqual", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'notEqual' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_approximateEqual(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y, jfloat tolerance) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ApproximateEqual", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'approximateEqual' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrFloat(op.get(), "tolerance", static_cast<float>(tolerance));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_less(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Less", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'less' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_lessEqual(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LessEqual", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'lessEqual' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_greater(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Greater", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'greater' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_greaterEqual(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "GreaterEqual", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'greaterEqual' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sum(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong reduction_indices, jboolean keep_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Sum", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  TFE_OpAddInput(op.get(), reduction_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_reduction_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "keep_dims", static_cast<unsigned char>(keep_dims));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_mean(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong reduction_indices, jboolean keep_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Mean", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  TFE_OpAddInput(op.get(), reduction_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_reduction_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "keep_dims", static_cast<unsigned char>(keep_dims));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_prod(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong reduction_indices, jboolean keep_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Prod", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  TFE_OpAddInput(op.get(), reduction_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_reduction_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "keep_dims", static_cast<unsigned char>(keep_dims));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_min(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong reduction_indices, jboolean keep_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Min", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  TFE_OpAddInput(op.get(), reduction_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_reduction_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "keep_dims", static_cast<unsigned char>(keep_dims));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_max(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong reduction_indices, jboolean keep_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Max", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  TFE_OpAddInput(op.get(), reduction_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_reduction_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "keep_dims", static_cast<unsigned char>(keep_dims));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_all(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong reduction_indices, jboolean keep_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "All", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  TFE_OpAddInput(op.get(), reduction_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tidx_reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_reduction_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "keep_dims", static_cast<unsigned char>(keep_dims));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_any(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong reduction_indices, jboolean keep_dims) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Any", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  TFE_OpAddInput(op.get(), reduction_indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tidx_reduction_indices_handle, TFE_TensorHandle, reduction_indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_reduction_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "keep_dims", static_cast<unsigned char>(keep_dims));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_argMax(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong dimension, jint output_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ArgMax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(dimension_handle, TFE_TensorHandle, dimension, 0);
  TFE_OpAddInput(op.get(), dimension_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_dimension_handle, TFE_TensorHandle, dimension, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_dimension_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrType(op.get(), "output_type", static_cast<TF_DataType>(output_type));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_argMin(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong dimension, jint output_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "ArgMin", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(dimension_handle, TFE_TensorHandle, dimension, 0);
  TFE_OpAddInput(op.get(), dimension_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_dimension_handle, TFE_TensorHandle, dimension, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_dimension_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrType(op.get(), "output_type", static_cast<TF_DataType>(output_type));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_bincount(
    JNIEnv* env, jobject object, jlong context_handle, jlong arr, jlong size, jlong weights) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Bincount", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(arr_handle, TFE_TensorHandle, arr, 0);
  TFE_OpAddInput(op.get(), arr_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(size_handle, TFE_TensorHandle, size, 0);
  TFE_OpAddInput(op.get(), size_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(weights_handle, TFE_TensorHandle, weights, 0);
  TFE_OpAddInput(op.get(), weights_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_weights_handle, TFE_TensorHandle, weights, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_weights_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_cumsum(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong axis, jboolean exclusive, jboolean reverse) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Cumsum", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(axis_handle, TFE_TensorHandle, axis, 0);
  TFE_OpAddInput(op.get(), axis_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_axis_handle, TFE_TensorHandle, axis, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_axis_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "exclusive", static_cast<unsigned char>(exclusive));

  TFE_OpSetAttrBool(op.get(), "reverse", static_cast<unsigned char>(reverse));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_cumprod(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong axis, jboolean exclusive, jboolean reverse) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Cumprod", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(axis_handle, TFE_TensorHandle, axis, 0);
  TFE_OpAddInput(op.get(), axis_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_axis_handle, TFE_TensorHandle, axis, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_axis_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  TFE_OpSetAttrBool(op.get(), "exclusive", static_cast<unsigned char>(exclusive));

  TFE_OpSetAttrBool(op.get(), "reverse", static_cast<unsigned char>(reverse));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_segmentSum(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong segment_ids) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SegmentSum", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_segment_ids_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_segmentMean(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong segment_ids) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SegmentMean", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_segment_ids_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_segmentProd(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong segment_ids) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SegmentProd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_segment_ids_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_segmentMin(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong segment_ids) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SegmentMin", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_segment_ids_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_segmentMax(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong segment_ids) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SegmentMax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_segment_ids_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_unsortedSegmentSum(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong segment_ids, jlong num_segments) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "UnsortedSegmentSum", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(num_segments_handle, TFE_TensorHandle, num_segments, 0);
  TFE_OpAddInput(op.get(), num_segments_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_segment_ids_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_unsortedSegmentMax(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong segment_ids, jlong num_segments) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "UnsortedSegmentMax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(num_segments_handle, TFE_TensorHandle, num_segments, 0);
  TFE_OpAddInput(op.get(), num_segments_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tindices_segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  const TF_DataType attr_Tindices = TFE_TensorHandleDataType(attr_Tindices_segment_ids_handle);
  TFE_OpSetAttrType(op.get(), "Tindices", attr_Tindices);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sparseSegmentSum(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong indices, jlong segment_ids) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SparseSegmentSum", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_indices_handle, TFE_TensorHandle, indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sparseSegmentMean(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong indices, jlong segment_ids) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SparseSegmentMean", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_indices_handle, TFE_TensorHandle, indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sparseSegmentSqrtN(
    JNIEnv* env, jobject object, jlong context_handle, jlong data, jlong indices, jlong segment_ids) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SparseSegmentSqrtN", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(data_handle, TFE_TensorHandle, data, 0);
  TFE_OpAddInput(op.get(), data_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(indices_handle, TFE_TensorHandle, indices, 0);
  TFE_OpAddInput(op.get(), indices_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(segment_ids_handle, TFE_TensorHandle, segment_ids, 0);
  TFE_OpAddInput(op.get(), segment_ids_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_data_handle, TFE_TensorHandle, data, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_data_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_Tidx_indices_handle, TFE_TensorHandle, indices, 0);
  const TF_DataType attr_Tidx = TFE_TensorHandleDataType(attr_Tidx_indices_handle);
  TFE_OpSetAttrType(op.get(), "Tidx", attr_Tidx);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_diag(
    JNIEnv* env, jobject object, jlong context_handle, jlong diagonal) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Diag", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(diagonal_handle, TFE_TensorHandle, diagonal, 0);
  TFE_OpAddInput(op.get(), diagonal_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_diagonal_handle, TFE_TensorHandle, diagonal, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_diagonal_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_diagPart(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "DiagPart", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_matrixDiag(
    JNIEnv* env, jobject object, jlong context_handle, jlong diagonal) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MatrixDiag", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(diagonal_handle, TFE_TensorHandle, diagonal, 0);
  TFE_OpAddInput(op.get(), diagonal_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_diagonal_handle, TFE_TensorHandle, diagonal, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_diagonal_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_matrixSetDiag(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong diagonal) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MatrixSetDiag", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(diagonal_handle, TFE_TensorHandle, diagonal, 0);
  TFE_OpAddInput(op.get(), diagonal_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_diagonal_handle, TFE_TensorHandle, diagonal, 0);
  const TF_DataType attr_T_diagonal = TFE_TensorHandleDataType(attr_T_diagonal_handle);
  if (attr_T != attr_T_diagonal) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'diagonal' of 'matrixSetDiag' op with data type '"
          << attr_T_diagonal
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_matrixDiagPart(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MatrixDiagPart", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_matrixBandPart(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong num_lower, jlong num_upper) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MatrixBandPart", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(num_lower_handle, TFE_TensorHandle, num_lower, 0);
  TFE_OpAddInput(op.get(), num_lower_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(num_upper_handle, TFE_TensorHandle, num_upper, 0);
  TFE_OpAddInput(op.get(), num_upper_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_matMul(
    JNIEnv* env, jobject object, jlong context_handle, jlong a, jlong b, jboolean transpose_a, jboolean transpose_b) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MatMul", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(a_handle, TFE_TensorHandle, a, 0);
  TFE_OpAddInput(op.get(), a_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(b_handle, TFE_TensorHandle, b, 0);
  TFE_OpAddInput(op.get(), b_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_a_handle, TFE_TensorHandle, a, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_a_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_b_handle, TFE_TensorHandle, b, 0);
  const TF_DataType attr_T_b = TFE_TensorHandleDataType(attr_T_b_handle);
  if (attr_T != attr_T_b) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'b' of 'matMul' op with data type '"
          << attr_T_b
          << "' must match data type '"
          << attr_T
          << "' of argument 'a'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrBool(op.get(), "transpose_a", static_cast<unsigned char>(transpose_a));

  TFE_OpSetAttrBool(op.get(), "transpose_b", static_cast<unsigned char>(transpose_b));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_batchMatMul(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y, jboolean adj_x, jboolean adj_y) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BatchMatMul", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, 0);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, 0);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_y_handle, TFE_TensorHandle, y, 0);
  const TF_DataType attr_T_y = TFE_TensorHandleDataType(attr_T_y_handle);
  if (attr_T != attr_T_y) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'y' of 'batchMatMul' op with data type '"
          << attr_T_y
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrBool(op.get(), "adj_x", static_cast<unsigned char>(adj_x));

  TFE_OpSetAttrBool(op.get(), "adj_y", static_cast<unsigned char>(adj_y));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_sparseMatMul(
    JNIEnv* env, jobject object, jlong context_handle, jlong a, jlong b, jboolean transpose_a, jboolean transpose_b, jboolean a_is_sparse, jboolean b_is_sparse) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SparseMatMul", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(a_handle, TFE_TensorHandle, a, 0);
  TFE_OpAddInput(op.get(), a_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(b_handle, TFE_TensorHandle, b, 0);
  TFE_OpAddInput(op.get(), b_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_Tb_b_handle, TFE_TensorHandle, b, 0);
  const TF_DataType attr_Tb = TFE_TensorHandleDataType(attr_Tb_b_handle);
  TFE_OpSetAttrType(op.get(), "Tb", attr_Tb);

  REQUIRE_HANDLE(attr_Ta_a_handle, TFE_TensorHandle, a, 0);
  const TF_DataType attr_Ta = TFE_TensorHandleDataType(attr_Ta_a_handle);
  TFE_OpSetAttrType(op.get(), "Ta", attr_Ta);

  TFE_OpSetAttrBool(op.get(), "transpose_a", static_cast<unsigned char>(transpose_a));

  TFE_OpSetAttrBool(op.get(), "transpose_b", static_cast<unsigned char>(transpose_b));

  TFE_OpSetAttrBool(op.get(), "a_is_sparse", static_cast<unsigned char>(a_is_sparse));

  TFE_OpSetAttrBool(op.get(), "b_is_sparse", static_cast<unsigned char>(b_is_sparse));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_cross(
    JNIEnv* env, jobject object, jlong context_handle, jlong a, jlong b) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Cross", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(a_handle, TFE_TensorHandle, a, 0);
  TFE_OpAddInput(op.get(), a_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(b_handle, TFE_TensorHandle, b, 0);
  TFE_OpAddInput(op.get(), b_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_a_handle, TFE_TensorHandle, a, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_a_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_b_handle, TFE_TensorHandle, b, 0);
  const TF_DataType attr_T_b = TFE_TensorHandleDataType(attr_T_b_handle);
  if (attr_T != attr_T_b) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'b' of 'cross' op with data type '"
          << attr_T_b
          << "' must match data type '"
          << attr_T
          << "' of argument 'a'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_complex(
    JNIEnv* env, jobject object, jlong context_handle, jlong real, jlong imag, jint tout) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Complex", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(real_handle, TFE_TensorHandle, real, 0);
  TFE_OpAddInput(op.get(), real_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(imag_handle, TFE_TensorHandle, imag, 0);
  TFE_OpAddInput(op.get(), imag_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_real_handle, TFE_TensorHandle, real, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_real_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_imag_handle, TFE_TensorHandle, imag, 0);
  const TF_DataType attr_T_imag = TFE_TensorHandleDataType(attr_T_imag_handle);
  if (attr_T != attr_T_imag) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'imag' of 'complex' op with data type '"
          << attr_T_imag
          << "' must match data type '"
          << attr_T
          << "' of argument 'real'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrType(op.get(), "Tout", static_cast<TF_DataType>(tout));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_real(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jint tout) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Real", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "Tout", static_cast<TF_DataType>(tout));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_imag(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jint tout) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Imag", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "Tout", static_cast<TF_DataType>(tout));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_angle(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jint tout) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Angle", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrType(op.get(), "Tout", static_cast<TF_DataType>(tout));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_conj(
    JNIEnv* env, jobject object, jlong context_handle, jlong input) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Conj", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_bucketize(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jfloatArray boundaries) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Bucketize", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int boundaries_n = env->GetArrayLength(boundaries);
  std::unique_ptr<float[]> boundaries_c_value(new float[boundaries_n]);
  jfloat* boundaries_elems = env->GetFloatArrayElements(boundaries, nullptr);
  for (int i = 0; i < boundaries_n; ++i) {
    boundaries_c_value[i] = static_cast<float>(boundaries_elems[i]);
  }
  TFE_OpSetAttrFloatList(op.get(), "boundaries", boundaries_c_value.get(), boundaries_n);
  env->ReleaseFloatArrayElements(boundaries, boundaries_elems, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_quantizedAdd(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y, jlong min_x, jlong max_x, jlong min_y, jlong max_y, jint toutput) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedAdd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, nullptr);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_x_handle, TFE_TensorHandle, min_x, nullptr);
  TFE_OpAddInput(op.get(), min_x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_x_handle, TFE_TensorHandle, max_x, nullptr);
  TFE_OpAddInput(op.get(), max_x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_y_handle, TFE_TensorHandle, min_y, nullptr);
  TFE_OpAddInput(op.get(), min_y_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_y_handle, TFE_TensorHandle, max_y, nullptr);
  TFE_OpAddInput(op.get(), max_y_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T2_y_handle, TFE_TensorHandle, y, nullptr);
  const TF_DataType attr_T2 = TFE_TensorHandleDataType(attr_T2_y_handle);
  TFE_OpSetAttrType(op.get(), "T2", attr_T2);

  REQUIRE_HANDLE(attr_T1_x_handle, TFE_TensorHandle, x, nullptr);
  const TF_DataType attr_T1 = TFE_TensorHandleDataType(attr_T1_x_handle);
  TFE_OpSetAttrType(op.get(), "T1", attr_T1);

  TFE_OpSetAttrType(op.get(), "Toutput", static_cast<TF_DataType>(toutput));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_quantizedMul(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong y, jlong min_x, jlong max_x, jlong min_y, jlong max_y, jint toutput) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedMul", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(y_handle, TFE_TensorHandle, y, nullptr);
  TFE_OpAddInput(op.get(), y_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_x_handle, TFE_TensorHandle, min_x, nullptr);
  TFE_OpAddInput(op.get(), min_x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_x_handle, TFE_TensorHandle, max_x, nullptr);
  TFE_OpAddInput(op.get(), max_x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_y_handle, TFE_TensorHandle, min_y, nullptr);
  TFE_OpAddInput(op.get(), min_y_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_y_handle, TFE_TensorHandle, max_y, nullptr);
  TFE_OpAddInput(op.get(), max_y_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T2_y_handle, TFE_TensorHandle, y, nullptr);
  const TF_DataType attr_T2 = TFE_TensorHandleDataType(attr_T2_y_handle);
  TFE_OpSetAttrType(op.get(), "T2", attr_T2);

  REQUIRE_HANDLE(attr_T1_x_handle, TFE_TensorHandle, x, nullptr);
  const TF_DataType attr_T1 = TFE_TensorHandleDataType(attr_T1_x_handle);
  TFE_OpSetAttrType(op.get(), "T1", attr_T1);

  TFE_OpSetAttrType(op.get(), "Toutput", static_cast<TF_DataType>(toutput));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_quantizedMatMul(
    JNIEnv* env, jobject object, jlong context_handle, jlong a, jlong b, jlong min_a, jlong max_a, jlong min_b, jlong max_b, jint toutput, jboolean transpose_a, jboolean transpose_b, jint tactivation) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedMatMul", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(a_handle, TFE_TensorHandle, a, nullptr);
  TFE_OpAddInput(op.get(), a_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(b_handle, TFE_TensorHandle, b, nullptr);
  TFE_OpAddInput(op.get(), b_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_a_handle, TFE_TensorHandle, min_a, nullptr);
  TFE_OpAddInput(op.get(), min_a_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_a_handle, TFE_TensorHandle, max_a, nullptr);
  TFE_OpAddInput(op.get(), max_a_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_b_handle, TFE_TensorHandle, min_b, nullptr);
  TFE_OpAddInput(op.get(), min_b_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_b_handle, TFE_TensorHandle, max_b, nullptr);
  TFE_OpAddInput(op.get(), max_b_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T2_b_handle, TFE_TensorHandle, b, nullptr);
  const TF_DataType attr_T2 = TFE_TensorHandleDataType(attr_T2_b_handle);
  TFE_OpSetAttrType(op.get(), "T2", attr_T2);

  REQUIRE_HANDLE(attr_T1_a_handle, TFE_TensorHandle, a, nullptr);
  const TF_DataType attr_T1 = TFE_TensorHandleDataType(attr_T1_a_handle);
  TFE_OpSetAttrType(op.get(), "T1", attr_T1);

  TFE_OpSetAttrType(op.get(), "Toutput", static_cast<TF_DataType>(toutput));

  TFE_OpSetAttrBool(op.get(), "transpose_a", static_cast<unsigned char>(transpose_a));

  TFE_OpSetAttrBool(op.get(), "transpose_b", static_cast<unsigned char>(transpose_b));

  TFE_OpSetAttrType(op.get(), "Tactivation", static_cast<TF_DataType>(tactivation));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_quantizeDownAndShrinkRange(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong input_min, jlong input_max, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizeDownAndShrinkRange", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_min_handle, TFE_TensorHandle, input_min, nullptr);
  TFE_OpAddInput(op.get(), input_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_max_handle, TFE_TensorHandle, input_max, nullptr);
  TFE_OpAddInput(op.get(), input_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tinput_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_Tinput = TFE_TensorHandleDataType(attr_Tinput_input_handle);
  TFE_OpSetAttrType(op.get(), "Tinput", attr_Tinput);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_requantize(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong input_min, jlong input_max, jlong requested_output_min, jlong requested_output_max, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Requantize", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_min_handle, TFE_TensorHandle, input_min, nullptr);
  TFE_OpAddInput(op.get(), input_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_max_handle, TFE_TensorHandle, input_max, nullptr);
  TFE_OpAddInput(op.get(), input_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(requested_output_min_handle, TFE_TensorHandle, requested_output_min, nullptr);
  TFE_OpAddInput(op.get(), requested_output_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(requested_output_max_handle, TFE_TensorHandle, requested_output_max, nullptr);
  TFE_OpAddInput(op.get(), requested_output_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tinput_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_Tinput = TFE_TensorHandleDataType(attr_Tinput_input_handle);
  TFE_OpSetAttrType(op.get(), "Tinput", attr_Tinput);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_requantizationRange(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong input_min, jlong input_max) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "RequantizationRange", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_min_handle, TFE_TensorHandle, input_min, nullptr);
  TFE_OpAddInput(op.get(), input_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_max_handle, TFE_TensorHandle, input_max, nullptr);
  TFE_OpAddInput(op.get(), input_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tinput_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_Tinput = TFE_TensorHandleDataType(attr_Tinput_input_handle);
  TFE_OpSetAttrType(op.get(), "Tinput", attr_Tinput);

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, JNI_COMMIT);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_Math_00024_compareAndBitpack(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong threshold) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "CompareAndBitpack", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(threshold_handle, TFE_TensorHandle, threshold, 0);
  TFE_OpAddInput(op.get(), threshold_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_threshold_handle, TFE_TensorHandle, threshold, 0);
  const TF_DataType attr_T_threshold = TFE_TensorHandleDataType(attr_T_threshold_handle);
  if (attr_T != attr_T_threshold) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'threshold' of 'compareAndBitpack' op with data type '"
          << attr_T_threshold
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {1});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}
