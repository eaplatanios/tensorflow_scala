/* DO NOT EDIT THIS FILE - it is machine generated */

/* Copyright 2017-18, Emmanouil Antonios Platanios. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#include "tensor_nn_ops.h"
#include "exception.h"
#include "utilities.h"

#include <algorithm>
#include <cstring>
#include <memory>
#include <sstream>

#include "tensorflow/c/c_api.h"
#include "tensorflow/c/eager/c_api.h"

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_biasAdd(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jlong bias, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BiasAdd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_handle, TFE_TensorHandle, value, 0);
  TFE_OpAddInput(op.get(), value_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(bias_handle, TFE_TensorHandle, bias, 0);
  TFE_OpAddInput(op.get(), bias_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_value_handle, TFE_TensorHandle, value, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_bias_handle, TFE_TensorHandle, bias, 0);
  const TF_DataType attr_T_bias = TFE_TensorHandleDataType(attr_T_bias_handle);
  if (attr_T != attr_T_bias) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'bias' of 'biasAdd' op with data type '"
          << attr_T_bias
          << "' must match data type '"
          << attr_T
          << "' of argument 'value'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_relu(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Relu", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_features_handle, TFE_TensorHandle, features, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_features_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_relu6(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Relu6", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_features_handle, TFE_TensorHandle, features, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_features_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_elu(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Elu", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_features_handle, TFE_TensorHandle, features, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_features_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_selu(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Selu", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_features_handle, TFE_TensorHandle, features, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_features_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_softplus(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Softplus", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_features_handle, TFE_TensorHandle, features, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_features_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_softsign(
    JNIEnv* env, jobject object, jlong context_handle, jlong features) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Softsign", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, 0);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_features_handle, TFE_TensorHandle, features, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_features_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_softmax(
    JNIEnv* env, jobject object, jlong context_handle, jlong logits) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Softmax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(logits_handle, TFE_TensorHandle, logits, 0);
  TFE_OpAddInput(op.get(), logits_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_logits_handle, TFE_TensorHandle, logits, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_logits_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_logSoftmax(
    JNIEnv* env, jobject object, jlong context_handle, jlong logits) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LogSoftmax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(logits_handle, TFE_TensorHandle, logits, 0);
  TFE_OpAddInput(op.get(), logits_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_logits_handle, TFE_TensorHandle, logits, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_logits_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_l2Loss(
    JNIEnv* env, jobject object, jlong context_handle, jlong t) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "L2Loss", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(t_handle, TFE_TensorHandle, t, 0);
  TFE_OpAddInput(op.get(), t_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_t_handle, TFE_TensorHandle, t, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_t_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_softmaxCrossEntropyWithLogits(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong labels) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SoftmaxCrossEntropyWithLogits", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(labels_handle, TFE_TensorHandle, labels, nullptr);
  TFE_OpAddInput(op.get(), labels_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_features_handle, TFE_TensorHandle, features, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_features_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_labels_handle, TFE_TensorHandle, labels, nullptr);
  const TF_DataType attr_T_labels = TFE_TensorHandleDataType(attr_T_labels_handle);
  if (attr_T != attr_T_labels) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'labels' of 'softmaxCrossEntropyWithLogits' op with data type '"
          << attr_T_labels
          << "' must match data type '"
          << attr_T
          << "' of argument 'features'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_sparseSoftmaxCrossEntropyWithLogits(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong labels) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "SparseSoftmaxCrossEntropyWithLogits", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(labels_handle, TFE_TensorHandle, labels, nullptr);
  TFE_OpAddInput(op.get(), labels_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tlabels_labels_handle, TFE_TensorHandle, labels, nullptr);
  const TF_DataType attr_Tlabels = TFE_TensorHandleDataType(attr_Tlabels_labels_handle);
  TFE_OpSetAttrType(op.get(), "Tlabels", attr_Tlabels);

  REQUIRE_HANDLE(attr_T_features_handle, TFE_TensorHandle, features, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_features_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_topKV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong k, jboolean sorted) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "TopKV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(k_handle, TFE_TensorHandle, k, nullptr);
  TFE_OpAddInput(op.get(), k_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrBool(op.get(), "sorted", static_cast<unsigned char>(sorted));

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_inTopKV2(
    JNIEnv* env, jobject object, jlong context_handle, jlong predictions, jlong targets, jlong k) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "InTopKV2", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(predictions_handle, TFE_TensorHandle, predictions, 0);
  TFE_OpAddInput(op.get(), predictions_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(targets_handle, TFE_TensorHandle, targets, 0);
  TFE_OpAddInput(op.get(), targets_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(k_handle, TFE_TensorHandle, k, 0);
  TFE_OpAddInput(op.get(), k_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_targets_handle, TFE_TensorHandle, targets, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_targets_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_k_handle, TFE_TensorHandle, k, 0);
  const TF_DataType attr_T_k = TFE_TensorHandleDataType(attr_T_k_handle);
  if (attr_T != attr_T_k) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'k' of 'inTopKV2' op with data type '"
          << attr_T_k
          << "' must match data type '"
          << attr_T
          << "' of argument 'targets'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_avgPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "AvgPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(value_handle, TFE_TensorHandle, value, 0);
  TFE_OpAddInput(op.get(), value_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_value_handle, TFE_TensorHandle, value, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_avgPool3D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "AvgPool3D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_maxPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MaxPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_maxPoolGrad(
    JNIEnv* env, jobject object, jlong context_handle, jlong orig_input, jlong orig_output, jlong grad, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MaxPoolGrad", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(orig_input_handle, TFE_TensorHandle, orig_input, 0);
  TFE_OpAddInput(op.get(), orig_input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(orig_output_handle, TFE_TensorHandle, orig_output, 0);
  TFE_OpAddInput(op.get(), orig_output_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(grad_handle, TFE_TensorHandle, grad, 0);
  TFE_OpAddInput(op.get(), grad_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_orig_input_handle, TFE_TensorHandle, orig_input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_orig_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_orig_output_handle, TFE_TensorHandle, orig_output, 0);
  const TF_DataType attr_T_orig_output = TFE_TensorHandleDataType(attr_T_orig_output_handle);
  if (attr_T != attr_T_orig_output) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'orig_output' of 'maxPoolGrad' op with data type '"
          << attr_T_orig_output
          << "' must match data type '"
          << attr_T
          << "' of argument 'orig_input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_grad_handle, TFE_TensorHandle, grad, 0);
  const TF_DataType attr_T_grad = TFE_TensorHandleDataType(attr_T_grad_handle);
  if (attr_T != attr_T_grad) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'grad' of 'maxPoolGrad' op with data type '"
          << attr_T_grad
          << "' must match data type '"
          << attr_T
          << "' of argument 'orig_input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_maxPoolGradGrad(
    JNIEnv* env, jobject object, jlong context_handle, jlong orig_input, jlong orig_output, jlong grad, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MaxPoolGradGrad", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(orig_input_handle, TFE_TensorHandle, orig_input, 0);
  TFE_OpAddInput(op.get(), orig_input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(orig_output_handle, TFE_TensorHandle, orig_output, 0);
  TFE_OpAddInput(op.get(), orig_output_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(grad_handle, TFE_TensorHandle, grad, 0);
  TFE_OpAddInput(op.get(), grad_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_orig_input_handle, TFE_TensorHandle, orig_input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_orig_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_orig_output_handle, TFE_TensorHandle, orig_output, 0);
  const TF_DataType attr_T_orig_output = TFE_TensorHandleDataType(attr_T_orig_output_handle);
  if (attr_T != attr_T_orig_output) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'orig_output' of 'maxPoolGradGrad' op with data type '"
          << attr_T_orig_output
          << "' must match data type '"
          << attr_T
          << "' of argument 'orig_input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_grad_handle, TFE_TensorHandle, grad, 0);
  const TF_DataType attr_T_grad = TFE_TensorHandleDataType(attr_T_grad_handle);
  if (attr_T != attr_T_grad) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'grad' of 'maxPoolGradGrad' op with data type '"
          << attr_T_grad
          << "' must match data type '"
          << attr_T
          << "' of argument 'orig_input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_maxPool3D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray ksize, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MaxPool3D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_maxPoolWithArgmax(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlongArray ksize, jlongArray strides, jbyteArray padding, jint targmax) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "MaxPoolWithArgmax", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrType(op.get(), "Targmax", static_cast<TF_DataType>(targmax));

  const int num_outputs = 2;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fractionalAvgPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jfloatArray pooling_ratio, jboolean pseudo_random, jboolean overlapping, jboolean deterministic, jlong seed, jlong seed2) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FractionalAvgPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_value_handle, TFE_TensorHandle, value, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int pooling_ratio_n = env->GetArrayLength(pooling_ratio);
  std::unique_ptr<float[]> pooling_ratio_c_value(new float[pooling_ratio_n]);
  jfloat* pooling_ratio_elems = env->GetFloatArrayElements(pooling_ratio, nullptr);
  for (int i = 0; i < pooling_ratio_n; ++i) {
    pooling_ratio_c_value[i] = static_cast<float>(pooling_ratio_elems[i]);
  }
  TFE_OpSetAttrFloatList(op.get(), "pooling_ratio", pooling_ratio_c_value.get(), pooling_ratio_n);
  env->ReleaseFloatArrayElements(pooling_ratio, pooling_ratio_elems, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "pseudo_random", static_cast<unsigned char>(pseudo_random));

  TFE_OpSetAttrBool(op.get(), "overlapping", static_cast<unsigned char>(overlapping));

  TFE_OpSetAttrBool(op.get(), "deterministic", static_cast<unsigned char>(deterministic));

  TFE_OpSetAttrInt(op.get(), "seed", static_cast<int64_t>(seed));

  TFE_OpSetAttrInt(op.get(), "seed2", static_cast<int64_t>(seed2));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fractionalMaxPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong value, jfloatArray pooling_ratio, jboolean pseudo_random, jboolean overlapping, jboolean deterministic, jlong seed, jlong seed2) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FractionalMaxPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(value_handle, TFE_TensorHandle, value, nullptr);
  TFE_OpAddInput(op.get(), value_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_value_handle, TFE_TensorHandle, value, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_value_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int pooling_ratio_n = env->GetArrayLength(pooling_ratio);
  std::unique_ptr<float[]> pooling_ratio_c_value(new float[pooling_ratio_n]);
  jfloat* pooling_ratio_elems = env->GetFloatArrayElements(pooling_ratio, nullptr);
  for (int i = 0; i < pooling_ratio_n; ++i) {
    pooling_ratio_c_value[i] = static_cast<float>(pooling_ratio_elems[i]);
  }
  TFE_OpSetAttrFloatList(op.get(), "pooling_ratio", pooling_ratio_c_value.get(), pooling_ratio_n);
  env->ReleaseFloatArrayElements(pooling_ratio, pooling_ratio_elems, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "pseudo_random", static_cast<unsigned char>(pseudo_random));

  TFE_OpSetAttrBool(op.get(), "overlapping", static_cast<unsigned char>(overlapping));

  TFE_OpSetAttrBool(op.get(), "deterministic", static_cast<unsigned char>(deterministic));

  TFE_OpSetAttrInt(op.get(), "seed", static_cast<int64_t>(seed));

  TFE_OpSetAttrInt(op.get(), "seed2", static_cast<int64_t>(seed2));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_conv2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlongArray strides, jbyteArray padding, jboolean use_cudnn_on_gpu, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Conv2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_filter_handle, TFE_TensorHandle, filter, 0);
  const TF_DataType attr_T_filter = TFE_TensorHandleDataType(attr_T_filter_handle);
  if (attr_T != attr_T_filter) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'conv2D' op with data type '"
          << attr_T_filter
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "use_cudnn_on_gpu", static_cast<unsigned char>(use_cudnn_on_gpu));

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_conv2DBackpropInput(
    JNIEnv* env, jobject object, jlong context_handle, jlong input_sizes, jlong filter, jlong out_backprop, jlongArray strides, jbyteArray padding, jboolean use_cudnn_on_gpu, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Conv2DBackpropInput", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_sizes_handle, TFE_TensorHandle, input_sizes, 0);
  TFE_OpAddInput(op.get(), input_sizes_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(out_backprop_handle, TFE_TensorHandle, out_backprop, 0);
  TFE_OpAddInput(op.get(), out_backprop_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_filter_handle, TFE_TensorHandle, filter, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_filter_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_out_backprop_handle, TFE_TensorHandle, out_backprop, 0);
  const TF_DataType attr_T_out_backprop = TFE_TensorHandleDataType(attr_T_out_backprop_handle);
  if (attr_T != attr_T_out_backprop) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'out_backprop' of 'conv2DBackpropInput' op with data type '"
          << attr_T_out_backprop
          << "' must match data type '"
          << attr_T
          << "' of argument 'filter'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "use_cudnn_on_gpu", static_cast<unsigned char>(use_cudnn_on_gpu));

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_conv2DBackpropFilter(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter_sizes, jlong out_backprop, jlongArray strides, jbyteArray padding, jboolean use_cudnn_on_gpu, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Conv2DBackpropFilter", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_sizes_handle, TFE_TensorHandle, filter_sizes, 0);
  TFE_OpAddInput(op.get(), filter_sizes_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(out_backprop_handle, TFE_TensorHandle, out_backprop, 0);
  TFE_OpAddInput(op.get(), out_backprop_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_out_backprop_handle, TFE_TensorHandle, out_backprop, 0);
  const TF_DataType attr_T_out_backprop = TFE_TensorHandleDataType(attr_T_out_backprop_handle);
  if (attr_T != attr_T_out_backprop) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'out_backprop' of 'conv2DBackpropFilter' op with data type '"
          << attr_T_out_backprop
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "use_cudnn_on_gpu", static_cast<unsigned char>(use_cudnn_on_gpu));

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fusedResizeAndPadConv2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong size, jlong paddings, jlong filter, jbyteArray mode, jlongArray strides, jbyteArray padding, jboolean resize_align_corners) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FusedResizeAndPadConv2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(size_handle, TFE_TensorHandle, size, 0);
  TFE_OpAddInput(op.get(), size_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_filter_handle, TFE_TensorHandle, filter, 0);
  const TF_DataType attr_T_filter = TFE_TensorHandleDataType(attr_T_filter_handle);
  if (attr_T != attr_T_filter) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'fusedResizeAndPadConv2D' op with data type '"
          << attr_T_filter
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  jbyte *mode_c_value = env->GetByteArrayElements(mode, nullptr);
  TFE_OpSetAttrString(op.get(), "mode", reinterpret_cast<const char *>(mode_c_value));
  env->ReleaseByteArrayElements(mode, mode_c_value, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "resize_align_corners", static_cast<unsigned char>(resize_align_corners));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fusedPadConv2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong paddings, jlong filter, jbyteArray mode, jlongArray strides, jbyteArray padding) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FusedPadConv2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(paddings_handle, TFE_TensorHandle, paddings, 0);
  TFE_OpAddInput(op.get(), paddings_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_filter_handle, TFE_TensorHandle, filter, 0);
  const TF_DataType attr_T_filter = TFE_TensorHandleDataType(attr_T_filter_handle);
  if (attr_T != attr_T_filter) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'fusedPadConv2D' op with data type '"
          << attr_T_filter
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  jbyte *mode_c_value = env->GetByteArrayElements(mode, nullptr);
  TFE_OpSetAttrString(op.get(), "mode", reinterpret_cast<const char *>(mode_c_value));
  env->ReleaseByteArrayElements(mode, mode_c_value, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_depthwiseConv2dNative(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "DepthwiseConv2dNative", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_filter_handle, TFE_TensorHandle, filter, 0);
  const TF_DataType attr_T_filter = TFE_TensorHandleDataType(attr_T_filter_handle);
  if (attr_T != attr_T_filter) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'depthwiseConv2dNative' op with data type '"
          << attr_T_filter
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_conv3D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlongArray strides, jbyteArray padding, jbyteArray data_format) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Conv3D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_filter_handle, TFE_TensorHandle, filter, 0);
  const TF_DataType attr_T_filter = TFE_TensorHandleDataType(attr_T_filter_handle);
  if (attr_T != attr_T_filter) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'conv3D' op with data type '"
          << attr_T_filter
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_dilation2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlongArray strides, jlongArray rates, jbyteArray padding) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "Dilation2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(filter_handle, TFE_TensorHandle, filter, 0);
  TFE_OpAddInput(op.get(), filter_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_filter_handle, TFE_TensorHandle, filter, 0);
  const TF_DataType attr_T_filter = TFE_TensorHandleDataType(attr_T_filter_handle);
  if (attr_T != attr_T_filter) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'filter' of 'dilation2D' op with data type '"
          << attr_T_filter
          << "' must match data type '"
          << attr_T
          << "' of argument 'input'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  const int rates_n = env->GetArrayLength(rates);
  std::unique_ptr<int64_t[]> rates_c_value(new int64_t[rates_n]);
  jlong* rates_elems = env->GetLongArrayElements(rates, nullptr);
  for (int i = 0; i < rates_n; ++i) {
    rates_c_value[i] = static_cast<int64_t>(rates_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "rates", rates_c_value.get(), rates_n);
  env->ReleaseLongArrayElements(rates, rates_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_lRN(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong depth_radius, jfloat bias, jfloat alpha, jfloat beta) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "LRN", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, 0);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  TFE_OpSetAttrInt(op.get(), "depth_radius", static_cast<int64_t>(depth_radius));

  TFE_OpSetAttrFloat(op.get(), "bias", static_cast<float>(bias));

  TFE_OpSetAttrFloat(op.get(), "alpha", static_cast<float>(alpha));

  TFE_OpSetAttrFloat(op.get(), "beta", static_cast<float>(beta));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlong JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_batchNormWithGlobalNormalization(
    JNIEnv* env, jobject object, jlong context_handle, jlong t, jlong m, jlong v, jlong beta, jlong gamma, jfloat variance_epsilon, jboolean scale_after_normalization) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, 0);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "BatchNormWithGlobalNormalization", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(t_handle, TFE_TensorHandle, t, 0);
  TFE_OpAddInput(op.get(), t_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(m_handle, TFE_TensorHandle, m, 0);
  TFE_OpAddInput(op.get(), m_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(v_handle, TFE_TensorHandle, v, 0);
  TFE_OpAddInput(op.get(), v_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(beta_handle, TFE_TensorHandle, beta, 0);
  TFE_OpAddInput(op.get(), beta_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(gamma_handle, TFE_TensorHandle, gamma, 0);
  TFE_OpAddInput(op.get(), gamma_handle, status.get());
  CHECK_STATUS(env, status.get(), 0);

  REQUIRE_HANDLE(attr_T_t_handle, TFE_TensorHandle, t, 0);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_t_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_m_handle, TFE_TensorHandle, m, 0);
  const TF_DataType attr_T_m = TFE_TensorHandleDataType(attr_T_m_handle);
  if (attr_T != attr_T_m) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'm' of 'batchNormWithGlobalNormalization' op with data type '"
          << attr_T_m
          << "' must match data type '"
          << attr_T
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_v_handle, TFE_TensorHandle, v, 0);
  const TF_DataType attr_T_v = TFE_TensorHandleDataType(attr_T_v_handle);
  if (attr_T != attr_T_v) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'v' of 'batchNormWithGlobalNormalization' op with data type '"
          << attr_T_v
          << "' must match data type '"
          << attr_T
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_beta_handle, TFE_TensorHandle, beta, 0);
  const TF_DataType attr_T_beta = TFE_TensorHandleDataType(attr_T_beta_handle);
  if (attr_T != attr_T_beta) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'beta' of 'batchNormWithGlobalNormalization' op with data type '"
          << attr_T_beta
          << "' must match data type '"
          << attr_T
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_gamma_handle, TFE_TensorHandle, gamma, 0);
  const TF_DataType attr_T_gamma = TFE_TensorHandleDataType(attr_T_gamma_handle);
  if (attr_T != attr_T_gamma) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'gamma' of 'batchNormWithGlobalNormalization' op with data type '"
          << attr_T_gamma
          << "' must match data type '"
          << attr_T
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrFloat(op.get(), "variance_epsilon", static_cast<float>(variance_epsilon));

  TFE_OpSetAttrBool(op.get(), "scale_after_normalization", static_cast<unsigned char>(scale_after_normalization));

  const int num_outputs = 1;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), 0);

  return reinterpret_cast<jlong>(outputs[0]);
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_fusedBatchNorm(
    JNIEnv* env, jobject object, jlong context_handle, jlong x, jlong scale, jlong offset, jlong mean, jlong variance, jfloat epsilon, jbyteArray data_format, jboolean is_training) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "FusedBatchNorm", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(x_handle, TFE_TensorHandle, x, nullptr);
  TFE_OpAddInput(op.get(), x_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(scale_handle, TFE_TensorHandle, scale, nullptr);
  TFE_OpAddInput(op.get(), scale_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(offset_handle, TFE_TensorHandle, offset, nullptr);
  TFE_OpAddInput(op.get(), offset_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(mean_handle, TFE_TensorHandle, mean, nullptr);
  TFE_OpAddInput(op.get(), mean_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(variance_handle, TFE_TensorHandle, variance, nullptr);
  TFE_OpAddInput(op.get(), variance_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_x_handle, TFE_TensorHandle, x, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_x_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  REQUIRE_HANDLE(attr_T_scale_handle, TFE_TensorHandle, scale, nullptr);
  const TF_DataType attr_T_scale = TFE_TensorHandleDataType(attr_T_scale_handle);
  if (attr_T != attr_T_scale) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'scale' of 'fusedBatchNorm' op with data type '"
          << attr_T_scale
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_offset_handle, TFE_TensorHandle, offset, nullptr);
  const TF_DataType attr_T_offset = TFE_TensorHandleDataType(attr_T_offset_handle);
  if (attr_T != attr_T_offset) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'offset' of 'fusedBatchNorm' op with data type '"
          << attr_T_offset
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_mean_handle, TFE_TensorHandle, mean, nullptr);
  const TF_DataType attr_T_mean = TFE_TensorHandleDataType(attr_T_mean_handle);
  if (attr_T != attr_T_mean) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'mean' of 'fusedBatchNorm' op with data type '"
          << attr_T_mean
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_T_variance_handle, TFE_TensorHandle, variance, nullptr);
  const TF_DataType attr_T_variance = TFE_TensorHandleDataType(attr_T_variance_handle);
  if (attr_T != attr_T_variance) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'variance' of 'fusedBatchNorm' op with data type '"
          << attr_T_variance
          << "' must match data type '"
          << attr_T
          << "' of argument 'x'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrFloat(op.get(), "epsilon", static_cast<float>(epsilon));

  jbyte *data_format_c_value = env->GetByteArrayElements(data_format, nullptr);
  TFE_OpSetAttrString(op.get(), "data_format", reinterpret_cast<const char *>(data_format_c_value));
  env->ReleaseByteArrayElements(data_format, data_format_c_value, JNI_ABORT);

  TFE_OpSetAttrBool(op.get(), "is_training", static_cast<unsigned char>(is_training));

  const int num_outputs = 5;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedBiasAdd(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong bias, jlong min_input, jlong max_input, jlong min_bias, jlong max_bias, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedBiasAdd", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(bias_handle, TFE_TensorHandle, bias, nullptr);
  TFE_OpAddInput(op.get(), bias_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_input_handle, TFE_TensorHandle, min_input, nullptr);
  TFE_OpAddInput(op.get(), min_input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_input_handle, TFE_TensorHandle, max_input, nullptr);
  TFE_OpAddInput(op.get(), max_input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_bias_handle, TFE_TensorHandle, min_bias, nullptr);
  TFE_OpAddInput(op.get(), min_bias_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_bias_handle, TFE_TensorHandle, max_bias, nullptr);
  TFE_OpAddInput(op.get(), max_bias_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T2_bias_handle, TFE_TensorHandle, bias, nullptr);
  const TF_DataType attr_T2 = TFE_TensorHandleDataType(attr_T2_bias_handle);
  TFE_OpSetAttrType(op.get(), "T2", attr_T2);

  REQUIRE_HANDLE(attr_T1_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_T1 = TFE_TensorHandleDataType(attr_T1_input_handle);
  TFE_OpSetAttrType(op.get(), "T1", attr_T1);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedRelu(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong min_features, jlong max_features, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedRelu", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_features_handle, TFE_TensorHandle, min_features, nullptr);
  TFE_OpAddInput(op.get(), min_features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_features_handle, TFE_TensorHandle, max_features, nullptr);
  TFE_OpAddInput(op.get(), max_features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tinput_features_handle, TFE_TensorHandle, features, nullptr);
  const TF_DataType attr_Tinput = TFE_TensorHandleDataType(attr_Tinput_features_handle);
  TFE_OpSetAttrType(op.get(), "Tinput", attr_Tinput);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedRelu6(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong min_features, jlong max_features, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedRelu6", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_features_handle, TFE_TensorHandle, min_features, nullptr);
  TFE_OpAddInput(op.get(), min_features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_features_handle, TFE_TensorHandle, max_features, nullptr);
  TFE_OpAddInput(op.get(), max_features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tinput_features_handle, TFE_TensorHandle, features, nullptr);
  const TF_DataType attr_Tinput = TFE_TensorHandleDataType(attr_Tinput_features_handle);
  TFE_OpSetAttrType(op.get(), "Tinput", attr_Tinput);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedReluX(
    JNIEnv* env, jobject object, jlong context_handle, jlong features, jlong max_value, jlong min_features, jlong max_features, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedReluX", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(features_handle, TFE_TensorHandle, features, nullptr);
  TFE_OpAddInput(op.get(), features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_value_handle, TFE_TensorHandle, max_value, nullptr);
  TFE_OpAddInput(op.get(), max_value_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_features_handle, TFE_TensorHandle, min_features, nullptr);
  TFE_OpAddInput(op.get(), min_features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_features_handle, TFE_TensorHandle, max_features, nullptr);
  TFE_OpAddInput(op.get(), max_features_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tinput_features_handle, TFE_TensorHandle, features, nullptr);
  const TF_DataType attr_Tinput = TFE_TensorHandleDataType(attr_Tinput_features_handle);
  TFE_OpSetAttrType(op.get(), "Tinput", attr_Tinput);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedAvgPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong min_input, jlong max_input, jlongArray ksize, jlongArray strides, jbyteArray padding) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedAvgPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_input_handle, TFE_TensorHandle, min_input, nullptr);
  TFE_OpAddInput(op.get(), min_input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_input_handle, TFE_TensorHandle, max_input, nullptr);
  TFE_OpAddInput(op.get(), max_input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedMaxPool(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong min_input, jlong max_input, jlongArray ksize, jlongArray strides, jbyteArray padding) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedMaxPool", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_input_handle, TFE_TensorHandle, min_input, nullptr);
  TFE_OpAddInput(op.get(), min_input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_input_handle, TFE_TensorHandle, max_input, nullptr);
  TFE_OpAddInput(op.get(), max_input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_T_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_T = TFE_TensorHandleDataType(attr_T_input_handle);
  TFE_OpSetAttrType(op.get(), "T", attr_T);

  const int ksize_n = env->GetArrayLength(ksize);
  std::unique_ptr<int64_t[]> ksize_c_value(new int64_t[ksize_n]);
  jlong* ksize_elems = env->GetLongArrayElements(ksize, nullptr);
  for (int i = 0; i < ksize_n; ++i) {
    ksize_c_value[i] = static_cast<int64_t>(ksize_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "ksize", ksize_c_value.get(), ksize_n);
  env->ReleaseLongArrayElements(ksize, ksize_elems, JNI_ABORT);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedConv2D(
    JNIEnv* env, jobject object, jlong context_handle, jlong input, jlong filter, jlong min_input, jlong max_input, jlong min_filter, jlong max_filter, jlongArray strides, jbyteArray padding, jint out_type) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedConv2D", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(input_handle, TFE_TensorHandle, input, nullptr);
  TFE_OpAddInput(op.get(), input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(filter_handle, TFE_TensorHandle, filter, nullptr);
  TFE_OpAddInput(op.get(), filter_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_input_handle, TFE_TensorHandle, min_input, nullptr);
  TFE_OpAddInput(op.get(), min_input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_input_handle, TFE_TensorHandle, max_input, nullptr);
  TFE_OpAddInput(op.get(), max_input_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(min_filter_handle, TFE_TensorHandle, min_filter, nullptr);
  TFE_OpAddInput(op.get(), min_filter_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(max_filter_handle, TFE_TensorHandle, max_filter, nullptr);
  TFE_OpAddInput(op.get(), max_filter_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tfilter_filter_handle, TFE_TensorHandle, filter, nullptr);
  const TF_DataType attr_Tfilter = TFE_TensorHandleDataType(attr_Tfilter_filter_handle);
  TFE_OpSetAttrType(op.get(), "Tfilter", attr_Tfilter);

  REQUIRE_HANDLE(attr_Tinput_input_handle, TFE_TensorHandle, input, nullptr);
  const TF_DataType attr_Tinput = TFE_TensorHandleDataType(attr_Tinput_input_handle);
  TFE_OpSetAttrType(op.get(), "Tinput", attr_Tinput);

  const int strides_n = env->GetArrayLength(strides);
  std::unique_ptr<int64_t[]> strides_c_value(new int64_t[strides_n]);
  jlong* strides_elems = env->GetLongArrayElements(strides, nullptr);
  for (int i = 0; i < strides_n; ++i) {
    strides_c_value[i] = static_cast<int64_t>(strides_elems[i]);
  }
  TFE_OpSetAttrIntList(op.get(), "strides", strides_c_value.get(), strides_n);
  env->ReleaseLongArrayElements(strides, strides_elems, JNI_ABORT);

  jbyte *padding_c_value = env->GetByteArrayElements(padding, nullptr);
  TFE_OpSetAttrString(op.get(), "padding", reinterpret_cast<const char *>(padding_c_value));
  env->ReleaseByteArrayElements(padding, padding_c_value, JNI_ABORT);

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}

JNIEXPORT jlongArray JNICALL Java_org_platanios_tensorflow_jni_generated_tensors_NN_00024_quantizedBatchNormWithGlobalNormalization(
    JNIEnv* env, jobject object, jlong context_handle, jlong t, jlong t_min, jlong t_max, jlong m, jlong m_min, jlong m_max, jlong v, jlong v_min, jlong v_max, jlong beta, jlong beta_min, jlong beta_max, jlong gamma, jlong gamma_min, jlong gamma_max, jint out_type, jfloat variance_epsilon, jboolean scale_after_normalization) {
  REQUIRE_HANDLE(context, TFE_Context, context_handle, nullptr);
  std::unique_ptr<TF_Status, decltype(&TF_DeleteStatus)> status(TF_NewStatus(), TF_DeleteStatus);

  std::unique_ptr<TFE_Op, decltype(&TFE_DeleteOp)> op(
      TFE_NewOp(context, "QuantizedBatchNormWithGlobalNormalization", status.get()), TFE_DeleteOp);
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(t_handle, TFE_TensorHandle, t, nullptr);
  TFE_OpAddInput(op.get(), t_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(t_min_handle, TFE_TensorHandle, t_min, nullptr);
  TFE_OpAddInput(op.get(), t_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(t_max_handle, TFE_TensorHandle, t_max, nullptr);
  TFE_OpAddInput(op.get(), t_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(m_handle, TFE_TensorHandle, m, nullptr);
  TFE_OpAddInput(op.get(), m_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(m_min_handle, TFE_TensorHandle, m_min, nullptr);
  TFE_OpAddInput(op.get(), m_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(m_max_handle, TFE_TensorHandle, m_max, nullptr);
  TFE_OpAddInput(op.get(), m_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(v_handle, TFE_TensorHandle, v, nullptr);
  TFE_OpAddInput(op.get(), v_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(v_min_handle, TFE_TensorHandle, v_min, nullptr);
  TFE_OpAddInput(op.get(), v_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(v_max_handle, TFE_TensorHandle, v_max, nullptr);
  TFE_OpAddInput(op.get(), v_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(beta_handle, TFE_TensorHandle, beta, nullptr);
  TFE_OpAddInput(op.get(), beta_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(beta_min_handle, TFE_TensorHandle, beta_min, nullptr);
  TFE_OpAddInput(op.get(), beta_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(beta_max_handle, TFE_TensorHandle, beta_max, nullptr);
  TFE_OpAddInput(op.get(), beta_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(gamma_handle, TFE_TensorHandle, gamma, nullptr);
  TFE_OpAddInput(op.get(), gamma_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(gamma_min_handle, TFE_TensorHandle, gamma_min, nullptr);
  TFE_OpAddInput(op.get(), gamma_min_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(gamma_max_handle, TFE_TensorHandle, gamma_max, nullptr);
  TFE_OpAddInput(op.get(), gamma_max_handle, status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  REQUIRE_HANDLE(attr_Tinput_t_handle, TFE_TensorHandle, t, nullptr);
  const TF_DataType attr_Tinput = TFE_TensorHandleDataType(attr_Tinput_t_handle);
  TFE_OpSetAttrType(op.get(), "Tinput", attr_Tinput);

  REQUIRE_HANDLE(attr_Tinput_m_handle, TFE_TensorHandle, m, nullptr);
  const TF_DataType attr_Tinput_m = TFE_TensorHandleDataType(attr_Tinput_m_handle);
  if (attr_Tinput != attr_Tinput_m) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'm' of 'quantizedBatchNormWithGlobalNormalization' op with data type '"
          << attr_Tinput_m
          << "' must match data type '"
          << attr_Tinput
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_Tinput_v_handle, TFE_TensorHandle, v, nullptr);
  const TF_DataType attr_Tinput_v = TFE_TensorHandleDataType(attr_Tinput_v_handle);
  if (attr_Tinput != attr_Tinput_v) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'v' of 'quantizedBatchNormWithGlobalNormalization' op with data type '"
          << attr_Tinput_v
          << "' must match data type '"
          << attr_Tinput
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_Tinput_beta_handle, TFE_TensorHandle, beta, nullptr);
  const TF_DataType attr_Tinput_beta = TFE_TensorHandleDataType(attr_Tinput_beta_handle);
  if (attr_Tinput != attr_Tinput_beta) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'beta' of 'quantizedBatchNormWithGlobalNormalization' op with data type '"
          << attr_Tinput_beta
          << "' must match data type '"
          << attr_Tinput
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  REQUIRE_HANDLE(attr_Tinput_gamma_handle, TFE_TensorHandle, gamma, nullptr);
  const TF_DataType attr_Tinput_gamma = TFE_TensorHandleDataType(attr_Tinput_gamma_handle);
  if (attr_Tinput != attr_Tinput_gamma) {
      std::stringstream error_msg;
      error_msg
          << "Argument 'gamma' of 'quantizedBatchNormWithGlobalNormalization' op with data type '"
          << attr_Tinput_gamma
          << "' must match data type '"
          << attr_Tinput
          << "' of argument 't'";
      throw_exception(env, tf_invalid_argument_exception, error_msg.str().c_str());
  }

  TFE_OpSetAttrType(op.get(), "out_type", static_cast<TF_DataType>(out_type));

  TFE_OpSetAttrFloat(op.get(), "variance_epsilon", static_cast<float>(variance_epsilon));

  TFE_OpSetAttrBool(op.get(), "scale_after_normalization", static_cast<unsigned char>(scale_after_normalization));

  const int num_outputs = 3;
  std::unique_ptr<TFE_TensorHandle* []> outputs(new TFE_TensorHandle* [num_outputs]);
  std::unique_ptr<int[]> actual_num_outputs(new int[1] {num_outputs});
  TFE_Execute(op.get(), outputs.get(), actual_num_outputs.get(), status.get());
  CHECK_STATUS(env, status.get(), nullptr);

  jlongArray outputs_array = env->NewLongArray(static_cast<jsize>(num_outputs));
  jlong* output_elems = env->GetLongArrayElements(outputs_array, nullptr);
  for (int i = 0; i < num_outputs; ++i) {
    output_elems[i] = reinterpret_cast<jlong>(outputs[i]);
  }
  env->ReleaseLongArrayElements(outputs_array, output_elems, 0);
  return outputs_array;
}
