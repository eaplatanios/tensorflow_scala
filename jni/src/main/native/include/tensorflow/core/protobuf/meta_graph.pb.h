// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/meta_graph.proto

#ifndef PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto__INCLUDED
#define PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/framework/op_def.pb.h"
#include "tensorflow/core/framework/tensor_shape.pb.h"
#include "tensorflow/core/framework/types.pb.h"
#include "tensorflow/core/protobuf/saver.pb.h"
// @@protoc_insertion_point(includes)
namespace tensorflow {
class AssetFileDef;
class AssetFileDefDefaultTypeInternal;
extern AssetFileDefDefaultTypeInternal _AssetFileDef_default_instance_;
class CollectionDef;
class CollectionDefDefaultTypeInternal;
extern CollectionDefDefaultTypeInternal _CollectionDef_default_instance_;
class CollectionDef_AnyList;
class CollectionDef_AnyListDefaultTypeInternal;
extern CollectionDef_AnyListDefaultTypeInternal _CollectionDef_AnyList_default_instance_;
class CollectionDef_BytesList;
class CollectionDef_BytesListDefaultTypeInternal;
extern CollectionDef_BytesListDefaultTypeInternal _CollectionDef_BytesList_default_instance_;
class CollectionDef_FloatList;
class CollectionDef_FloatListDefaultTypeInternal;
extern CollectionDef_FloatListDefaultTypeInternal _CollectionDef_FloatList_default_instance_;
class CollectionDef_Int64List;
class CollectionDef_Int64ListDefaultTypeInternal;
extern CollectionDef_Int64ListDefaultTypeInternal _CollectionDef_Int64List_default_instance_;
class CollectionDef_NodeList;
class CollectionDef_NodeListDefaultTypeInternal;
extern CollectionDef_NodeListDefaultTypeInternal _CollectionDef_NodeList_default_instance_;
class MetaGraphDef;
class MetaGraphDefDefaultTypeInternal;
extern MetaGraphDefDefaultTypeInternal _MetaGraphDef_default_instance_;
class MetaGraphDef_CollectionDefEntry;
class MetaGraphDef_CollectionDefEntryDefaultTypeInternal;
extern MetaGraphDef_CollectionDefEntryDefaultTypeInternal _MetaGraphDef_CollectionDefEntry_default_instance_;
class MetaGraphDef_MetaInfoDef;
class MetaGraphDef_MetaInfoDefDefaultTypeInternal;
extern MetaGraphDef_MetaInfoDefDefaultTypeInternal _MetaGraphDef_MetaInfoDef_default_instance_;
class MetaGraphDef_SignatureDefEntry;
class MetaGraphDef_SignatureDefEntryDefaultTypeInternal;
extern MetaGraphDef_SignatureDefEntryDefaultTypeInternal _MetaGraphDef_SignatureDefEntry_default_instance_;
class SignatureDef;
class SignatureDefDefaultTypeInternal;
extern SignatureDefDefaultTypeInternal _SignatureDef_default_instance_;
class SignatureDef_InputsEntry;
class SignatureDef_InputsEntryDefaultTypeInternal;
extern SignatureDef_InputsEntryDefaultTypeInternal _SignatureDef_InputsEntry_default_instance_;
class SignatureDef_OutputsEntry;
class SignatureDef_OutputsEntryDefaultTypeInternal;
extern SignatureDef_OutputsEntryDefaultTypeInternal _SignatureDef_OutputsEntry_default_instance_;
class TensorInfo;
class TensorInfoDefaultTypeInternal;
extern TensorInfoDefaultTypeInternal _TensorInfo_default_instance_;
class TensorInfo_CooSparse;
class TensorInfo_CooSparseDefaultTypeInternal;
extern TensorInfo_CooSparseDefaultTypeInternal _TensorInfo_CooSparse_default_instance_;
}  // namespace tensorflow

namespace tensorflow {

namespace protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto

// ===================================================================

class MetaGraphDef_MetaInfoDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.MetaGraphDef.MetaInfoDef) */ {
 public:
  MetaGraphDef_MetaInfoDef();
  virtual ~MetaGraphDef_MetaInfoDef();

  MetaGraphDef_MetaInfoDef(const MetaGraphDef_MetaInfoDef& from);

  inline MetaGraphDef_MetaInfoDef& operator=(const MetaGraphDef_MetaInfoDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaGraphDef_MetaInfoDef(MetaGraphDef_MetaInfoDef&& from) noexcept
    : MetaGraphDef_MetaInfoDef() {
    *this = ::std::move(from);
  }

  inline MetaGraphDef_MetaInfoDef& operator=(MetaGraphDef_MetaInfoDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaGraphDef_MetaInfoDef& default_instance();

  static inline const MetaGraphDef_MetaInfoDef* internal_default_instance() {
    return reinterpret_cast<const MetaGraphDef_MetaInfoDef*>(
               &_MetaGraphDef_MetaInfoDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(MetaGraphDef_MetaInfoDef* other);
  void Swap(MetaGraphDef_MetaInfoDef* other);
  friend void swap(MetaGraphDef_MetaInfoDef& a, MetaGraphDef_MetaInfoDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaGraphDef_MetaInfoDef* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaGraphDef_MetaInfoDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MetaGraphDef_MetaInfoDef& from);
  void MergeFrom(const MetaGraphDef_MetaInfoDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MetaGraphDef_MetaInfoDef* other);
  protected:
  explicit MetaGraphDef_MetaInfoDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 4;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 4;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // string meta_graph_version = 1;
  void clear_meta_graph_version();
  static const int kMetaGraphVersionFieldNumber = 1;
  const ::std::string& meta_graph_version() const;
  void set_meta_graph_version(const ::std::string& value);
  #if LANG_CXX11
  void set_meta_graph_version(::std::string&& value);
  #endif
  void set_meta_graph_version(const char* value);
  void set_meta_graph_version(const char* value, size_t size);
  ::std::string* mutable_meta_graph_version();
  ::std::string* release_meta_graph_version();
  void set_allocated_meta_graph_version(::std::string* meta_graph_version);
  ::std::string* unsafe_arena_release_meta_graph_version();
  void unsafe_arena_set_allocated_meta_graph_version(
      ::std::string* meta_graph_version);

  // string tensorflow_version = 5;
  void clear_tensorflow_version();
  static const int kTensorflowVersionFieldNumber = 5;
  const ::std::string& tensorflow_version() const;
  void set_tensorflow_version(const ::std::string& value);
  #if LANG_CXX11
  void set_tensorflow_version(::std::string&& value);
  #endif
  void set_tensorflow_version(const char* value);
  void set_tensorflow_version(const char* value, size_t size);
  ::std::string* mutable_tensorflow_version();
  ::std::string* release_tensorflow_version();
  void set_allocated_tensorflow_version(::std::string* tensorflow_version);
  ::std::string* unsafe_arena_release_tensorflow_version();
  void unsafe_arena_set_allocated_tensorflow_version(
      ::std::string* tensorflow_version);

  // string tensorflow_git_version = 6;
  void clear_tensorflow_git_version();
  static const int kTensorflowGitVersionFieldNumber = 6;
  const ::std::string& tensorflow_git_version() const;
  void set_tensorflow_git_version(const ::std::string& value);
  #if LANG_CXX11
  void set_tensorflow_git_version(::std::string&& value);
  #endif
  void set_tensorflow_git_version(const char* value);
  void set_tensorflow_git_version(const char* value, size_t size);
  ::std::string* mutable_tensorflow_git_version();
  ::std::string* release_tensorflow_git_version();
  void set_allocated_tensorflow_git_version(::std::string* tensorflow_git_version);
  ::std::string* unsafe_arena_release_tensorflow_git_version();
  void unsafe_arena_set_allocated_tensorflow_git_version(
      ::std::string* tensorflow_git_version);

  // .tensorflow.OpList stripped_op_list = 2;
  bool has_stripped_op_list() const;
  void clear_stripped_op_list();
  static const int kStrippedOpListFieldNumber = 2;
  private:
  void _slow_mutable_stripped_op_list();
  void _slow_set_allocated_stripped_op_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::OpList** stripped_op_list);
  ::tensorflow::OpList* _slow_release_stripped_op_list();
  public:
  const ::tensorflow::OpList& stripped_op_list() const;
  ::tensorflow::OpList* mutable_stripped_op_list();
  ::tensorflow::OpList* release_stripped_op_list();
  void set_allocated_stripped_op_list(::tensorflow::OpList* stripped_op_list);
  ::tensorflow::OpList* unsafe_arena_release_stripped_op_list();
  void unsafe_arena_set_allocated_stripped_op_list(
      ::tensorflow::OpList* stripped_op_list);

  // .google.protobuf.Any any_info = 3;
  bool has_any_info() const;
  void clear_any_info();
  static const int kAnyInfoFieldNumber = 3;
  private:
  void _slow_mutable_any_info();
  ::google::protobuf::Any* _slow_release_any_info();
  public:
  const ::google::protobuf::Any& any_info() const;
  ::google::protobuf::Any* mutable_any_info();
  ::google::protobuf::Any* release_any_info();
  void set_allocated_any_info(::google::protobuf::Any* any_info);
  ::google::protobuf::Any* unsafe_arena_release_any_info();
  void unsafe_arena_set_allocated_any_info(
      ::google::protobuf::Any* any_info);

  // bool stripped_default_attrs = 7;
  void clear_stripped_default_attrs();
  static const int kStrippedDefaultAttrsFieldNumber = 7;
  bool stripped_default_attrs() const;
  void set_stripped_default_attrs(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.MetaGraphDef.MetaInfoDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::internal::ArenaStringPtr meta_graph_version_;
  ::google::protobuf::internal::ArenaStringPtr tensorflow_version_;
  ::google::protobuf::internal::ArenaStringPtr tensorflow_git_version_;
  ::tensorflow::OpList* stripped_op_list_;
  ::google::protobuf::Any* any_info_;
  bool stripped_default_attrs_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class MetaGraphDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.MetaGraphDef) */ {
 public:
  MetaGraphDef();
  virtual ~MetaGraphDef();

  MetaGraphDef(const MetaGraphDef& from);

  inline MetaGraphDef& operator=(const MetaGraphDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaGraphDef(MetaGraphDef&& from) noexcept
    : MetaGraphDef() {
    *this = ::std::move(from);
  }

  inline MetaGraphDef& operator=(MetaGraphDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaGraphDef& default_instance();

  static inline const MetaGraphDef* internal_default_instance() {
    return reinterpret_cast<const MetaGraphDef*>(
               &_MetaGraphDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(MetaGraphDef* other);
  void Swap(MetaGraphDef* other);
  friend void swap(MetaGraphDef& a, MetaGraphDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaGraphDef* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaGraphDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MetaGraphDef& from);
  void MergeFrom(const MetaGraphDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MetaGraphDef* other);
  protected:
  explicit MetaGraphDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MetaGraphDef_MetaInfoDef MetaInfoDef;

  // accessors -------------------------------------------------------

  // map<string, .tensorflow.CollectionDef> collection_def = 4;
  int collection_def_size() const;
  void clear_collection_def();
  static const int kCollectionDefFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::CollectionDef >&
      collection_def() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::CollectionDef >*
      mutable_collection_def();

  // map<string, .tensorflow.SignatureDef> signature_def = 5;
  int signature_def_size() const;
  void clear_signature_def();
  static const int kSignatureDefFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::SignatureDef >&
      signature_def() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::SignatureDef >*
      mutable_signature_def();

  // repeated .tensorflow.AssetFileDef asset_file_def = 6;
  int asset_file_def_size() const;
  void clear_asset_file_def();
  static const int kAssetFileDefFieldNumber = 6;
  const ::tensorflow::AssetFileDef& asset_file_def(int index) const;
  ::tensorflow::AssetFileDef* mutable_asset_file_def(int index);
  ::tensorflow::AssetFileDef* add_asset_file_def();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::AssetFileDef >*
      mutable_asset_file_def();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::AssetFileDef >&
      asset_file_def() const;

  // .tensorflow.MetaGraphDef.MetaInfoDef meta_info_def = 1;
  bool has_meta_info_def() const;
  void clear_meta_info_def();
  static const int kMetaInfoDefFieldNumber = 1;
  private:
  void _slow_mutable_meta_info_def();
  void _slow_set_allocated_meta_info_def(
      ::google::protobuf::Arena* message_arena, ::tensorflow::MetaGraphDef_MetaInfoDef** meta_info_def);
  ::tensorflow::MetaGraphDef_MetaInfoDef* _slow_release_meta_info_def();
  public:
  const ::tensorflow::MetaGraphDef_MetaInfoDef& meta_info_def() const;
  ::tensorflow::MetaGraphDef_MetaInfoDef* mutable_meta_info_def();
  ::tensorflow::MetaGraphDef_MetaInfoDef* release_meta_info_def();
  void set_allocated_meta_info_def(::tensorflow::MetaGraphDef_MetaInfoDef* meta_info_def);
  ::tensorflow::MetaGraphDef_MetaInfoDef* unsafe_arena_release_meta_info_def();
  void unsafe_arena_set_allocated_meta_info_def(
      ::tensorflow::MetaGraphDef_MetaInfoDef* meta_info_def);

  // .tensorflow.GraphDef graph_def = 2;
  bool has_graph_def() const;
  void clear_graph_def();
  static const int kGraphDefFieldNumber = 2;
  private:
  void _slow_mutable_graph_def();
  void _slow_set_allocated_graph_def(
      ::google::protobuf::Arena* message_arena, ::tensorflow::GraphDef** graph_def);
  ::tensorflow::GraphDef* _slow_release_graph_def();
  public:
  const ::tensorflow::GraphDef& graph_def() const;
  ::tensorflow::GraphDef* mutable_graph_def();
  ::tensorflow::GraphDef* release_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* graph_def);
  ::tensorflow::GraphDef* unsafe_arena_release_graph_def();
  void unsafe_arena_set_allocated_graph_def(
      ::tensorflow::GraphDef* graph_def);

  // .tensorflow.SaverDef saver_def = 3;
  bool has_saver_def() const;
  void clear_saver_def();
  static const int kSaverDefFieldNumber = 3;
  private:
  void _slow_mutable_saver_def();
  void _slow_set_allocated_saver_def(
      ::google::protobuf::Arena* message_arena, ::tensorflow::SaverDef** saver_def);
  ::tensorflow::SaverDef* _slow_release_saver_def();
  public:
  const ::tensorflow::SaverDef& saver_def() const;
  ::tensorflow::SaverDef* mutable_saver_def();
  ::tensorflow::SaverDef* release_saver_def();
  void set_allocated_saver_def(::tensorflow::SaverDef* saver_def);
  ::tensorflow::SaverDef* unsafe_arena_release_saver_def();
  void unsafe_arena_set_allocated_saver_def(
      ::tensorflow::SaverDef* saver_def);

  // @@protoc_insertion_point(class_scope:tensorflow.MetaGraphDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  public:
  class MetaGraphDef_CollectionDefEntry : public ::google::protobuf::internal::MapEntry<MetaGraphDef_CollectionDefEntry, 
      ::std::string, ::tensorflow::CollectionDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<MetaGraphDef_CollectionDefEntry, 
      ::std::string, ::tensorflow::CollectionDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > SuperType;
    MetaGraphDef_CollectionDefEntry();
    MetaGraphDef_CollectionDefEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const MetaGraphDef_CollectionDefEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_MetaGraphDef_CollectionDefEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      MetaGraphDef_CollectionDefEntry,
      ::std::string, ::tensorflow::CollectionDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > collection_def_;
  private:
  public:
  class MetaGraphDef_SignatureDefEntry : public ::google::protobuf::internal::MapEntry<MetaGraphDef_SignatureDefEntry, 
      ::std::string, ::tensorflow::SignatureDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<MetaGraphDef_SignatureDefEntry, 
      ::std::string, ::tensorflow::SignatureDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > SuperType;
    MetaGraphDef_SignatureDefEntry();
    MetaGraphDef_SignatureDefEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const MetaGraphDef_SignatureDefEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_MetaGraphDef_SignatureDefEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      MetaGraphDef_SignatureDefEntry,
      ::std::string, ::tensorflow::SignatureDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > signature_def_;
  private:
  ::google::protobuf::RepeatedPtrField< ::tensorflow::AssetFileDef > asset_file_def_;
  ::tensorflow::MetaGraphDef_MetaInfoDef* meta_info_def_;
  ::tensorflow::GraphDef* graph_def_;
  ::tensorflow::SaverDef* saver_def_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollectionDef_NodeList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.NodeList) */ {
 public:
  CollectionDef_NodeList();
  virtual ~CollectionDef_NodeList();

  CollectionDef_NodeList(const CollectionDef_NodeList& from);

  inline CollectionDef_NodeList& operator=(const CollectionDef_NodeList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollectionDef_NodeList(CollectionDef_NodeList&& from) noexcept
    : CollectionDef_NodeList() {
    *this = ::std::move(from);
  }

  inline CollectionDef_NodeList& operator=(CollectionDef_NodeList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_NodeList& default_instance();

  static inline const CollectionDef_NodeList* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_NodeList*>(
               &_CollectionDef_NodeList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(CollectionDef_NodeList* other);
  void Swap(CollectionDef_NodeList* other);
  friend void swap(CollectionDef_NodeList& a, CollectionDef_NodeList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollectionDef_NodeList* New() const PROTOBUF_FINAL { return New(NULL); }

  CollectionDef_NodeList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CollectionDef_NodeList& from);
  void MergeFrom(const CollectionDef_NodeList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CollectionDef_NodeList* other);
  protected:
  explicit CollectionDef_NodeList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_value(int index, ::std::string&& value);
  #endif
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  #if LANG_CXX11
  void add_value(::std::string&& value);
  #endif
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.NodeList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollectionDef_BytesList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.BytesList) */ {
 public:
  CollectionDef_BytesList();
  virtual ~CollectionDef_BytesList();

  CollectionDef_BytesList(const CollectionDef_BytesList& from);

  inline CollectionDef_BytesList& operator=(const CollectionDef_BytesList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollectionDef_BytesList(CollectionDef_BytesList&& from) noexcept
    : CollectionDef_BytesList() {
    *this = ::std::move(from);
  }

  inline CollectionDef_BytesList& operator=(CollectionDef_BytesList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_BytesList& default_instance();

  static inline const CollectionDef_BytesList* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_BytesList*>(
               &_CollectionDef_BytesList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(CollectionDef_BytesList* other);
  void Swap(CollectionDef_BytesList* other);
  friend void swap(CollectionDef_BytesList& a, CollectionDef_BytesList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollectionDef_BytesList* New() const PROTOBUF_FINAL { return New(NULL); }

  CollectionDef_BytesList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CollectionDef_BytesList& from);
  void MergeFrom(const CollectionDef_BytesList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CollectionDef_BytesList* other);
  protected:
  explicit CollectionDef_BytesList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_value(int index, ::std::string&& value);
  #endif
  void set_value(int index, const char* value);
  void set_value(int index, const void* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  #if LANG_CXX11
  void add_value(::std::string&& value);
  #endif
  void add_value(const char* value);
  void add_value(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.BytesList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollectionDef_Int64List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.Int64List) */ {
 public:
  CollectionDef_Int64List();
  virtual ~CollectionDef_Int64List();

  CollectionDef_Int64List(const CollectionDef_Int64List& from);

  inline CollectionDef_Int64List& operator=(const CollectionDef_Int64List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollectionDef_Int64List(CollectionDef_Int64List&& from) noexcept
    : CollectionDef_Int64List() {
    *this = ::std::move(from);
  }

  inline CollectionDef_Int64List& operator=(CollectionDef_Int64List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_Int64List& default_instance();

  static inline const CollectionDef_Int64List* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_Int64List*>(
               &_CollectionDef_Int64List_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(CollectionDef_Int64List* other);
  void Swap(CollectionDef_Int64List* other);
  friend void swap(CollectionDef_Int64List& a, CollectionDef_Int64List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollectionDef_Int64List* New() const PROTOBUF_FINAL { return New(NULL); }

  CollectionDef_Int64List* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CollectionDef_Int64List& from);
  void MergeFrom(const CollectionDef_Int64List& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CollectionDef_Int64List* other);
  protected:
  explicit CollectionDef_Int64List(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value(int index) const;
  void set_value(int index, ::google::protobuf::int64 value);
  void add_value(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.Int64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollectionDef_FloatList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.FloatList) */ {
 public:
  CollectionDef_FloatList();
  virtual ~CollectionDef_FloatList();

  CollectionDef_FloatList(const CollectionDef_FloatList& from);

  inline CollectionDef_FloatList& operator=(const CollectionDef_FloatList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollectionDef_FloatList(CollectionDef_FloatList&& from) noexcept
    : CollectionDef_FloatList() {
    *this = ::std::move(from);
  }

  inline CollectionDef_FloatList& operator=(CollectionDef_FloatList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_FloatList& default_instance();

  static inline const CollectionDef_FloatList* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_FloatList*>(
               &_CollectionDef_FloatList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(CollectionDef_FloatList* other);
  void Swap(CollectionDef_FloatList* other);
  friend void swap(CollectionDef_FloatList& a, CollectionDef_FloatList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollectionDef_FloatList* New() const PROTOBUF_FINAL { return New(NULL); }

  CollectionDef_FloatList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CollectionDef_FloatList& from);
  void MergeFrom(const CollectionDef_FloatList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CollectionDef_FloatList* other);
  protected:
  explicit CollectionDef_FloatList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float value = 1 [packed = true];
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.FloatList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollectionDef_AnyList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef.AnyList) */ {
 public:
  CollectionDef_AnyList();
  virtual ~CollectionDef_AnyList();

  CollectionDef_AnyList(const CollectionDef_AnyList& from);

  inline CollectionDef_AnyList& operator=(const CollectionDef_AnyList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollectionDef_AnyList(CollectionDef_AnyList&& from) noexcept
    : CollectionDef_AnyList() {
    *this = ::std::move(from);
  }

  inline CollectionDef_AnyList& operator=(CollectionDef_AnyList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef_AnyList& default_instance();

  static inline const CollectionDef_AnyList* internal_default_instance() {
    return reinterpret_cast<const CollectionDef_AnyList*>(
               &_CollectionDef_AnyList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(CollectionDef_AnyList* other);
  void Swap(CollectionDef_AnyList* other);
  friend void swap(CollectionDef_AnyList& a, CollectionDef_AnyList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollectionDef_AnyList* New() const PROTOBUF_FINAL { return New(NULL); }

  CollectionDef_AnyList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CollectionDef_AnyList& from);
  void MergeFrom(const CollectionDef_AnyList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CollectionDef_AnyList* other);
  protected:
  explicit CollectionDef_AnyList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::google::protobuf::Any& value(int index) const;
  ::google::protobuf::Any* mutable_value(int index);
  ::google::protobuf::Any* add_value();
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_value();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      value() const;

  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef.AnyList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > value_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollectionDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CollectionDef) */ {
 public:
  CollectionDef();
  virtual ~CollectionDef();

  CollectionDef(const CollectionDef& from);

  inline CollectionDef& operator=(const CollectionDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollectionDef(CollectionDef&& from) noexcept
    : CollectionDef() {
    *this = ::std::move(from);
  }

  inline CollectionDef& operator=(CollectionDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectionDef& default_instance();

  enum KindCase {
    kNodeList = 1,
    kBytesList = 2,
    kInt64List = 3,
    kFloatList = 4,
    kAnyList = 5,
    KIND_NOT_SET = 0,
  };

  static inline const CollectionDef* internal_default_instance() {
    return reinterpret_cast<const CollectionDef*>(
               &_CollectionDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(CollectionDef* other);
  void Swap(CollectionDef* other);
  friend void swap(CollectionDef& a, CollectionDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollectionDef* New() const PROTOBUF_FINAL { return New(NULL); }

  CollectionDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CollectionDef& from);
  void MergeFrom(const CollectionDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CollectionDef* other);
  protected:
  explicit CollectionDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CollectionDef_NodeList NodeList;
  typedef CollectionDef_BytesList BytesList;
  typedef CollectionDef_Int64List Int64List;
  typedef CollectionDef_FloatList FloatList;
  typedef CollectionDef_AnyList AnyList;

  // accessors -------------------------------------------------------

  // .tensorflow.CollectionDef.NodeList node_list = 1;
  bool has_node_list() const;
  void clear_node_list();
  static const int kNodeListFieldNumber = 1;
  private:
  void _slow_mutable_node_list();
  void _slow_set_allocated_node_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::CollectionDef_NodeList** node_list);
  ::tensorflow::CollectionDef_NodeList* _slow_release_node_list();
  public:
  const ::tensorflow::CollectionDef_NodeList& node_list() const;
  ::tensorflow::CollectionDef_NodeList* mutable_node_list();
  ::tensorflow::CollectionDef_NodeList* release_node_list();
  void set_allocated_node_list(::tensorflow::CollectionDef_NodeList* node_list);
  ::tensorflow::CollectionDef_NodeList* unsafe_arena_release_node_list();
  void unsafe_arena_set_allocated_node_list(
      ::tensorflow::CollectionDef_NodeList* node_list);

  // .tensorflow.CollectionDef.BytesList bytes_list = 2;
  bool has_bytes_list() const;
  void clear_bytes_list();
  static const int kBytesListFieldNumber = 2;
  private:
  void _slow_mutable_bytes_list();
  void _slow_set_allocated_bytes_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::CollectionDef_BytesList** bytes_list);
  ::tensorflow::CollectionDef_BytesList* _slow_release_bytes_list();
  public:
  const ::tensorflow::CollectionDef_BytesList& bytes_list() const;
  ::tensorflow::CollectionDef_BytesList* mutable_bytes_list();
  ::tensorflow::CollectionDef_BytesList* release_bytes_list();
  void set_allocated_bytes_list(::tensorflow::CollectionDef_BytesList* bytes_list);
  ::tensorflow::CollectionDef_BytesList* unsafe_arena_release_bytes_list();
  void unsafe_arena_set_allocated_bytes_list(
      ::tensorflow::CollectionDef_BytesList* bytes_list);

  // .tensorflow.CollectionDef.Int64List int64_list = 3;
  bool has_int64_list() const;
  void clear_int64_list();
  static const int kInt64ListFieldNumber = 3;
  private:
  void _slow_mutable_int64_list();
  void _slow_set_allocated_int64_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::CollectionDef_Int64List** int64_list);
  ::tensorflow::CollectionDef_Int64List* _slow_release_int64_list();
  public:
  const ::tensorflow::CollectionDef_Int64List& int64_list() const;
  ::tensorflow::CollectionDef_Int64List* mutable_int64_list();
  ::tensorflow::CollectionDef_Int64List* release_int64_list();
  void set_allocated_int64_list(::tensorflow::CollectionDef_Int64List* int64_list);
  ::tensorflow::CollectionDef_Int64List* unsafe_arena_release_int64_list();
  void unsafe_arena_set_allocated_int64_list(
      ::tensorflow::CollectionDef_Int64List* int64_list);

  // .tensorflow.CollectionDef.FloatList float_list = 4;
  bool has_float_list() const;
  void clear_float_list();
  static const int kFloatListFieldNumber = 4;
  private:
  void _slow_mutable_float_list();
  void _slow_set_allocated_float_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::CollectionDef_FloatList** float_list);
  ::tensorflow::CollectionDef_FloatList* _slow_release_float_list();
  public:
  const ::tensorflow::CollectionDef_FloatList& float_list() const;
  ::tensorflow::CollectionDef_FloatList* mutable_float_list();
  ::tensorflow::CollectionDef_FloatList* release_float_list();
  void set_allocated_float_list(::tensorflow::CollectionDef_FloatList* float_list);
  ::tensorflow::CollectionDef_FloatList* unsafe_arena_release_float_list();
  void unsafe_arena_set_allocated_float_list(
      ::tensorflow::CollectionDef_FloatList* float_list);

  // .tensorflow.CollectionDef.AnyList any_list = 5;
  bool has_any_list() const;
  void clear_any_list();
  static const int kAnyListFieldNumber = 5;
  private:
  void _slow_mutable_any_list();
  void _slow_set_allocated_any_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::CollectionDef_AnyList** any_list);
  ::tensorflow::CollectionDef_AnyList* _slow_release_any_list();
  public:
  const ::tensorflow::CollectionDef_AnyList& any_list() const;
  ::tensorflow::CollectionDef_AnyList* mutable_any_list();
  ::tensorflow::CollectionDef_AnyList* release_any_list();
  void set_allocated_any_list(::tensorflow::CollectionDef_AnyList* any_list);
  ::tensorflow::CollectionDef_AnyList* unsafe_arena_release_any_list();
  void unsafe_arena_set_allocated_any_list(
      ::tensorflow::CollectionDef_AnyList* any_list);

  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.CollectionDef)
 private:
  void set_has_node_list();
  void set_has_bytes_list();
  void set_has_int64_list();
  void set_has_float_list();
  void set_has_any_list();

  inline bool has_kind() const;
  void clear_kind();
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    KindUnion() {}
    ::tensorflow::CollectionDef_NodeList* node_list_;
    ::tensorflow::CollectionDef_BytesList* bytes_list_;
    ::tensorflow::CollectionDef_Int64List* int64_list_;
    ::tensorflow::CollectionDef_FloatList* float_list_;
    ::tensorflow::CollectionDef_AnyList* any_list_;
  } kind_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorInfo_CooSparse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TensorInfo.CooSparse) */ {
 public:
  TensorInfo_CooSparse();
  virtual ~TensorInfo_CooSparse();

  TensorInfo_CooSparse(const TensorInfo_CooSparse& from);

  inline TensorInfo_CooSparse& operator=(const TensorInfo_CooSparse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorInfo_CooSparse(TensorInfo_CooSparse&& from) noexcept
    : TensorInfo_CooSparse() {
    *this = ::std::move(from);
  }

  inline TensorInfo_CooSparse& operator=(TensorInfo_CooSparse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorInfo_CooSparse& default_instance();

  static inline const TensorInfo_CooSparse* internal_default_instance() {
    return reinterpret_cast<const TensorInfo_CooSparse*>(
               &_TensorInfo_CooSparse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(TensorInfo_CooSparse* other);
  void Swap(TensorInfo_CooSparse* other);
  friend void swap(TensorInfo_CooSparse& a, TensorInfo_CooSparse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorInfo_CooSparse* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorInfo_CooSparse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TensorInfo_CooSparse& from);
  void MergeFrom(const TensorInfo_CooSparse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TensorInfo_CooSparse* other);
  protected:
  explicit TensorInfo_CooSparse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string values_tensor_name = 1;
  void clear_values_tensor_name();
  static const int kValuesTensorNameFieldNumber = 1;
  const ::std::string& values_tensor_name() const;
  void set_values_tensor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_values_tensor_name(::std::string&& value);
  #endif
  void set_values_tensor_name(const char* value);
  void set_values_tensor_name(const char* value, size_t size);
  ::std::string* mutable_values_tensor_name();
  ::std::string* release_values_tensor_name();
  void set_allocated_values_tensor_name(::std::string* values_tensor_name);
  ::std::string* unsafe_arena_release_values_tensor_name();
  void unsafe_arena_set_allocated_values_tensor_name(
      ::std::string* values_tensor_name);

  // string indices_tensor_name = 2;
  void clear_indices_tensor_name();
  static const int kIndicesTensorNameFieldNumber = 2;
  const ::std::string& indices_tensor_name() const;
  void set_indices_tensor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_indices_tensor_name(::std::string&& value);
  #endif
  void set_indices_tensor_name(const char* value);
  void set_indices_tensor_name(const char* value, size_t size);
  ::std::string* mutable_indices_tensor_name();
  ::std::string* release_indices_tensor_name();
  void set_allocated_indices_tensor_name(::std::string* indices_tensor_name);
  ::std::string* unsafe_arena_release_indices_tensor_name();
  void unsafe_arena_set_allocated_indices_tensor_name(
      ::std::string* indices_tensor_name);

  // string dense_shape_tensor_name = 3;
  void clear_dense_shape_tensor_name();
  static const int kDenseShapeTensorNameFieldNumber = 3;
  const ::std::string& dense_shape_tensor_name() const;
  void set_dense_shape_tensor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_dense_shape_tensor_name(::std::string&& value);
  #endif
  void set_dense_shape_tensor_name(const char* value);
  void set_dense_shape_tensor_name(const char* value, size_t size);
  ::std::string* mutable_dense_shape_tensor_name();
  ::std::string* release_dense_shape_tensor_name();
  void set_allocated_dense_shape_tensor_name(::std::string* dense_shape_tensor_name);
  ::std::string* unsafe_arena_release_dense_shape_tensor_name();
  void unsafe_arena_set_allocated_dense_shape_tensor_name(
      ::std::string* dense_shape_tensor_name);

  // @@protoc_insertion_point(class_scope:tensorflow.TensorInfo.CooSparse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr values_tensor_name_;
  ::google::protobuf::internal::ArenaStringPtr indices_tensor_name_;
  ::google::protobuf::internal::ArenaStringPtr dense_shape_tensor_name_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TensorInfo) */ {
 public:
  TensorInfo();
  virtual ~TensorInfo();

  TensorInfo(const TensorInfo& from);

  inline TensorInfo& operator=(const TensorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorInfo(TensorInfo&& from) noexcept
    : TensorInfo() {
    *this = ::std::move(from);
  }

  inline TensorInfo& operator=(TensorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorInfo& default_instance();

  enum EncodingCase {
    kName = 1,
    kCooSparse = 4,
    ENCODING_NOT_SET = 0,
  };

  static inline const TensorInfo* internal_default_instance() {
    return reinterpret_cast<const TensorInfo*>(
               &_TensorInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(TensorInfo* other);
  void Swap(TensorInfo* other);
  friend void swap(TensorInfo& a, TensorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TensorInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TensorInfo& from);
  void MergeFrom(const TensorInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TensorInfo* other);
  protected:
  explicit TensorInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TensorInfo_CooSparse CooSparse;

  // accessors -------------------------------------------------------

  // .tensorflow.TensorShapeProto tensor_shape = 3;
  bool has_tensor_shape() const;
  void clear_tensor_shape();
  static const int kTensorShapeFieldNumber = 3;
  private:
  void _slow_mutable_tensor_shape();
  void _slow_set_allocated_tensor_shape(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TensorShapeProto** tensor_shape);
  ::tensorflow::TensorShapeProto* _slow_release_tensor_shape();
  public:
  const ::tensorflow::TensorShapeProto& tensor_shape() const;
  ::tensorflow::TensorShapeProto* mutable_tensor_shape();
  ::tensorflow::TensorShapeProto* release_tensor_shape();
  void set_allocated_tensor_shape(::tensorflow::TensorShapeProto* tensor_shape);
  ::tensorflow::TensorShapeProto* unsafe_arena_release_tensor_shape();
  void unsafe_arena_set_allocated_tensor_shape(
      ::tensorflow::TensorShapeProto* tensor_shape);

  // .tensorflow.DataType dtype = 2;
  void clear_dtype();
  static const int kDtypeFieldNumber = 2;
  ::tensorflow::DataType dtype() const;
  void set_dtype(::tensorflow::DataType value);

  // string name = 1;
  private:
  bool has_name() const;
  public:
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  ::std::string* unsafe_arena_release_name();
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // .tensorflow.TensorInfo.CooSparse coo_sparse = 4;
  bool has_coo_sparse() const;
  void clear_coo_sparse();
  static const int kCooSparseFieldNumber = 4;
  private:
  void _slow_mutable_coo_sparse();
  void _slow_set_allocated_coo_sparse(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TensorInfo_CooSparse** coo_sparse);
  ::tensorflow::TensorInfo_CooSparse* _slow_release_coo_sparse();
  public:
  const ::tensorflow::TensorInfo_CooSparse& coo_sparse() const;
  ::tensorflow::TensorInfo_CooSparse* mutable_coo_sparse();
  ::tensorflow::TensorInfo_CooSparse* release_coo_sparse();
  void set_allocated_coo_sparse(::tensorflow::TensorInfo_CooSparse* coo_sparse);
  ::tensorflow::TensorInfo_CooSparse* unsafe_arena_release_coo_sparse();
  void unsafe_arena_set_allocated_coo_sparse(
      ::tensorflow::TensorInfo_CooSparse* coo_sparse);

  EncodingCase encoding_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.TensorInfo)
 private:
  void set_has_name();
  void set_has_coo_sparse();

  inline bool has_encoding() const;
  void clear_encoding();
  inline void clear_has_encoding();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::TensorShapeProto* tensor_shape_;
  int dtype_;
  union EncodingUnion {
    EncodingUnion() {}
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::tensorflow::TensorInfo_CooSparse* coo_sparse_;
  } encoding_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class SignatureDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.SignatureDef) */ {
 public:
  SignatureDef();
  virtual ~SignatureDef();

  SignatureDef(const SignatureDef& from);

  inline SignatureDef& operator=(const SignatureDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignatureDef(SignatureDef&& from) noexcept
    : SignatureDef() {
    *this = ::std::move(from);
  }

  inline SignatureDef& operator=(SignatureDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignatureDef& default_instance();

  static inline const SignatureDef* internal_default_instance() {
    return reinterpret_cast<const SignatureDef*>(
               &_SignatureDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(SignatureDef* other);
  void Swap(SignatureDef* other);
  friend void swap(SignatureDef& a, SignatureDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignatureDef* New() const PROTOBUF_FINAL { return New(NULL); }

  SignatureDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignatureDef& from);
  void MergeFrom(const SignatureDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignatureDef* other);
  protected:
  explicit SignatureDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .tensorflow.TensorInfo> inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::TensorInfo >&
      inputs() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::TensorInfo >*
      mutable_inputs();

  // map<string, .tensorflow.TensorInfo> outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::TensorInfo >&
      outputs() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::TensorInfo >*
      mutable_outputs();

  // string method_name = 3;
  void clear_method_name();
  static const int kMethodNameFieldNumber = 3;
  const ::std::string& method_name() const;
  void set_method_name(const ::std::string& value);
  #if LANG_CXX11
  void set_method_name(::std::string&& value);
  #endif
  void set_method_name(const char* value);
  void set_method_name(const char* value, size_t size);
  ::std::string* mutable_method_name();
  ::std::string* release_method_name();
  void set_allocated_method_name(::std::string* method_name);
  ::std::string* unsafe_arena_release_method_name();
  void unsafe_arena_set_allocated_method_name(
      ::std::string* method_name);

  // @@protoc_insertion_point(class_scope:tensorflow.SignatureDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  public:
  class SignatureDef_InputsEntry : public ::google::protobuf::internal::MapEntry<SignatureDef_InputsEntry, 
      ::std::string, ::tensorflow::TensorInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<SignatureDef_InputsEntry, 
      ::std::string, ::tensorflow::TensorInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > SuperType;
    SignatureDef_InputsEntry();
    SignatureDef_InputsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const SignatureDef_InputsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_SignatureDef_InputsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      SignatureDef_InputsEntry,
      ::std::string, ::tensorflow::TensorInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > inputs_;
  private:
  public:
  class SignatureDef_OutputsEntry : public ::google::protobuf::internal::MapEntry<SignatureDef_OutputsEntry, 
      ::std::string, ::tensorflow::TensorInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<SignatureDef_OutputsEntry, 
      ::std::string, ::tensorflow::TensorInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > SuperType;
    SignatureDef_OutputsEntry();
    SignatureDef_OutputsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const SignatureDef_OutputsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_SignatureDef_OutputsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      SignatureDef_OutputsEntry,
      ::std::string, ::tensorflow::TensorInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > outputs_;
  private:
  ::google::protobuf::internal::ArenaStringPtr method_name_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssetFileDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.AssetFileDef) */ {
 public:
  AssetFileDef();
  virtual ~AssetFileDef();

  AssetFileDef(const AssetFileDef& from);

  inline AssetFileDef& operator=(const AssetFileDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetFileDef(AssetFileDef&& from) noexcept
    : AssetFileDef() {
    *this = ::std::move(from);
  }

  inline AssetFileDef& operator=(AssetFileDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetFileDef& default_instance();

  static inline const AssetFileDef* internal_default_instance() {
    return reinterpret_cast<const AssetFileDef*>(
               &_AssetFileDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(AssetFileDef* other);
  void Swap(AssetFileDef* other);
  friend void swap(AssetFileDef& a, AssetFileDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetFileDef* New() const PROTOBUF_FINAL { return New(NULL); }

  AssetFileDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AssetFileDef& from);
  void MergeFrom(const AssetFileDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AssetFileDef* other);
  protected:
  explicit AssetFileDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 2;
  void clear_filename();
  static const int kFilenameFieldNumber = 2;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);
  ::std::string* unsafe_arena_release_filename();
  void unsafe_arena_set_allocated_filename(
      ::std::string* filename);

  // .tensorflow.TensorInfo tensor_info = 1;
  bool has_tensor_info() const;
  void clear_tensor_info();
  static const int kTensorInfoFieldNumber = 1;
  private:
  void _slow_mutable_tensor_info();
  void _slow_set_allocated_tensor_info(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TensorInfo** tensor_info);
  ::tensorflow::TensorInfo* _slow_release_tensor_info();
  public:
  const ::tensorflow::TensorInfo& tensor_info() const;
  ::tensorflow::TensorInfo* mutable_tensor_info();
  ::tensorflow::TensorInfo* release_tensor_info();
  void set_allocated_tensor_info(::tensorflow::TensorInfo* tensor_info);
  ::tensorflow::TensorInfo* unsafe_arena_release_tensor_info();
  void unsafe_arena_set_allocated_tensor_info(
      ::tensorflow::TensorInfo* tensor_info);

  // @@protoc_insertion_point(class_scope:tensorflow.AssetFileDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::tensorflow::TensorInfo* tensor_info_;
  mutable int _cached_size_;
  friend struct protobuf_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MetaGraphDef_MetaInfoDef

// string meta_graph_version = 1;
inline void MetaGraphDef_MetaInfoDef::clear_meta_graph_version() {
  meta_graph_version_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& MetaGraphDef_MetaInfoDef::meta_graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  return meta_graph_version_.Get();
}
inline void MetaGraphDef_MetaInfoDef::set_meta_graph_version(const ::std::string& value) {
  
  meta_graph_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
#if LANG_CXX11
inline void MetaGraphDef_MetaInfoDef::set_meta_graph_version(::std::string&& value) {
  
  meta_graph_version_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
#endif
inline void MetaGraphDef_MetaInfoDef::set_meta_graph_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  meta_graph_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
inline void MetaGraphDef_MetaInfoDef::set_meta_graph_version(const char* value,
    size_t size) {
  
  meta_graph_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
inline ::std::string* MetaGraphDef_MetaInfoDef::mutable_meta_graph_version() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  return meta_graph_version_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MetaGraphDef_MetaInfoDef::release_meta_graph_version() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  
  return meta_graph_version_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MetaGraphDef_MetaInfoDef::unsafe_arena_release_meta_graph_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return meta_graph_version_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_meta_graph_version(::std::string* meta_graph_version) {
  if (meta_graph_version != NULL) {
    
  } else {
    
  }
  meta_graph_version_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meta_graph_version,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}
inline void MetaGraphDef_MetaInfoDef::unsafe_arena_set_allocated_meta_graph_version(
    ::std::string* meta_graph_version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (meta_graph_version != NULL) {
    
  } else {
    
  }
  meta_graph_version_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      meta_graph_version, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.meta_graph_version)
}

// .tensorflow.OpList stripped_op_list = 2;
inline bool MetaGraphDef_MetaInfoDef::has_stripped_op_list() const {
  return this != internal_default_instance() && stripped_op_list_ != NULL;
}
inline void MetaGraphDef_MetaInfoDef::clear_stripped_op_list() {
  if (GetArenaNoVirtual() == NULL && stripped_op_list_ != NULL) delete stripped_op_list_;
  stripped_op_list_ = NULL;
}
inline const ::tensorflow::OpList& MetaGraphDef_MetaInfoDef::stripped_op_list() const {
  const ::tensorflow::OpList* p = stripped_op_list_;
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::OpList*>(
      &::tensorflow::_OpList_default_instance_);
}
inline ::tensorflow::OpList* MetaGraphDef_MetaInfoDef::mutable_stripped_op_list() {
  
  if (stripped_op_list_ == NULL) {
    _slow_mutable_stripped_op_list();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
  return stripped_op_list_;
}
inline ::tensorflow::OpList* MetaGraphDef_MetaInfoDef::release_stripped_op_list() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_stripped_op_list();
  } else {
    ::tensorflow::OpList* temp = stripped_op_list_;
    stripped_op_list_ = NULL;
    return temp;
  }
}
inline  void MetaGraphDef_MetaInfoDef::set_allocated_stripped_op_list(::tensorflow::OpList* stripped_op_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stripped_op_list_;
  }
  if (stripped_op_list != NULL) {
    _slow_set_allocated_stripped_op_list(message_arena, &stripped_op_list);
  }
  stripped_op_list_ = stripped_op_list;
  if (stripped_op_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.stripped_op_list)
}

// .google.protobuf.Any any_info = 3;
inline bool MetaGraphDef_MetaInfoDef::has_any_info() const {
  return this != internal_default_instance() && any_info_ != NULL;
}
inline void MetaGraphDef_MetaInfoDef::clear_any_info() {
  if (GetArenaNoVirtual() == NULL && any_info_ != NULL) delete any_info_;
  any_info_ = NULL;
}
inline const ::google::protobuf::Any& MetaGraphDef_MetaInfoDef::any_info() const {
  const ::google::protobuf::Any* p = any_info_;
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* MetaGraphDef_MetaInfoDef::mutable_any_info() {
  
  if (any_info_ == NULL) {
    _slow_mutable_any_info();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
  return any_info_;
}
inline ::google::protobuf::Any* MetaGraphDef_MetaInfoDef::release_any_info() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_any_info();
  } else {
    ::google::protobuf::Any* temp = any_info_;
    any_info_ = NULL;
    return temp;
  }
}
inline  void MetaGraphDef_MetaInfoDef::set_allocated_any_info(::google::protobuf::Any* any_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete any_info_;
  }
  if (any_info != NULL) {
    if (message_arena != NULL) {
      message_arena->Own(any_info);
    }
  }
  any_info_ = any_info;
  if (any_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.any_info)
}

// repeated string tags = 4;
inline int MetaGraphDef_MetaInfoDef::tags_size() const {
  return tags_.size();
}
inline void MetaGraphDef_MetaInfoDef::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& MetaGraphDef_MetaInfoDef::tags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return tags_.Get(index);
}
inline ::std::string* MetaGraphDef_MetaInfoDef::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return tags_.Mutable(index);
}
inline void MetaGraphDef_MetaInfoDef::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MetaGraphDef_MetaInfoDef::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MetaGraphDef_MetaInfoDef::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.MetaGraphDef.MetaInfoDef.tags)
}
inline void MetaGraphDef_MetaInfoDef::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.MetaGraphDef.MetaInfoDef.tags)
}
inline ::std::string* MetaGraphDef_MetaInfoDef::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return tags_.Add();
}
inline void MetaGraphDef_MetaInfoDef::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.MetaGraphDef.MetaInfoDef.tags)
}
#if LANG_CXX11
inline void MetaGraphDef_MetaInfoDef::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.MetaGraphDef.MetaInfoDef.tags)
}
#endif
inline void MetaGraphDef_MetaInfoDef::add_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.MetaGraphDef.MetaInfoDef.tags)
}
inline void MetaGraphDef_MetaInfoDef::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.MetaGraphDef.MetaInfoDef.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MetaGraphDef_MetaInfoDef::tags() const {
  // @@protoc_insertion_point(field_list:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MetaGraphDef_MetaInfoDef::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.MetaGraphDef.MetaInfoDef.tags)
  return &tags_;
}

// string tensorflow_version = 5;
inline void MetaGraphDef_MetaInfoDef::clear_tensorflow_version() {
  tensorflow_version_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& MetaGraphDef_MetaInfoDef::tensorflow_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
  return tensorflow_version_.Get();
}
inline void MetaGraphDef_MetaInfoDef::set_tensorflow_version(const ::std::string& value) {
  
  tensorflow_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
}
#if LANG_CXX11
inline void MetaGraphDef_MetaInfoDef::set_tensorflow_version(::std::string&& value) {
  
  tensorflow_version_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
}
#endif
inline void MetaGraphDef_MetaInfoDef::set_tensorflow_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tensorflow_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
}
inline void MetaGraphDef_MetaInfoDef::set_tensorflow_version(const char* value,
    size_t size) {
  
  tensorflow_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
}
inline ::std::string* MetaGraphDef_MetaInfoDef::mutable_tensorflow_version() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
  return tensorflow_version_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MetaGraphDef_MetaInfoDef::release_tensorflow_version() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
  
  return tensorflow_version_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MetaGraphDef_MetaInfoDef::unsafe_arena_release_tensorflow_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return tensorflow_version_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_tensorflow_version(::std::string* tensorflow_version) {
  if (tensorflow_version != NULL) {
    
  } else {
    
  }
  tensorflow_version_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tensorflow_version,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
}
inline void MetaGraphDef_MetaInfoDef::unsafe_arena_set_allocated_tensorflow_version(
    ::std::string* tensorflow_version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (tensorflow_version != NULL) {
    
  } else {
    
  }
  tensorflow_version_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      tensorflow_version, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_version)
}

// string tensorflow_git_version = 6;
inline void MetaGraphDef_MetaInfoDef::clear_tensorflow_git_version() {
  tensorflow_git_version_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& MetaGraphDef_MetaInfoDef::tensorflow_git_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
  return tensorflow_git_version_.Get();
}
inline void MetaGraphDef_MetaInfoDef::set_tensorflow_git_version(const ::std::string& value) {
  
  tensorflow_git_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
}
#if LANG_CXX11
inline void MetaGraphDef_MetaInfoDef::set_tensorflow_git_version(::std::string&& value) {
  
  tensorflow_git_version_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
}
#endif
inline void MetaGraphDef_MetaInfoDef::set_tensorflow_git_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tensorflow_git_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
}
inline void MetaGraphDef_MetaInfoDef::set_tensorflow_git_version(const char* value,
    size_t size) {
  
  tensorflow_git_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
}
inline ::std::string* MetaGraphDef_MetaInfoDef::mutable_tensorflow_git_version() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
  return tensorflow_git_version_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MetaGraphDef_MetaInfoDef::release_tensorflow_git_version() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
  
  return tensorflow_git_version_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MetaGraphDef_MetaInfoDef::unsafe_arena_release_tensorflow_git_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return tensorflow_git_version_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MetaGraphDef_MetaInfoDef::set_allocated_tensorflow_git_version(::std::string* tensorflow_git_version) {
  if (tensorflow_git_version != NULL) {
    
  } else {
    
  }
  tensorflow_git_version_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tensorflow_git_version,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
}
inline void MetaGraphDef_MetaInfoDef::unsafe_arena_set_allocated_tensorflow_git_version(
    ::std::string* tensorflow_git_version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (tensorflow_git_version != NULL) {
    
  } else {
    
  }
  tensorflow_git_version_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      tensorflow_git_version, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.MetaGraphDef.MetaInfoDef.tensorflow_git_version)
}

// bool stripped_default_attrs = 7;
inline void MetaGraphDef_MetaInfoDef::clear_stripped_default_attrs() {
  stripped_default_attrs_ = false;
}
inline bool MetaGraphDef_MetaInfoDef::stripped_default_attrs() const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.MetaInfoDef.stripped_default_attrs)
  return stripped_default_attrs_;
}
inline void MetaGraphDef_MetaInfoDef::set_stripped_default_attrs(bool value) {
  
  stripped_default_attrs_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.MetaGraphDef.MetaInfoDef.stripped_default_attrs)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetaGraphDef

// .tensorflow.MetaGraphDef.MetaInfoDef meta_info_def = 1;
inline bool MetaGraphDef::has_meta_info_def() const {
  return this != internal_default_instance() && meta_info_def_ != NULL;
}
inline void MetaGraphDef::clear_meta_info_def() {
  if (GetArenaNoVirtual() == NULL && meta_info_def_ != NULL) delete meta_info_def_;
  meta_info_def_ = NULL;
}
inline const ::tensorflow::MetaGraphDef_MetaInfoDef& MetaGraphDef::meta_info_def() const {
  const ::tensorflow::MetaGraphDef_MetaInfoDef* p = meta_info_def_;
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.meta_info_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::MetaGraphDef_MetaInfoDef*>(
      &::tensorflow::_MetaGraphDef_MetaInfoDef_default_instance_);
}
inline ::tensorflow::MetaGraphDef_MetaInfoDef* MetaGraphDef::mutable_meta_info_def() {
  
  if (meta_info_def_ == NULL) {
    _slow_mutable_meta_info_def();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.meta_info_def)
  return meta_info_def_;
}
inline ::tensorflow::MetaGraphDef_MetaInfoDef* MetaGraphDef::release_meta_info_def() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.meta_info_def)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_meta_info_def();
  } else {
    ::tensorflow::MetaGraphDef_MetaInfoDef* temp = meta_info_def_;
    meta_info_def_ = NULL;
    return temp;
  }
}
inline  void MetaGraphDef::set_allocated_meta_info_def(::tensorflow::MetaGraphDef_MetaInfoDef* meta_info_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete meta_info_def_;
  }
  if (meta_info_def != NULL) {
    _slow_set_allocated_meta_info_def(message_arena, &meta_info_def);
  }
  meta_info_def_ = meta_info_def;
  if (meta_info_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.meta_info_def)
}

// .tensorflow.GraphDef graph_def = 2;
inline bool MetaGraphDef::has_graph_def() const {
  return this != internal_default_instance() && graph_def_ != NULL;
}
inline void MetaGraphDef::clear_graph_def() {
  if (GetArenaNoVirtual() == NULL && graph_def_ != NULL) delete graph_def_;
  graph_def_ = NULL;
}
inline const ::tensorflow::GraphDef& MetaGraphDef::graph_def() const {
  const ::tensorflow::GraphDef* p = graph_def_;
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.graph_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::GraphDef*>(
      &::tensorflow::_GraphDef_default_instance_);
}
inline ::tensorflow::GraphDef* MetaGraphDef::mutable_graph_def() {
  
  if (graph_def_ == NULL) {
    _slow_mutable_graph_def();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.graph_def)
  return graph_def_;
}
inline ::tensorflow::GraphDef* MetaGraphDef::release_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.graph_def)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_graph_def();
  } else {
    ::tensorflow::GraphDef* temp = graph_def_;
    graph_def_ = NULL;
    return temp;
  }
}
inline  void MetaGraphDef::set_allocated_graph_def(::tensorflow::GraphDef* graph_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete graph_def_;
  }
  if (graph_def != NULL) {
    _slow_set_allocated_graph_def(message_arena, &graph_def);
  }
  graph_def_ = graph_def;
  if (graph_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.graph_def)
}

// .tensorflow.SaverDef saver_def = 3;
inline bool MetaGraphDef::has_saver_def() const {
  return this != internal_default_instance() && saver_def_ != NULL;
}
inline void MetaGraphDef::clear_saver_def() {
  if (GetArenaNoVirtual() == NULL && saver_def_ != NULL) delete saver_def_;
  saver_def_ = NULL;
}
inline const ::tensorflow::SaverDef& MetaGraphDef::saver_def() const {
  const ::tensorflow::SaverDef* p = saver_def_;
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.saver_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::SaverDef*>(
      &::tensorflow::_SaverDef_default_instance_);
}
inline ::tensorflow::SaverDef* MetaGraphDef::mutable_saver_def() {
  
  if (saver_def_ == NULL) {
    _slow_mutable_saver_def();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.saver_def)
  return saver_def_;
}
inline ::tensorflow::SaverDef* MetaGraphDef::release_saver_def() {
  // @@protoc_insertion_point(field_release:tensorflow.MetaGraphDef.saver_def)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_saver_def();
  } else {
    ::tensorflow::SaverDef* temp = saver_def_;
    saver_def_ = NULL;
    return temp;
  }
}
inline  void MetaGraphDef::set_allocated_saver_def(::tensorflow::SaverDef* saver_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete saver_def_;
  }
  if (saver_def != NULL) {
    _slow_set_allocated_saver_def(message_arena, &saver_def);
  }
  saver_def_ = saver_def;
  if (saver_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.MetaGraphDef.saver_def)
}

// map<string, .tensorflow.CollectionDef> collection_def = 4;
inline int MetaGraphDef::collection_def_size() const {
  return collection_def_.size();
}
inline void MetaGraphDef::clear_collection_def() {
  collection_def_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::CollectionDef >&
MetaGraphDef::collection_def() const {
  // @@protoc_insertion_point(field_map:tensorflow.MetaGraphDef.collection_def)
  return collection_def_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::CollectionDef >*
MetaGraphDef::mutable_collection_def() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.MetaGraphDef.collection_def)
  return collection_def_.MutableMap();
}

// map<string, .tensorflow.SignatureDef> signature_def = 5;
inline int MetaGraphDef::signature_def_size() const {
  return signature_def_.size();
}
inline void MetaGraphDef::clear_signature_def() {
  signature_def_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::SignatureDef >&
MetaGraphDef::signature_def() const {
  // @@protoc_insertion_point(field_map:tensorflow.MetaGraphDef.signature_def)
  return signature_def_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::SignatureDef >*
MetaGraphDef::mutable_signature_def() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.MetaGraphDef.signature_def)
  return signature_def_.MutableMap();
}

// repeated .tensorflow.AssetFileDef asset_file_def = 6;
inline int MetaGraphDef::asset_file_def_size() const {
  return asset_file_def_.size();
}
inline void MetaGraphDef::clear_asset_file_def() {
  asset_file_def_.Clear();
}
inline const ::tensorflow::AssetFileDef& MetaGraphDef::asset_file_def(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.MetaGraphDef.asset_file_def)
  return asset_file_def_.Get(index);
}
inline ::tensorflow::AssetFileDef* MetaGraphDef::mutable_asset_file_def(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.MetaGraphDef.asset_file_def)
  return asset_file_def_.Mutable(index);
}
inline ::tensorflow::AssetFileDef* MetaGraphDef::add_asset_file_def() {
  // @@protoc_insertion_point(field_add:tensorflow.MetaGraphDef.asset_file_def)
  return asset_file_def_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::AssetFileDef >*
MetaGraphDef::mutable_asset_file_def() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.MetaGraphDef.asset_file_def)
  return &asset_file_def_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::AssetFileDef >&
MetaGraphDef::asset_file_def() const {
  // @@protoc_insertion_point(field_list:tensorflow.MetaGraphDef.asset_file_def)
  return asset_file_def_;
}

// -------------------------------------------------------------------

// CollectionDef_NodeList

// repeated string value = 1;
inline int CollectionDef_NodeList::value_size() const {
  return value_.size();
}
inline void CollectionDef_NodeList::clear_value() {
  value_.Clear();
}
inline const ::std::string& CollectionDef_NodeList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.NodeList.value)
  return value_.Get(index);
}
inline ::std::string* CollectionDef_NodeList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.NodeList.value)
  return value_.Mutable(index);
}
inline void CollectionDef_NodeList::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.NodeList.value)
  value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CollectionDef_NodeList::set_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.NodeList.value)
  value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CollectionDef_NodeList::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.CollectionDef.NodeList.value)
}
inline void CollectionDef_NodeList::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CollectionDef.NodeList.value)
}
inline ::std::string* CollectionDef_NodeList::add_value() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.CollectionDef.NodeList.value)
  return value_.Add();
}
inline void CollectionDef_NodeList::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.NodeList.value)
}
#if LANG_CXX11
inline void CollectionDef_NodeList::add_value(::std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.NodeList.value)
}
#endif
inline void CollectionDef_NodeList::add_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.CollectionDef.NodeList.value)
}
inline void CollectionDef_NodeList::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.CollectionDef.NodeList.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CollectionDef_NodeList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.NodeList.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CollectionDef_NodeList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.NodeList.value)
  return &value_;
}

// -------------------------------------------------------------------

// CollectionDef_BytesList

// repeated bytes value = 1;
inline int CollectionDef_BytesList::value_size() const {
  return value_.size();
}
inline void CollectionDef_BytesList::clear_value() {
  value_.Clear();
}
inline const ::std::string& CollectionDef_BytesList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.BytesList.value)
  return value_.Get(index);
}
inline ::std::string* CollectionDef_BytesList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.BytesList.value)
  return value_.Mutable(index);
}
inline void CollectionDef_BytesList::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.BytesList.value)
  value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CollectionDef_BytesList::set_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.BytesList.value)
  value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CollectionDef_BytesList::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.CollectionDef.BytesList.value)
}
inline void CollectionDef_BytesList::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CollectionDef.BytesList.value)
}
inline ::std::string* CollectionDef_BytesList::add_value() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.CollectionDef.BytesList.value)
  return value_.Add();
}
inline void CollectionDef_BytesList::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.BytesList.value)
}
#if LANG_CXX11
inline void CollectionDef_BytesList::add_value(::std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.BytesList.value)
}
#endif
inline void CollectionDef_BytesList::add_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.CollectionDef.BytesList.value)
}
inline void CollectionDef_BytesList::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.CollectionDef.BytesList.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CollectionDef_BytesList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.BytesList.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CollectionDef_BytesList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.BytesList.value)
  return &value_;
}

// -------------------------------------------------------------------

// CollectionDef_Int64List

// repeated int64 value = 1 [packed = true];
inline int CollectionDef_Int64List::value_size() const {
  return value_.size();
}
inline void CollectionDef_Int64List::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int64 CollectionDef_Int64List::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.Int64List.value)
  return value_.Get(index);
}
inline void CollectionDef_Int64List::set_value(int index, ::google::protobuf::int64 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.Int64List.value)
}
inline void CollectionDef_Int64List::add_value(::google::protobuf::int64 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.Int64List.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CollectionDef_Int64List::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.Int64List.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CollectionDef_Int64List::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.Int64List.value)
  return &value_;
}

// -------------------------------------------------------------------

// CollectionDef_FloatList

// repeated float value = 1 [packed = true];
inline int CollectionDef_FloatList::value_size() const {
  return value_.size();
}
inline void CollectionDef_FloatList::clear_value() {
  value_.Clear();
}
inline float CollectionDef_FloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.FloatList.value)
  return value_.Get(index);
}
inline void CollectionDef_FloatList::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.CollectionDef.FloatList.value)
}
inline void CollectionDef_FloatList::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.FloatList.value)
}
inline const ::google::protobuf::RepeatedField< float >&
CollectionDef_FloatList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.FloatList.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
CollectionDef_FloatList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.FloatList.value)
  return &value_;
}

// -------------------------------------------------------------------

// CollectionDef_AnyList

// repeated .google.protobuf.Any value = 1;
inline int CollectionDef_AnyList::value_size() const {
  return value_.size();
}
inline void CollectionDef_AnyList::clear_value() {
  value_.Clear();
}
inline const ::google::protobuf::Any& CollectionDef_AnyList::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.AnyList.value)
  return value_.Get(index);
}
inline ::google::protobuf::Any* CollectionDef_AnyList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.AnyList.value)
  return value_.Mutable(index);
}
inline ::google::protobuf::Any* CollectionDef_AnyList::add_value() {
  // @@protoc_insertion_point(field_add:tensorflow.CollectionDef.AnyList.value)
  return value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
CollectionDef_AnyList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.CollectionDef.AnyList.value)
  return &value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
CollectionDef_AnyList::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.CollectionDef.AnyList.value)
  return value_;
}

// -------------------------------------------------------------------

// CollectionDef

// .tensorflow.CollectionDef.NodeList node_list = 1;
inline bool CollectionDef::has_node_list() const {
  return kind_case() == kNodeList;
}
inline void CollectionDef::set_has_node_list() {
  _oneof_case_[0] = kNodeList;
}
inline void CollectionDef::clear_node_list() {
  if (has_node_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.node_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_NodeList& CollectionDef::node_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.node_list)
  return has_node_list()
      ? *kind_.node_list_
      : ::tensorflow::CollectionDef_NodeList::default_instance();
}
inline ::tensorflow::CollectionDef_NodeList* CollectionDef::mutable_node_list() {
  if (!has_node_list()) {
    clear_kind();
    set_has_node_list();
    kind_.node_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_NodeList >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.node_list)
  return kind_.node_list_;
}
inline ::tensorflow::CollectionDef_NodeList* CollectionDef::release_node_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.node_list)
  if (has_node_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::CollectionDef_NodeList* temp = new ::tensorflow::CollectionDef_NodeList(*kind_.node_list_);
      kind_.node_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::CollectionDef_NodeList* temp = kind_.node_list_;
      kind_.node_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_node_list(::tensorflow::CollectionDef_NodeList* node_list) {
  clear_kind();
  if (node_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(node_list) == NULL) {
      GetArenaNoVirtual()->Own(node_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(node_list)) {
      ::tensorflow::CollectionDef_NodeList* new_node_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_NodeList >(
          GetArenaNoVirtual());
      new_node_list->CopyFrom(*node_list);
      node_list = new_node_list;
    }
    set_has_node_list();
    kind_.node_list_ = node_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.node_list)
}
inline  ::tensorflow::CollectionDef_NodeList* CollectionDef::unsafe_arena_release_node_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.node_list)
  if (has_node_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_NodeList* temp = kind_.node_list_;
    kind_.node_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void CollectionDef::unsafe_arena_set_allocated_node_list(::tensorflow::CollectionDef_NodeList* node_list) {
  clear_kind();
  if (node_list) {
    set_has_node_list();
    kind_.node_list_ = node_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.node_list)
}

// .tensorflow.CollectionDef.BytesList bytes_list = 2;
inline bool CollectionDef::has_bytes_list() const {
  return kind_case() == kBytesList;
}
inline void CollectionDef::set_has_bytes_list() {
  _oneof_case_[0] = kBytesList;
}
inline void CollectionDef::clear_bytes_list() {
  if (has_bytes_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.bytes_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_BytesList& CollectionDef::bytes_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.bytes_list)
  return has_bytes_list()
      ? *kind_.bytes_list_
      : ::tensorflow::CollectionDef_BytesList::default_instance();
}
inline ::tensorflow::CollectionDef_BytesList* CollectionDef::mutable_bytes_list() {
  if (!has_bytes_list()) {
    clear_kind();
    set_has_bytes_list();
    kind_.bytes_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_BytesList >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.bytes_list)
  return kind_.bytes_list_;
}
inline ::tensorflow::CollectionDef_BytesList* CollectionDef::release_bytes_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.bytes_list)
  if (has_bytes_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::CollectionDef_BytesList* temp = new ::tensorflow::CollectionDef_BytesList(*kind_.bytes_list_);
      kind_.bytes_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::CollectionDef_BytesList* temp = kind_.bytes_list_;
      kind_.bytes_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_bytes_list(::tensorflow::CollectionDef_BytesList* bytes_list) {
  clear_kind();
  if (bytes_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(bytes_list) == NULL) {
      GetArenaNoVirtual()->Own(bytes_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(bytes_list)) {
      ::tensorflow::CollectionDef_BytesList* new_bytes_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_BytesList >(
          GetArenaNoVirtual());
      new_bytes_list->CopyFrom(*bytes_list);
      bytes_list = new_bytes_list;
    }
    set_has_bytes_list();
    kind_.bytes_list_ = bytes_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.bytes_list)
}
inline  ::tensorflow::CollectionDef_BytesList* CollectionDef::unsafe_arena_release_bytes_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.bytes_list)
  if (has_bytes_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_BytesList* temp = kind_.bytes_list_;
    kind_.bytes_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void CollectionDef::unsafe_arena_set_allocated_bytes_list(::tensorflow::CollectionDef_BytesList* bytes_list) {
  clear_kind();
  if (bytes_list) {
    set_has_bytes_list();
    kind_.bytes_list_ = bytes_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.bytes_list)
}

// .tensorflow.CollectionDef.Int64List int64_list = 3;
inline bool CollectionDef::has_int64_list() const {
  return kind_case() == kInt64List;
}
inline void CollectionDef::set_has_int64_list() {
  _oneof_case_[0] = kInt64List;
}
inline void CollectionDef::clear_int64_list() {
  if (has_int64_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.int64_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_Int64List& CollectionDef::int64_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.int64_list)
  return has_int64_list()
      ? *kind_.int64_list_
      : ::tensorflow::CollectionDef_Int64List::default_instance();
}
inline ::tensorflow::CollectionDef_Int64List* CollectionDef::mutable_int64_list() {
  if (!has_int64_list()) {
    clear_kind();
    set_has_int64_list();
    kind_.int64_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_Int64List >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.int64_list)
  return kind_.int64_list_;
}
inline ::tensorflow::CollectionDef_Int64List* CollectionDef::release_int64_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.int64_list)
  if (has_int64_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::CollectionDef_Int64List* temp = new ::tensorflow::CollectionDef_Int64List(*kind_.int64_list_);
      kind_.int64_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::CollectionDef_Int64List* temp = kind_.int64_list_;
      kind_.int64_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_int64_list(::tensorflow::CollectionDef_Int64List* int64_list) {
  clear_kind();
  if (int64_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(int64_list) == NULL) {
      GetArenaNoVirtual()->Own(int64_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(int64_list)) {
      ::tensorflow::CollectionDef_Int64List* new_int64_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_Int64List >(
          GetArenaNoVirtual());
      new_int64_list->CopyFrom(*int64_list);
      int64_list = new_int64_list;
    }
    set_has_int64_list();
    kind_.int64_list_ = int64_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.int64_list)
}
inline  ::tensorflow::CollectionDef_Int64List* CollectionDef::unsafe_arena_release_int64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.int64_list)
  if (has_int64_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_Int64List* temp = kind_.int64_list_;
    kind_.int64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void CollectionDef::unsafe_arena_set_allocated_int64_list(::tensorflow::CollectionDef_Int64List* int64_list) {
  clear_kind();
  if (int64_list) {
    set_has_int64_list();
    kind_.int64_list_ = int64_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.int64_list)
}

// .tensorflow.CollectionDef.FloatList float_list = 4;
inline bool CollectionDef::has_float_list() const {
  return kind_case() == kFloatList;
}
inline void CollectionDef::set_has_float_list() {
  _oneof_case_[0] = kFloatList;
}
inline void CollectionDef::clear_float_list() {
  if (has_float_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.float_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_FloatList& CollectionDef::float_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.float_list)
  return has_float_list()
      ? *kind_.float_list_
      : ::tensorflow::CollectionDef_FloatList::default_instance();
}
inline ::tensorflow::CollectionDef_FloatList* CollectionDef::mutable_float_list() {
  if (!has_float_list()) {
    clear_kind();
    set_has_float_list();
    kind_.float_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_FloatList >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.float_list)
  return kind_.float_list_;
}
inline ::tensorflow::CollectionDef_FloatList* CollectionDef::release_float_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.float_list)
  if (has_float_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::CollectionDef_FloatList* temp = new ::tensorflow::CollectionDef_FloatList(*kind_.float_list_);
      kind_.float_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::CollectionDef_FloatList* temp = kind_.float_list_;
      kind_.float_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_float_list(::tensorflow::CollectionDef_FloatList* float_list) {
  clear_kind();
  if (float_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(float_list) == NULL) {
      GetArenaNoVirtual()->Own(float_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(float_list)) {
      ::tensorflow::CollectionDef_FloatList* new_float_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_FloatList >(
          GetArenaNoVirtual());
      new_float_list->CopyFrom(*float_list);
      float_list = new_float_list;
    }
    set_has_float_list();
    kind_.float_list_ = float_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.float_list)
}
inline  ::tensorflow::CollectionDef_FloatList* CollectionDef::unsafe_arena_release_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.float_list)
  if (has_float_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_FloatList* temp = kind_.float_list_;
    kind_.float_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void CollectionDef::unsafe_arena_set_allocated_float_list(::tensorflow::CollectionDef_FloatList* float_list) {
  clear_kind();
  if (float_list) {
    set_has_float_list();
    kind_.float_list_ = float_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.float_list)
}

// .tensorflow.CollectionDef.AnyList any_list = 5;
inline bool CollectionDef::has_any_list() const {
  return kind_case() == kAnyList;
}
inline void CollectionDef::set_has_any_list() {
  _oneof_case_[0] = kAnyList;
}
inline void CollectionDef::clear_any_list() {
  if (has_any_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete kind_.any_list_;
    }
    clear_has_kind();
  }
}
inline  const ::tensorflow::CollectionDef_AnyList& CollectionDef::any_list() const {
  // @@protoc_insertion_point(field_get:tensorflow.CollectionDef.any_list)
  return has_any_list()
      ? *kind_.any_list_
      : ::tensorflow::CollectionDef_AnyList::default_instance();
}
inline ::tensorflow::CollectionDef_AnyList* CollectionDef::mutable_any_list() {
  if (!has_any_list()) {
    clear_kind();
    set_has_any_list();
    kind_.any_list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_AnyList >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CollectionDef.any_list)
  return kind_.any_list_;
}
inline ::tensorflow::CollectionDef_AnyList* CollectionDef::release_any_list() {
  // @@protoc_insertion_point(field_release:tensorflow.CollectionDef.any_list)
  if (has_any_list()) {
    clear_has_kind();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::CollectionDef_AnyList* temp = new ::tensorflow::CollectionDef_AnyList(*kind_.any_list_);
      kind_.any_list_ = NULL;
      return temp;
    } else {
      ::tensorflow::CollectionDef_AnyList* temp = kind_.any_list_;
      kind_.any_list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void CollectionDef::set_allocated_any_list(::tensorflow::CollectionDef_AnyList* any_list) {
  clear_kind();
  if (any_list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(any_list) == NULL) {
      GetArenaNoVirtual()->Own(any_list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(any_list)) {
      ::tensorflow::CollectionDef_AnyList* new_any_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::CollectionDef_AnyList >(
          GetArenaNoVirtual());
      new_any_list->CopyFrom(*any_list);
      any_list = new_any_list;
    }
    set_has_any_list();
    kind_.any_list_ = any_list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CollectionDef.any_list)
}
inline  ::tensorflow::CollectionDef_AnyList* CollectionDef::unsafe_arena_release_any_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CollectionDef.any_list)
  if (has_any_list()) {
    clear_has_kind();
    ::tensorflow::CollectionDef_AnyList* temp = kind_.any_list_;
    kind_.any_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void CollectionDef::unsafe_arena_set_allocated_any_list(::tensorflow::CollectionDef_AnyList* any_list) {
  clear_kind();
  if (any_list) {
    set_has_any_list();
    kind_.any_list_ = any_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CollectionDef.any_list)
}

inline bool CollectionDef::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void CollectionDef::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline CollectionDef::KindCase CollectionDef::kind_case() const {
  return CollectionDef::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TensorInfo_CooSparse

// string values_tensor_name = 1;
inline void TensorInfo_CooSparse::clear_values_tensor_name() {
  values_tensor_name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TensorInfo_CooSparse::values_tensor_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.CooSparse.values_tensor_name)
  return values_tensor_name_.Get();
}
inline void TensorInfo_CooSparse::set_values_tensor_name(const ::std::string& value) {
  
  values_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.CooSparse.values_tensor_name)
}
#if LANG_CXX11
inline void TensorInfo_CooSparse::set_values_tensor_name(::std::string&& value) {
  
  values_tensor_name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorInfo.CooSparse.values_tensor_name)
}
#endif
inline void TensorInfo_CooSparse::set_values_tensor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  values_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorInfo.CooSparse.values_tensor_name)
}
inline void TensorInfo_CooSparse::set_values_tensor_name(const char* value,
    size_t size) {
  
  values_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorInfo.CooSparse.values_tensor_name)
}
inline ::std::string* TensorInfo_CooSparse::mutable_values_tensor_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.CooSparse.values_tensor_name)
  return values_tensor_name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorInfo_CooSparse::release_values_tensor_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.CooSparse.values_tensor_name)
  
  return values_tensor_name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorInfo_CooSparse::unsafe_arena_release_values_tensor_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorInfo.CooSparse.values_tensor_name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return values_tensor_name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TensorInfo_CooSparse::set_allocated_values_tensor_name(::std::string* values_tensor_name) {
  if (values_tensor_name != NULL) {
    
  } else {
    
  }
  values_tensor_name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), values_tensor_name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.CooSparse.values_tensor_name)
}
inline void TensorInfo_CooSparse::unsafe_arena_set_allocated_values_tensor_name(
    ::std::string* values_tensor_name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (values_tensor_name != NULL) {
    
  } else {
    
  }
  values_tensor_name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      values_tensor_name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.CooSparse.values_tensor_name)
}

// string indices_tensor_name = 2;
inline void TensorInfo_CooSparse::clear_indices_tensor_name() {
  indices_tensor_name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TensorInfo_CooSparse::indices_tensor_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
  return indices_tensor_name_.Get();
}
inline void TensorInfo_CooSparse::set_indices_tensor_name(const ::std::string& value) {
  
  indices_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
}
#if LANG_CXX11
inline void TensorInfo_CooSparse::set_indices_tensor_name(::std::string&& value) {
  
  indices_tensor_name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
}
#endif
inline void TensorInfo_CooSparse::set_indices_tensor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  indices_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
}
inline void TensorInfo_CooSparse::set_indices_tensor_name(const char* value,
    size_t size) {
  
  indices_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
}
inline ::std::string* TensorInfo_CooSparse::mutable_indices_tensor_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
  return indices_tensor_name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorInfo_CooSparse::release_indices_tensor_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
  
  return indices_tensor_name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorInfo_CooSparse::unsafe_arena_release_indices_tensor_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return indices_tensor_name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TensorInfo_CooSparse::set_allocated_indices_tensor_name(::std::string* indices_tensor_name) {
  if (indices_tensor_name != NULL) {
    
  } else {
    
  }
  indices_tensor_name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), indices_tensor_name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
}
inline void TensorInfo_CooSparse::unsafe_arena_set_allocated_indices_tensor_name(
    ::std::string* indices_tensor_name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (indices_tensor_name != NULL) {
    
  } else {
    
  }
  indices_tensor_name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      indices_tensor_name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.CooSparse.indices_tensor_name)
}

// string dense_shape_tensor_name = 3;
inline void TensorInfo_CooSparse::clear_dense_shape_tensor_name() {
  dense_shape_tensor_name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TensorInfo_CooSparse::dense_shape_tensor_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
  return dense_shape_tensor_name_.Get();
}
inline void TensorInfo_CooSparse::set_dense_shape_tensor_name(const ::std::string& value) {
  
  dense_shape_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
}
#if LANG_CXX11
inline void TensorInfo_CooSparse::set_dense_shape_tensor_name(::std::string&& value) {
  
  dense_shape_tensor_name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
}
#endif
inline void TensorInfo_CooSparse::set_dense_shape_tensor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dense_shape_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
}
inline void TensorInfo_CooSparse::set_dense_shape_tensor_name(const char* value,
    size_t size) {
  
  dense_shape_tensor_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
}
inline ::std::string* TensorInfo_CooSparse::mutable_dense_shape_tensor_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
  return dense_shape_tensor_name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorInfo_CooSparse::release_dense_shape_tensor_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
  
  return dense_shape_tensor_name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorInfo_CooSparse::unsafe_arena_release_dense_shape_tensor_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return dense_shape_tensor_name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TensorInfo_CooSparse::set_allocated_dense_shape_tensor_name(::std::string* dense_shape_tensor_name) {
  if (dense_shape_tensor_name != NULL) {
    
  } else {
    
  }
  dense_shape_tensor_name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dense_shape_tensor_name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
}
inline void TensorInfo_CooSparse::unsafe_arena_set_allocated_dense_shape_tensor_name(
    ::std::string* dense_shape_tensor_name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (dense_shape_tensor_name != NULL) {
    
  } else {
    
  }
  dense_shape_tensor_name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      dense_shape_tensor_name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.CooSparse.dense_shape_tensor_name)
}

// -------------------------------------------------------------------

// TensorInfo

// string name = 1;
inline bool TensorInfo::has_name() const {
  return encoding_case() == kName;
}
inline void TensorInfo::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void TensorInfo::clear_name() {
  if (has_name()) {
    encoding_.name_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_encoding();
  }
}
inline const ::std::string& TensorInfo::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.name)
  if (has_name()) {
    return encoding_.name_.Get();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TensorInfo::set_name(const ::std::string& value) {
  if (!has_name()) {
    clear_encoding();
    set_has_name();
    encoding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  encoding_.name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.name)
}
#if LANG_CXX11
inline void TensorInfo::set_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.name)
  if (!has_name()) {
    clear_encoding();
    set_has_name();
    encoding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  encoding_.name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorInfo.name)
}
#endif
inline void TensorInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_name()) {
    clear_encoding();
    set_has_name();
    encoding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  encoding_.name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorInfo.name)
}
inline void TensorInfo::set_name(const char* value,
                             size_t size) {
  if (!has_name()) {
    clear_encoding();
    set_has_name();
    encoding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  encoding_.name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorInfo.name)
}
inline ::std::string* TensorInfo::mutable_name() {
  if (!has_name()) {
    clear_encoding();
    set_has_name();
    encoding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return encoding_.name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.name)
}
inline ::std::string* TensorInfo::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.name)
  if (has_name()) {
    clear_has_encoding();
    return encoding_.name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline ::std::string* TensorInfo::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorInfo.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_name()) {
    clear_has_encoding();
    return encoding_.name_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void TensorInfo::set_allocated_name(::std::string* name) {
  if (!has_name()) {
    encoding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_encoding();
  if (name != NULL) {
    set_has_name();
    encoding_.name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.name)
}
inline void TensorInfo::unsafe_arena_set_allocated_name(::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_name()) {
    encoding_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_encoding();
  if (name) {
    set_has_name();
    encoding_.name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.name)
}

// .tensorflow.TensorInfo.CooSparse coo_sparse = 4;
inline bool TensorInfo::has_coo_sparse() const {
  return encoding_case() == kCooSparse;
}
inline void TensorInfo::set_has_coo_sparse() {
  _oneof_case_[0] = kCooSparse;
}
inline void TensorInfo::clear_coo_sparse() {
  if (has_coo_sparse()) {
    if (GetArenaNoVirtual() == NULL) {
      delete encoding_.coo_sparse_;
    }
    clear_has_encoding();
  }
}
inline  const ::tensorflow::TensorInfo_CooSparse& TensorInfo::coo_sparse() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.coo_sparse)
  return has_coo_sparse()
      ? *encoding_.coo_sparse_
      : ::tensorflow::TensorInfo_CooSparse::default_instance();
}
inline ::tensorflow::TensorInfo_CooSparse* TensorInfo::mutable_coo_sparse() {
  if (!has_coo_sparse()) {
    clear_encoding();
    set_has_coo_sparse();
    encoding_.coo_sparse_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::TensorInfo_CooSparse >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.coo_sparse)
  return encoding_.coo_sparse_;
}
inline ::tensorflow::TensorInfo_CooSparse* TensorInfo::release_coo_sparse() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.coo_sparse)
  if (has_coo_sparse()) {
    clear_has_encoding();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::TensorInfo_CooSparse* temp = new ::tensorflow::TensorInfo_CooSparse(*encoding_.coo_sparse_);
      encoding_.coo_sparse_ = NULL;
      return temp;
    } else {
      ::tensorflow::TensorInfo_CooSparse* temp = encoding_.coo_sparse_;
      encoding_.coo_sparse_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void TensorInfo::set_allocated_coo_sparse(::tensorflow::TensorInfo_CooSparse* coo_sparse) {
  clear_encoding();
  if (coo_sparse) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(coo_sparse) == NULL) {
      GetArenaNoVirtual()->Own(coo_sparse);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(coo_sparse)) {
      ::tensorflow::TensorInfo_CooSparse* new_coo_sparse = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::TensorInfo_CooSparse >(
          GetArenaNoVirtual());
      new_coo_sparse->CopyFrom(*coo_sparse);
      coo_sparse = new_coo_sparse;
    }
    set_has_coo_sparse();
    encoding_.coo_sparse_ = coo_sparse;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.coo_sparse)
}
inline  ::tensorflow::TensorInfo_CooSparse* TensorInfo::unsafe_arena_release_coo_sparse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorInfo.coo_sparse)
  if (has_coo_sparse()) {
    clear_has_encoding();
    ::tensorflow::TensorInfo_CooSparse* temp = encoding_.coo_sparse_;
    encoding_.coo_sparse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void TensorInfo::unsafe_arena_set_allocated_coo_sparse(::tensorflow::TensorInfo_CooSparse* coo_sparse) {
  clear_encoding();
  if (coo_sparse) {
    set_has_coo_sparse();
    encoding_.coo_sparse_ = coo_sparse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorInfo.coo_sparse)
}

// .tensorflow.DataType dtype = 2;
inline void TensorInfo::clear_dtype() {
  dtype_ = 0;
}
inline ::tensorflow::DataType TensorInfo::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.dtype)
  return static_cast< ::tensorflow::DataType >(dtype_);
}
inline void TensorInfo::set_dtype(::tensorflow::DataType value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorInfo.dtype)
}

// .tensorflow.TensorShapeProto tensor_shape = 3;
inline bool TensorInfo::has_tensor_shape() const {
  return this != internal_default_instance() && tensor_shape_ != NULL;
}
inline void TensorInfo::clear_tensor_shape() {
  if (GetArenaNoVirtual() == NULL && tensor_shape_ != NULL) delete tensor_shape_;
  tensor_shape_ = NULL;
}
inline const ::tensorflow::TensorShapeProto& TensorInfo::tensor_shape() const {
  const ::tensorflow::TensorShapeProto* p = tensor_shape_;
  // @@protoc_insertion_point(field_get:tensorflow.TensorInfo.tensor_shape)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::TensorShapeProto*>(
      &::tensorflow::_TensorShapeProto_default_instance_);
}
inline ::tensorflow::TensorShapeProto* TensorInfo::mutable_tensor_shape() {
  
  if (tensor_shape_ == NULL) {
    _slow_mutable_tensor_shape();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorInfo.tensor_shape)
  return tensor_shape_;
}
inline ::tensorflow::TensorShapeProto* TensorInfo::release_tensor_shape() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorInfo.tensor_shape)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_tensor_shape();
  } else {
    ::tensorflow::TensorShapeProto* temp = tensor_shape_;
    tensor_shape_ = NULL;
    return temp;
  }
}
inline  void TensorInfo::set_allocated_tensor_shape(::tensorflow::TensorShapeProto* tensor_shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tensor_shape_;
  }
  if (tensor_shape != NULL) {
    _slow_set_allocated_tensor_shape(message_arena, &tensor_shape);
  }
  tensor_shape_ = tensor_shape;
  if (tensor_shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorInfo.tensor_shape)
}

inline bool TensorInfo::has_encoding() const {
  return encoding_case() != ENCODING_NOT_SET;
}
inline void TensorInfo::clear_has_encoding() {
  _oneof_case_[0] = ENCODING_NOT_SET;
}
inline TensorInfo::EncodingCase TensorInfo::encoding_case() const {
  return TensorInfo::EncodingCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SignatureDef

// map<string, .tensorflow.TensorInfo> inputs = 1;
inline int SignatureDef::inputs_size() const {
  return inputs_.size();
}
inline void SignatureDef::clear_inputs() {
  inputs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::TensorInfo >&
SignatureDef::inputs() const {
  // @@protoc_insertion_point(field_map:tensorflow.SignatureDef.inputs)
  return inputs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::TensorInfo >*
SignatureDef::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.SignatureDef.inputs)
  return inputs_.MutableMap();
}

// map<string, .tensorflow.TensorInfo> outputs = 2;
inline int SignatureDef::outputs_size() const {
  return outputs_.size();
}
inline void SignatureDef::clear_outputs() {
  outputs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::TensorInfo >&
SignatureDef::outputs() const {
  // @@protoc_insertion_point(field_map:tensorflow.SignatureDef.outputs)
  return outputs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::TensorInfo >*
SignatureDef::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.SignatureDef.outputs)
  return outputs_.MutableMap();
}

// string method_name = 3;
inline void SignatureDef::clear_method_name() {
  method_name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& SignatureDef::method_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.SignatureDef.method_name)
  return method_name_.Get();
}
inline void SignatureDef::set_method_name(const ::std::string& value) {
  
  method_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.SignatureDef.method_name)
}
#if LANG_CXX11
inline void SignatureDef::set_method_name(::std::string&& value) {
  
  method_name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.SignatureDef.method_name)
}
#endif
inline void SignatureDef::set_method_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  method_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.SignatureDef.method_name)
}
inline void SignatureDef::set_method_name(const char* value,
    size_t size) {
  
  method_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.SignatureDef.method_name)
}
inline ::std::string* SignatureDef::mutable_method_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.SignatureDef.method_name)
  return method_name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SignatureDef::release_method_name() {
  // @@protoc_insertion_point(field_release:tensorflow.SignatureDef.method_name)
  
  return method_name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SignatureDef::unsafe_arena_release_method_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SignatureDef.method_name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return method_name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SignatureDef::set_allocated_method_name(::std::string* method_name) {
  if (method_name != NULL) {
    
  } else {
    
  }
  method_name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), method_name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SignatureDef.method_name)
}
inline void SignatureDef::unsafe_arena_set_allocated_method_name(
    ::std::string* method_name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (method_name != NULL) {
    
  } else {
    
  }
  method_name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      method_name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SignatureDef.method_name)
}

// -------------------------------------------------------------------

// AssetFileDef

// .tensorflow.TensorInfo tensor_info = 1;
inline bool AssetFileDef::has_tensor_info() const {
  return this != internal_default_instance() && tensor_info_ != NULL;
}
inline void AssetFileDef::clear_tensor_info() {
  if (GetArenaNoVirtual() == NULL && tensor_info_ != NULL) delete tensor_info_;
  tensor_info_ = NULL;
}
inline const ::tensorflow::TensorInfo& AssetFileDef::tensor_info() const {
  const ::tensorflow::TensorInfo* p = tensor_info_;
  // @@protoc_insertion_point(field_get:tensorflow.AssetFileDef.tensor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::TensorInfo*>(
      &::tensorflow::_TensorInfo_default_instance_);
}
inline ::tensorflow::TensorInfo* AssetFileDef::mutable_tensor_info() {
  
  if (tensor_info_ == NULL) {
    _slow_mutable_tensor_info();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.AssetFileDef.tensor_info)
  return tensor_info_;
}
inline ::tensorflow::TensorInfo* AssetFileDef::release_tensor_info() {
  // @@protoc_insertion_point(field_release:tensorflow.AssetFileDef.tensor_info)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_tensor_info();
  } else {
    ::tensorflow::TensorInfo* temp = tensor_info_;
    tensor_info_ = NULL;
    return temp;
  }
}
inline  void AssetFileDef::set_allocated_tensor_info(::tensorflow::TensorInfo* tensor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tensor_info_;
  }
  if (tensor_info != NULL) {
    _slow_set_allocated_tensor_info(message_arena, &tensor_info);
  }
  tensor_info_ = tensor_info;
  if (tensor_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AssetFileDef.tensor_info)
}

// string filename = 2;
inline void AssetFileDef::clear_filename() {
  filename_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& AssetFileDef::filename() const {
  // @@protoc_insertion_point(field_get:tensorflow.AssetFileDef.filename)
  return filename_.Get();
}
inline void AssetFileDef::set_filename(const ::std::string& value) {
  
  filename_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.AssetFileDef.filename)
}
#if LANG_CXX11
inline void AssetFileDef::set_filename(::std::string&& value) {
  
  filename_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.AssetFileDef.filename)
}
#endif
inline void AssetFileDef::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.AssetFileDef.filename)
}
inline void AssetFileDef::set_filename(const char* value,
    size_t size) {
  
  filename_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.AssetFileDef.filename)
}
inline ::std::string* AssetFileDef::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.AssetFileDef.filename)
  return filename_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* AssetFileDef::release_filename() {
  // @@protoc_insertion_point(field_release:tensorflow.AssetFileDef.filename)
  
  return filename_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* AssetFileDef::unsafe_arena_release_filename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.AssetFileDef.filename)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return filename_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void AssetFileDef::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AssetFileDef.filename)
}
inline void AssetFileDef::unsafe_arena_set_allocated_filename(
    ::std::string* filename) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      filename, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.AssetFileDef.filename)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmeta_5fgraph_2eproto__INCLUDED
